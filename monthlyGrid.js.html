<script>
var MonthlyGrid = (function() {
  // Private variables
  let _initialized = false;
  let _currentMonth = new Date().getMonth();
  let _currentYear = new Date().getFullYear();
  let _categories = [];
  let _transactions = [];
  let _isLoading = false;
  
  // DOM element cache for performance
  const _elements = {};
  
  /**
   * Get an element by ID with caching
   */
  function getElement(id) {
    if (!_elements[id]) {
      _elements[id] = document.getElementById(id);
    }
    return _elements[id];
  }

  /**
   * Initialize the Monthly Grid
   */
  function init(containerId) {
    if (_initialized && !containerId) {
      return;
    }
    
    console.log('Initializing Monthly Grid View...');
    
    // Find and store container element
    if (containerId) {
      const container = document.getElementById(containerId);
      if (container) {
        _elements['monthly-grid-container'] = container;
        console.log("Found container, storing for rendering:", containerId);
      } else {
        console.error("Container not found:", containerId);
        return;
      }
    } else {
      // Try to find the default container
      const defaultContainer = document.getElementById("monthly-grid-container");
      if (!defaultContainer) {
        console.error("Default grid container not found");
        return;
      }
      _elements['monthly-grid-container'] = defaultContainer;
    }
    
    // Set up event handlers
    bindEvents();
    
    // Load real data from spreadsheet
    loadRealExpenseData();
    
    // Prevent body scrolling on mobile
    if (window.innerWidth <= 768) {
      document.body.style.overflow = 'hidden';
      
      // Allow the grid container to scroll
      const container = getElement('monthly-grid-container');
      if (container) {
        container.style.overflow = 'auto';
      }
    }
    
    _initialized = true;
    console.log('Monthly Grid View initialized');
  }
  
  /**
   * Load real expense data from spreadsheet for current month
   */
  function loadRealExpenseData() {
    if (_isLoading) {
      console.log('Already loading expense data, skipping...');
      return;
    }
    
    _isLoading = true;
    
    // Debug logging
    const currentDate = new Date(_currentYear, _currentMonth, 1);
    const monthName = currentDate.toLocaleString('default', { month: 'long' });
    console.log('=== MONTH DEBUG ===');
    console.log('UI should show:', monthName, _currentYear);
    console.log('_currentMonth value:', _currentMonth, '(0=Jan, 11=Dec)');
    console.log('Sending to server: month=' + _currentMonth + ', year=' + _currentYear);
    console.log('Expected server data: ' + monthName + ' ' + _currentYear);
    console.log('==================');
    
    console.log('Loading real expense data for month:', _currentMonth, 'year:', _currentYear);
    
    // Show loading indicator
    showLoadingIndicator();
    
    // Clear existing data
    _transactions = [];
    _categories = [];
    
    // STEP 1: Load active categories first
    loadActiveCategories()
      .then(categories => {
        console.log('Categories loaded, now loading expenses...');
        
        // STEP 2: Load expenses for the current month
        if (!window.API || typeof API.getExpenseData !== 'function') {
          throw new Error('API.getExpenseData function not found. Check API.html file.');
        }
        
        // Ensure parameters are numbers
        const monthParam = parseInt(_currentMonth);
        const yearParam = parseInt(_currentYear);
        
        console.log('Calling API.getExpenseData with params:', monthParam, yearParam);
        
        return new Promise((resolve, reject) => {
          API.getExpenseData(
            monthParam,
            yearParam,
            function(result) {
              console.log('SUCCESS: API returned:', result);
              
              if (!result) {
                reject('Server returned null result');
                return;
              }
              
              if (!result.success) {
                reject('Server returned failure: ' + (result.error || 'No error message'));
                return;
              }
              
              if (!result.expenses || !Array.isArray(result.expenses)) {
                reject('Server returned invalid expenses data. Type: ' + typeof result.expenses);
                return;
              }
              
              resolve(result.expenses);
            },
            function(error) {
              reject('Server function call failed: ' + error);
            }
          );
        });
      })
      .then(expenses => {
        console.log('Processing ' + expenses.length + ' expenses...');
        
        // STEP 3: Process the expense data (no category creation)
        processRealExpenseData(expenses);
        
        // STEP 4: Render the grid with real data
        renderGrid();
        
        console.log(`SUCCESS: Loaded ${_transactions.length} transactions for ${_currentMonth}/${_currentYear}`);
        hideLoadingIndicator();
        _isLoading = false;
      })
      .catch(error => {
        console.error('FAILED: Error loading expense data:', error);
        showErrorMessage('Failed to load data: ' + error);
        hideLoadingIndicator();
        _isLoading = false;
      });
  }
  
  /**
   * Parse category string to extract name and emoji
   * Format: "Business 💼" -> {name: "Business", emoji: "💼"}
   */
  function parseCategoryNameAndEmoji(categoryString) {
    // Split by space and check if last part is an emoji
    const parts = categoryString.trim().split(' ');
    
    if (parts.length >= 2) {
      // Check if the last part contains emoji characters
      const lastPart = parts[parts.length - 1];
      const emojiRegex = /[\u{1F600}-\u{1F6FF}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
      
      if (emojiRegex.test(lastPart)) {
        // Last part contains emoji, split name and emoji
        const name = parts.slice(0, -1).join(' ');
        const emoji = lastPart;
        return { name, emoji };
      }
    }
    
    // No emoji found, return the whole string as name
    return { name: categoryString, emoji: '' };
  }
  
  /**
   * Load categories exactly like QuickExpenseEntry does - FIXED to store parsed categories
   */
  function loadActiveCategories() {
    console.log('Loading categories from localStorage and API...');
    
    return new Promise((resolve, reject) => {
      // First try to load from local storage for immediate display
      const cachedCategories = localStorage.getItem('simbudget_categories');
      const activeCategories = localStorage.getItem('simbudget_active_categories');
      
      if (cachedCategories && activeCategories) {
        try {
          const allCategories = JSON.parse(cachedCategories);
          const active = JSON.parse(activeCategories);
          
          console.log('All categories from cache:', allCategories);
          console.log('Active categories list:', active);
          
          // FIXED: Parse categories immediately and store in correct format
          const parsedActiveCategories = allCategories
            .filter(cat => {
              const categoryName = typeof cat === 'string' ? cat : cat.name;
              return active.includes(categoryName);
            })
            .map(cat => {
              const categoryString = typeof cat === 'string' ? cat : cat.name;
              const parsed = parseCategoryNameAndEmoji(categoryString);
              return {
                id: parsed.name,        // Clean name as ID for matching
                name: parsed.name,      // Clean name without emoji
                emoji: parsed.emoji,    // Extracted emoji
                active: true
              };
            });
          
          // Store PARSED categories in _categories
          _categories = parsedActiveCategories;
          
          console.log('Stored parsed active categories:', parsedActiveCategories);
          resolve(parsedActiveCategories);
          return;
        } catch (e) {
          console.error('Error parsing cached categories:', e);
        }
      }
      
      // If API exists, use it to load categories
      if (window.API && typeof API.getCategories === 'function') {
        API.getCategories(
          function(result) {
            if (result && result.success) {
              if (result.categories && result.activeCategories) {
                // FIXED: Parse categories immediately
                const parsedActiveCategories = result.categories
                  .filter(cat => result.activeCategories.includes(cat))
                  .map(cat => {
                    const parsed = parseCategoryNameAndEmoji(cat);
                    return {
                      id: parsed.name,        // Clean name as ID for matching
                      name: parsed.name,      // Clean name without emoji
                      emoji: parsed.emoji,    // Extracted emoji
                      active: true
                    };
                  });
                
                // Cache the full categories array (for other components)
                localStorage.setItem('simbudget_categories', JSON.stringify(result.categories));
                localStorage.setItem('simbudget_active_categories', JSON.stringify(result.activeCategories));
                
                // Store PARSED categories in _categories
                _categories = parsedActiveCategories;
                
                console.log('Loaded and parsed active categories from API:', parsedActiveCategories);
                resolve(parsedActiveCategories);
              } else {
                reject('No categories in API result');
              }
            } else {
              reject('API call failed');
            }
          },
          function(error) {
            console.error('Error loading categories:', error);
            reject(error);
          }
        );
      } else {
        reject('API.getCategories not available');
      }
    });
  }

  /**
   * Parse date string in format "DD MMM YYYY" (e.g., "28 Feb 2025")
   * Returns a Date object or null if parsing fails
   */
  function parseSpreadsheetDate(dateString) {
    if (!dateString || typeof dateString !== 'string') {
      return null;
    }
    
    // Clean the string and split by spaces
    const parts = dateString.trim().split(/\s+/);
    if (parts.length !== 3) {
      console.warn('Invalid date format, expected "DD MMM YYYY":', dateString);
      return null;
    }
    
    const [dayStr, monthStr, yearStr] = parts;
    
    // Parse day
    const day = parseInt(dayStr);
    if (isNaN(day) || day < 1 || day > 31) {
      console.warn('Invalid day in date:', dateString);
      return null;
    }
    
    // Parse year
    const year = parseInt(yearStr);
    if (isNaN(year) || year < 1900 || year > 2100) {
      console.warn('Invalid year in date:', dateString);
      return null;
    }
    
    // Parse month (convert month abbreviation to 0-based index)
    const monthMap = {
      'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
      'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
    };
    
    const month = monthMap[monthStr];
    if (month === undefined) {
      console.warn('Invalid month in date:', dateString);
      return null;
    }
    
    // Create date using local timezone to avoid timezone shifts
    const date = new Date(year, month, day, 12, 0, 0, 0); // Set to noon to avoid DST issues
    
    // Verify the date is valid (handles cases like Feb 30)
    if (date.getDate() !== day || date.getMonth() !== month || date.getFullYear() !== year) {
      console.warn('Date components changed during creation, invalid date:', dateString);
      return null;
    }
    
    console.log(`Parsed "${dateString}" -> Day: ${date.getDate()}, Month: ${date.getMonth()}, Year: ${date.getFullYear()}`);
    return date;
  }

  /**
   * Process real expense data from spreadsheet (expenses only, no categories)
   */
  function processRealExpenseData(expenses) {
    console.log('Processing expense data:', expenses.length, 'items');
    
    const processedTransactions = [];
    
    // Process each expense
    expenses.forEach((expense, index) => {
      // Skip empty rows
      if (!expense.category || !expense.amount) {
        console.log('Skipping expense', index, '- missing category or amount:', expense);
        return;
      }
      
      // Parse date - ENHANCED with robust parsing
      let expenseDate;
      
      if (expense.date instanceof Date) {
        expenseDate = expense.date;
        console.log(`Expense ${index}: Date is already Date object:`, expense.date.toDateString());
      } else if (expense.date) {
        // Try our custom parser first
        expenseDate = parseSpreadsheetDate(expense.date);
        
        if (!expenseDate) {
          // Fallback to standard Date parsing
          console.log(`Expense ${index}: Custom parsing failed, trying standard Date() for:`, expense.date);
          expenseDate = new Date(expense.date);
          
          if (isNaN(expenseDate.getTime())) {
            console.warn(`Expense ${index}: Both parsing methods failed for date:`, expense.date);
            return;
          }
        }
        
        console.log(`Expense ${index}: Successfully parsed "${expense.date}" -> ${expenseDate.toDateString()} (Day: ${expenseDate.getDate()})`);
      } else {
        console.warn('No date for expense', index, ':', expense);
        return;
      }
      
      // Parse amount
      const amount = parseFloat(expense.amount);
      if (isNaN(amount) || amount <= 0) {
        console.warn('Invalid amount for expense', index, ':', expense);
        return;
      }
      
      // Parse category to get clean name (remove emoji)
      const parsed = parseCategoryNameAndEmoji(expense.category.trim());
      const cleanCategory = parsed.name; // Use only the name part for matching
      
      // Create transaction object
      const transaction = {
        id: expense.rowIndex || `tx-real-${index}`,
        date: expenseDate,
        category: cleanCategory,  // Store clean category name for matching with active categories
        amount: amount,
        description: expense.name || expense.description || '',
        account: expense.account || 'Main Account',
        notes: expense.notes || ''
      };
      
      processedTransactions.push(transaction);
      console.log(`Processed: ${transaction.description} - €${amount} on ${expenseDate.toDateString()} [${cleanCategory}] (Day: ${expenseDate.getDate()})`);
    });
    
    // Store processed transactions (categories are loaded separately)
    _transactions = processedTransactions;
    
    console.log(`FINAL: Processed ${_transactions.length} transactions`);
    console.log('Sample transactions with days:');
    _transactions.slice(0, 5).forEach(tx => {
      console.log(`  - Day ${tx.date.getDate()}: ${tx.description} in "${tx.category}" on ${tx.date.toDateString()}`);
    });
    
    // Additional debugging: Check for transactions all on the same day
    const dayMap = {};
    _transactions.forEach(tx => {
      const day = tx.date.getDate();
      dayMap[day] = (dayMap[day] || 0) + 1;
    });
    console.log('Transactions per day:', dayMap);
  }
  
  /**
   * Show loading indicator with current month info
   */
  function showLoadingIndicator() {
    const container = getElement('monthly-grid-container');
    if (container) {
      const monthName = new Date(_currentYear, _currentMonth, 1)
        .toLocaleString('default', { month: 'long' });
      
      container.innerHTML = `
        <div class="loading-indicator">
          <div class="loading-spinner"></div>
          <p>Loading ${monthName} ${_currentYear} expenses...</p>
          <p><small>Reading month-specific data from spreadsheet</small></p>
        </div>
      `;
    }
  }
  
  /**
   * Hide loading indicator
   */
  function hideLoadingIndicator() {
    const loadingEl = document.querySelector('.loading-indicator');
    if (loadingEl) {
      loadingEl.remove();
    }
  }
  
  /**
   * Show error message
   */
  function showErrorMessage(message) {
    const container = getElement('monthly-grid-container');
    if (container) {
      container.innerHTML = `
        <div class="grid-error">
          <h3>❌ Failed to Load Data</h3>
          <p><strong>Error:</strong> ${message}</p>
          <p><strong>Expected:</strong> Reading from spreadsheet with expense data</p>
          <button class="retry-btn" onclick="MonthlyGrid.refresh()">Retry</button>
          <hr>
          <details>
            <summary>Debugging Info</summary>
            <p><strong>Check Code.gs:</strong> Make sure getExpenseData() function exists</p>
            <p><strong>Check API.html:</strong> Make sure API.getExpenseData() function exists</p>
            <p><strong>Check Logs:</strong> Open Apps Script editor → Executions tab</p>
            <p><strong>Check Sheet:</strong> Verify spreadsheet has expense data in correct format</p>
          </details>
        </div>
      `;
    }
  }
  
  /**
   * Refresh the grid by reloading data
   */
  function refresh() {
    console.log('Refreshing monthly grid...');
    _isLoading = false; // Reset loading flag
    loadRealExpenseData();
  }

  // Track modal states to prevent accidental popups
  let _isOpeningModal = false;
  let _isClosingModal = false;
  
  function bindEvents() {
    // Month navigation
    const prevMonth = getElement('prevMonth');
    const nextMonth = getElement('nextMonth');
    
    if (prevMonth) {
      prevMonth.addEventListener('click', function() {
        navigateMonth(-1);
      });
    }
    
    if (nextMonth) {
      nextMonth.addEventListener('click', function() {
        navigateMonth(1);
      });
    }
    
    // Cell click handlers (using event delegation)
    const gridContainer = getElement('monthly-grid-container');
    if (gridContainer) {
      gridContainer.addEventListener('click', function(e) {
        if (_isClosingModal) return;
        
        const cell = e.target.closest('.grid-cell[data-day][data-category]');
        if (cell) {
          e.stopPropagation();
          
          const day = cell.getAttribute('data-day');
          const category = cell.getAttribute('data-category');
          
          _isOpeningModal = true;
          openTransactionModal(day, category);
          
          setTimeout(() => {
            _isOpeningModal = false;
          }, 300);
        }
      });
    }
    
    // Remove existing event listeners first to prevent duplicates
    document.removeEventListener('click', handleDocumentClick);
    document.removeEventListener('touchend', handleTouchEnd);
    
    // Add event listeners
    document.addEventListener('click', handleDocumentClick);
    document.addEventListener('touchend', handleTouchEnd);
  }
  
  function handleDocumentClick(e) {
    if (_isOpeningModal || _isClosingModal) return;
    
    const modal = getElement('transaction-modal');
    if (!modal) return;
    
    const closeBtn = getElement('close-modal-btn');
    const modalCard = modal.querySelector('.modal-card');
    const addBtn = getElement('add-transaction-btn');
    
    if (closeBtn && (e.target === closeBtn || closeBtn.contains(e.target))) {
      e.preventDefault();
      e.stopPropagation();
      closeTransactionModal();
      return;
    }
    
    if (addBtn && (e.target === addBtn || addBtn.contains(e.target))) {
      e.preventDefault();
      e.stopPropagation();
      console.log('Add transaction button clicked - single event');
      addTransactionRow();
      return;
    }
    
    if (modal.classList.contains('visible')) {
      if (e.target === modal || 
          (e.target !== modalCard && !modalCard.contains(e.target))) {
        e.preventDefault();
        e.stopPropagation();
        closeTransactionModal();
        return;
      }
    }
  }
  
  function handleTouchEnd(e) {
    if (_isOpeningModal || _isClosingModal) return;
    
    const modal = getElement('transaction-modal');
    if (!modal || !modal.classList.contains('visible')) return;
    
    const modalCard = modal.querySelector('.modal-card');
    if (modalCard && !modalCard.contains(e.target) && e.target !== modalCard) {
      e.preventDefault();
      e.stopPropagation();
      closeTransactionModal();
    }
  }
  
  function navigateMonth(change) {
    _currentMonth += change;
    
    if (_currentMonth > 11) {
      _currentMonth = 0;
      _currentYear++;
    } else if (_currentMonth < 0) {
      _currentMonth = 11;
      _currentYear--;
    }
    
    updateMonthYearDisplay();
    
    // Reload data for new month
    console.log('Month changed to:', _currentMonth, '/', _currentYear, '- reloading data...');
    loadRealExpenseData();
  }
  
  function updateMonthYearDisplay() {
    const monthYearDisplay = getElement('monthYearDisplay');
    if (monthYearDisplay) {
      const monthName = new Date(_currentYear, _currentMonth, 1)
        .toLocaleString('default', { month: 'long' });
      
      console.log('DISPLAY UPDATE: Setting display to', monthName, _currentYear, '(internal month index:', _currentMonth, ')');
      
      monthYearDisplay.textContent = `${monthName} ${_currentYear}`;
    }
  }
  
  function renderGrid() {
    const container = getElement('monthly-grid-container');
    if (!container) {
      console.error("Grid container not found for rendering");
      return;
    }
    
    // Clear existing content
    container.innerHTML = '';
    
    // Get days in month
    const daysInMonth = new Date(_currentYear, _currentMonth + 1, 0).getDate();
    
    // Update month/year display
    updateMonthYearDisplay();
    
    // Categories are already parsed in _categories, just use them directly
    const categoriesToDisplay = _categories;
    
    if (categoriesToDisplay.length === 0) {
      container.innerHTML = `
        <div class="grid-error">
          <h3>No Categories Found</h3>
          <p>No expense categories found in your data for the current month.</p>
          <button class="retry-btn" onclick="MonthlyGrid.refresh()">Refresh</button>
        </div>
      `;
      return;
    }
    
    // Create table for grid
    const table = document.createElement('table');
    table.className = 'monthly-grid';
    
    // Add header with categories
    const thead = createTableHeader(categoriesToDisplay, daysInMonth);
    table.appendChild(thead);
    
    // Create rows for each day
    const tbody = createTableBody(categoriesToDisplay, daysInMonth);
    table.appendChild(tbody);
    
    // Add table to container
    container.appendChild(table);
    
    // Add the modal HTML after rendering the grid
    ensureModalExists();
  }
  
  function getTransactionsForDayAndCategory(day, categoryId) {
    // Convert categoryId to match the actual category names from data
    const transactions = _transactions.filter(tx => {
      if (!tx.date || !tx.category) return false;
      
      // Check if the day matches
      const txDay = tx.date.getDate();
      const txMonth = tx.date.getMonth();
      const txYear = tx.date.getFullYear();
      
      // Must be same day, month, and year
      const dayMatches = (txDay === day);
      const monthMatches = (txMonth === _currentMonth);
      const yearMatches = (txYear === _currentYear);
      
      // Fix category matching - categoryId might be slugified, but tx.category is the full name
      const categoryMatches = (
        tx.category === categoryId || 
        tx.category.toLowerCase().replace(/[^a-z0-9]/g, '') === categoryId ||
        categoryId === tx.category.toLowerCase().replace(/[^a-z0-9]/g, '')
      );
      
      const matches = dayMatches && monthMatches && yearMatches && categoryMatches;
      
      if (matches) {
        console.log(`Found transaction: ${tx.description} on day ${day} in category ${categoryId}`);
      }
      
      return matches;
    });
    
    return transactions;
  }
  
  function getMonthTotalForCategory(categoryId) {
    return _transactions
      .filter(tx => 
        tx.category === categoryId && 
        tx.date.getMonth() === _currentMonth &&
        tx.date.getFullYear() === _currentYear
      )
      .reduce((sum, tx) => sum + tx.amount, 0);
  }
  
  function getMonthGrandTotal() {
    return _transactions
      .filter(tx => 
        tx.date.getMonth() === _currentMonth &&
        tx.date.getFullYear() === _currentYear
      )
      .reduce((sum, tx) => sum + tx.amount, 0);
  }

  function ensureModalExists() {
    let modal = getElement('transaction-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'transaction-modal';
      modal.className = 'transaction-modal';
      modal.innerHTML = `
        <div class="modal-backdrop"></div>
        <div class="modal-card">
          <div class="modal-header">
            <h3 id="modal-title" class="modal-title">Transactions</h3>
            <button id="close-modal-btn" class="close-btn" aria-label="Close">
              <i class="material-icons">close</i>
            </button>
          </div>
          
          <div class="modal-content">
            <div id="transactions-list" class="transactions-list">
              <!-- Transactions will be populated here -->
            </div>
            
            <div class="modal-actions">
              <button id="add-transaction-btn" class="add-transaction-btn">
                <i class="material-icons">add</i> Add Transaction
              </button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      _elements['transaction-modal'] = modal;
      _elements['modal-title'] = modal.querySelector('#modal-title');
      _elements['transactions-list'] = modal.querySelector('#transactions-list');
      _elements['close-modal-btn'] = modal.querySelector('#close-modal-btn');
      _elements['add-transaction-btn'] = modal.querySelector('#add-transaction-btn');
    }
  }

  function createTableHeader(categories, daysInMonth) {
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    // Date column header
    const dateHeader = document.createElement('th');
    dateHeader.className = 'date-header';
    dateHeader.textContent = 'Date';
    headerRow.appendChild(dateHeader);
    
    // Category headers with monthly totals - FIXED EMOJI DUPLICATION
    categories.forEach(category => {
      const categoryHeader = document.createElement('th');
      categoryHeader.className = 'category-header';
      categoryHeader.setAttribute('data-category', category.id);
      categoryHeader.title = `${category.emoji} ${category.name}`;
      
      // Calculate monthly total for this category
      const monthlyTotal = getMonthTotalForCategory(category.id);
      
      // Create header content with emoji on top line, name on bottom (desktop only)
      const headerContent = document.createElement('div');
      headerContent.className = 'category-header-content';
      
      const categoryEmoji = document.createElement('div');
      categoryEmoji.className = 'category-emoji';
      categoryEmoji.textContent = category.emoji; // ONLY the emoji, no name
      
      const categoryName = document.createElement('div');
      categoryName.className = 'category-name';
      categoryName.textContent = category.name; // ONLY the clean name, no emoji
      
      const categoryTotal = document.createElement('div');
      categoryTotal.className = 'category-total';
      categoryTotal.textContent = `€${monthlyTotal.toFixed(0)}`;
      
      headerContent.appendChild(categoryEmoji);
      headerContent.appendChild(categoryName);
      headerContent.appendChild(categoryTotal);
      categoryHeader.appendChild(headerContent);
      
      headerRow.appendChild(categoryHeader);
    });
    
    // Daily total header
    const totalHeader = document.createElement('th');
    totalHeader.className = 'total-header';
    totalHeader.title = 'Daily Total';
    
    // Calculate monthly grand total
    const grandTotal = getMonthGrandTotal();
    
    const totalHeaderContent = document.createElement('div');
    totalHeaderContent.className = 'category-header-content';
    
    const totalEmoji = document.createElement('div');
    totalEmoji.className = 'category-emoji';
    totalEmoji.textContent = '💰';
    
    const totalName = document.createElement('div');
    totalName.className = 'category-name total-label';
    totalName.textContent = 'Total';
    
    const totalValue = document.createElement('div');
    totalValue.className = 'category-total';
    totalValue.textContent = `€${grandTotal.toFixed(0)}`;
    
    totalHeaderContent.appendChild(totalEmoji);
    totalHeaderContent.appendChild(totalName);
    totalHeaderContent.appendChild(totalValue);
    totalHeader.appendChild(totalHeaderContent);
    
    headerRow.appendChild(totalHeader);
    
    // Notes header
    const notesHeader = document.createElement('th');
    notesHeader.className = 'notes-header';
    notesHeader.title = 'Notes';
    
    const notesHeaderContent = document.createElement('div');
    notesHeaderContent.className = 'category-header-content';
    
    const notesEmoji = document.createElement('div');
    notesEmoji.className = 'category-emoji';
    notesEmoji.textContent = '📝';
    
    const notesName = document.createElement('div');
    notesName.className = 'category-name';
    notesName.textContent = 'Notes';
    
    notesHeaderContent.appendChild(notesEmoji);
    notesHeaderContent.appendChild(notesName);
    notesHeader.appendChild(notesHeaderContent);
    
    headerRow.appendChild(notesHeader);
    
    thead.appendChild(headerRow);
    return thead;
  }
  
  function createTableBody(categories, daysInMonth) {
    const tbody = document.createElement('tbody');
    
    // Get today's date for highlighting
    const today = new Date();
    const isCurrentMonth = today.getMonth() === _currentMonth && today.getFullYear() === _currentYear;
    const currentDay = today.getDate();
    
    // Create a row for each day
    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(_currentYear, _currentMonth, day);
      const dayOfWeek = dateObj.getDay();
      
      const isWeekend = (dayOfWeek === 0);
      const isToday = isCurrentMonth && day === currentDay;
        
      const row = document.createElement('tr');
      row.className = 'day-row';
      
      if (isWeekend) {
        row.classList.add('weekend-row');
      }
      
      if (isToday) {
        row.classList.add('today-row');
      }
      
      // Date cell
      const dateCell = document.createElement('td');
      dateCell.className = 'date-cell';
      if (isWeekend) dateCell.classList.add('weekend-cell');
      if (isToday) dateCell.classList.add('today-cell');
      
      const dayName = dateObj.toLocaleString('en-US', { weekday: 'short' });
      
      dateCell.innerHTML = `<div class="date-container">
                              <span class="day-number">${day}</span>
                              <span class="day-name">${dayName}</span>
                            </div>`;
      row.appendChild(dateCell);
      
      // Daily total for calculating at the end
      let dayTotal = 0;
      
      // Category cells
      categories.forEach(category => {
        const cell = document.createElement('td');
        cell.className = 'grid-cell';
        if (isWeekend) cell.classList.add('weekend-cell');
        if (isToday) cell.classList.add('today-cell');
        cell.setAttribute('data-day', day);
        cell.setAttribute('data-category', category.id);
        
        // Get transactions for this day and category
        const dayTransactions = getTransactionsForDayAndCategory(day, category.id);
        
        // If there are transactions, show amount and count
        if (dayTransactions.length > 0) {
          const amount = dayTransactions.reduce((sum, tx) => sum + tx.amount, 0);
          dayTotal += amount;
          
          // Determine color based on amount ranges (improved thresholds)
          let colorClass = 'amount-large';
          if (amount <= 30) {
            colorClass = 'amount-small';
          } else if (amount <= 75) {
            colorClass = 'amount-medium';
          }
          
          cell.innerHTML = `<div class="cell-content ${colorClass}">
                              <span class="amount">€${amount.toFixed(0)}</span>
                              <span class="transaction-count">(${dayTransactions.length})</span>
                            </div>`;
        }
        
        row.appendChild(cell);
      });
      
      // Daily total cell
      const totalCell = document.createElement('td');
      totalCell.className = 'total-cell';
      if (isWeekend) totalCell.classList.add('weekend-cell');
      if (isToday) totalCell.classList.add('today-cell');
      
      if (dayTotal > 0) {
        totalCell.innerHTML = `<div class="total-amount">€${dayTotal.toFixed(0)}</div>`;
      }
      
      row.appendChild(totalCell);
      
      // Notes cell
      const notesCell = document.createElement('td');
      notesCell.className = 'notes-cell';
      if (isWeekend) notesCell.classList.add('weekend-cell');
      if (isToday) notesCell.classList.add('today-cell');
      
      notesCell.innerHTML = `<div class="notes-content" contenteditable="true"></div>`;
      row.appendChild(notesCell);
      
      tbody.appendChild(row);
    }
    
    return tbody;
  }

  function openTransactionModal(day, categoryId) {
    if (_isClosingModal) return;
    
    console.log('Opening modal for day:', day, 'category:', categoryId);
    
    ensureModalExists();
    
    const modal = getElement('transaction-modal');
    if (!modal) {
      console.error('Modal element not found in DOM');
      return;
    }
    
    // FIXED: Now _categories contains parsed categories with id property
    const category = _categories.find(c => c.id === categoryId);
    if (!category) {
      console.error('Category not found:', categoryId);
      console.log('Available categories:', _categories);
      return;
    }
    
    const transactions = getTransactionsForDayAndCategory(parseInt(day), categoryId);
    console.log('Transactions found:', transactions.length);
    
    const dateObj = new Date(_currentYear, _currentMonth, parseInt(day));
    const formattedDate = dateObj.toLocaleDateString('en-US', { 
      weekday: 'short', 
      month: 'short', 
      day: 'numeric'
    });
    
    const total = transactions.reduce((sum, tx) => sum + tx.amount, 0);
    
    const modalTitle = getElement('modal-title');
    if (modalTitle) {
      modalTitle.innerHTML = `
        <div class="integrated-title">
          <span class="title-category">${category.emoji} ${category.name}</span>
          <span class="title-divider">|</span>
          <span class="title-date">${formattedDate}</span>
          ${total > 0 ? `<span class="title-divider">|</span><span class="title-total">Total: €${total.toFixed(2)}</span>` : ''}
        </div>
      `;
    }
    
    const transactionsList = getElement('transactions-list');
    if (transactionsList) {
      transactionsList.innerHTML = '';
      
      if (transactions.length > 0) {
        transactions.forEach(tx => {
          const item = createTransactionItem(tx);
          transactionsList.appendChild(item);
        });
      } else {
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-transactions';
        emptyState.textContent = 'No transactions for this day/category. Add one below!';
        transactionsList.appendChild(emptyState);
      }
    }
    
    modal.setAttribute('data-day', day);
    modal.setAttribute('data-category', categoryId);
    
    document.addEventListener('keydown', handleEscKey);
    
    setTimeout(() => {
      modal.classList.add('visible');
      console.log('Modal should now be visible');
    }, 10);
  }
  
  function createTransactionItem(tx) {
    const item = document.createElement('div');
    item.className = 'transaction-item';
    item.setAttribute('data-id', tx.id);
    
    item.innerHTML = `
      <div class="transaction-row">
        <input type="number" class="transaction-amount" value="${tx.amount}" min="0" step="0.01">
        <input type="text" class="transaction-description" value="${tx.description || ''}">
        <select class="transaction-account">
          <option value="Main Account" ${tx.account === 'Main Account' ? 'selected' : ''}>Main Account</option>
          <option value="Credit Card" ${tx.account === 'Credit Card' ? 'selected' : ''}>Credit Card</option>
          <option value="Savings" ${tx.account === 'Savings' ? 'selected' : ''}>Savings</option>
        </select>
        <div class="transaction-actions">
          <button class="transaction-delete"><i class="material-icons">close</i></button>
        </div>
      </div>
    `;
    
    setupTransactionItemEvents(item, tx);
    
    return item;
  }
  
  function setupTransactionItemEvents(item, tx) {
    const deleteBtn = item.querySelector('.transaction-delete');
    if (deleteBtn) {
      deleteBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        
        item.remove();
        
        const index = _transactions.findIndex(transaction => transaction.id === tx.id);
        if (index !== -1) {
          _transactions.splice(index, 1);
        }
        
        updateTransactionTotal();
        renderGrid();
      });
    }
    
    const amountInput = item.querySelector('.transaction-amount');
    if (amountInput) {
      amountInput.addEventListener('input', function() {
        tx.amount = parseFloat(this.value) || 0;
        updateTransactionTotal();
        renderGrid();
      });
    }
    
    const descriptionInput = item.querySelector('.transaction-description');
    if (descriptionInput) {
      descriptionInput.addEventListener('input', function() {
        tx.description = this.value;
      });
    }
    
    const accountSelect = item.querySelector('.transaction-account');
    if (accountSelect) {
      accountSelect.addEventListener('change', function() {
        tx.account = this.value;
      });
    }
  }
  
  function updateTransactionTotal() {
    const transactionsList = getElement('transactions-list');
    const modalTitle = getElement('modal-title');
    if (!transactionsList || !modalTitle) return;
    
    const amounts = Array.from(transactionsList.querySelectorAll('.transaction-amount'))
      .map(input => parseFloat(input.value) || 0);
    
    const total = amounts.reduce((sum, amount) => sum + amount, 0);
    
    const titleTotal = modalTitle.querySelector('.title-total');
    if (titleTotal) {
      titleTotal.textContent = `Total: €${total.toFixed(2)}`;
    } else if (total > 0) {
      const titleContent = modalTitle.querySelector('.integrated-title');
      if (titleContent) {
        const divider = document.createElement('span');
        divider.className = 'title-divider';
        divider.textContent = '|';
        
        const newTotal = document.createElement('span');
        newTotal.className = 'title-total';
        newTotal.textContent = `Total: €${total.toFixed(2)}`;
        
        titleContent.appendChild(divider);
        titleContent.appendChild(newTotal);
      }
    }
  }
  
  function handleEscKey(e) {
    if (e.key === 'Escape') {
      closeTransactionModal();
    }
  }
  
  function closeTransactionModal() {
    console.log('Closing transaction modal');
    _isClosingModal = true;
    
    const modal = getElement('transaction-modal');
    if (modal) {
      modal.classList.remove('visible');
      console.log('Modal visibility class removed');
      
      document.removeEventListener('keydown', handleEscKey);
      
      renderGrid();
      
      setTimeout(() => {
        _isClosingModal = false;
      }, 300);
    }
  }
  
  function addTransactionRow() {
    console.log('Adding single new transaction row');
    
    const transactionsList = getElement('transactions-list');
    const modal = getElement('transaction-modal');
    
    if (!transactionsList || !modal) {
      console.error('Required elements not found');
      return;
    }
    
    const day = modal.getAttribute('data-day');
    const categoryId = modal.getAttribute('data-category');
    
    if (!day || !categoryId) {
      console.error('Missing day or category information');
      return;
    }
    
    const newId = `tx-new-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
    console.log('Creating single transaction with ID:', newId);
    
    const newTx = {
      id: newId,
      date: new Date(_currentYear, _currentMonth, parseInt(day)),
      category: categoryId,
      amount: 0,
      description: '',
      account: 'Main Account'
    };
    
    _transactions.push(newTx);
    
    const item = createTransactionItem(newTx);
    item.classList.add('new-transaction');
    
    setTimeout(() => {
      const amountField = item.querySelector('.transaction-amount');
      if (amountField) {
        amountField.focus();
      }
    }, 100);
    
    if (transactionsList.querySelector('.empty-transactions')) {
      transactionsList.innerHTML = '';
    }
    
    transactionsList.appendChild(item);
    
    updateTransactionTotal();
  }
  
  /**
   * Set expense data from external source (enhanced)
   */
  function setExpenseData(expenses) {
    if (!expenses || !Array.isArray(expenses)) {
      console.error('Invalid expense data provided:', expenses);
      return;
    }
    
    console.log('Setting expense data in MonthlyGrid:', expenses.length, 'transactions');
    
    // Process the new data
    processRealExpenseData(expenses);
    
    // Render with the new data
    renderGrid();
  }

  // Public methods
  return {
    init: init,
    renderGrid: renderGrid,
    setExpenseData: setExpenseData,
    refresh: refresh,
    openTransactionModal: openTransactionModal
  };
})();

// Expose globally
window.MonthlyGrid = MonthlyGrid;

</script>