<script>
var MonthlyGrid = (function() {
  // Private variables
  let _initialized = false;
  let _currentMonth = new Date().getMonth();
  let _currentYear = new Date().getFullYear();
  let _categories = [];
  let _transactions = [];
  let _isLoading = false;
  let _currencySymbol = '‚Ç¨'; 
  
  // ENHANCED: Smart caching system
  let _expenseCache = new Map(); // In-memory cache for current session
  let _prefetchQueue = new Set(); // Track ongoing prefetch operations
  const CACHE_PREFIX = 'monthlyGrid_expenses_';
  const CACHE_VERSION = '1.0';
  const MAX_CACHE_MONTHS = 6; // Limit cache size
  const SESSION_STORAGE_KEY = 'monthlyGrid_sessionActive'; // Track if session is new
  
  // DOM element cache for performance
  const _elements = {};
  
  /**
   * Generate cache key for a specific month/year
   */
  function getCacheKey(month, year) {
    return `${year}-${String(month).padStart(2, '0')}`;
  }
  
  /**
   * Check if this is a new session (page refresh/new tab) and clear cache if so
   */
  function handleSessionStart() {
    // Check if this is a new session
    const isSessionActive = sessionStorage.getItem(SESSION_STORAGE_KEY);
    
    if (!isSessionActive) {
      // This is a new session (page refresh/new tab)
      console.log('New session detected - clearing all cache');
      clearCache();
      sessionStorage.setItem(SESSION_STORAGE_KEY, 'true');
    } else {
      console.log('Continuing existing session - cache preserved');
    }
  }
  
  /**
   * Get expense data from cache (memory first, then localStorage)
   */
  function getCachedExpenses(month, year) {
    const key = getCacheKey(month, year);
    
    // Check in-memory cache first
    if (_expenseCache.has(key)) {
      console.log(`Found expenses in memory cache for ${month}/${year}`);
      return _expenseCache.get(key);
    }
    
    // Check localStorage cache
    try {
      const storageKey = CACHE_PREFIX + key;
      const cached = localStorage.getItem(storageKey);
      if (cached) {
        const data = JSON.parse(cached);
        
        // Check cache version and 24-hour expiry (within session)
        const cacheAge = Date.now() - data.timestamp;
        const isExpired = cacheAge > 24 * 60 * 60 * 1000; // 24 hours
        
        if (data.version === CACHE_VERSION && !isExpired) {
          console.log(`Found expenses in localStorage cache for ${month}/${year} (age: ${Math.round(cacheAge / 1000 / 60)} minutes)`);
          
          // Store in memory cache for faster access
          _expenseCache.set(key, data.expenses);
          
          return data.expenses;
        } else {
          // Cache expired, remove it
          localStorage.removeItem(storageKey);
          console.log(`Cache expired for ${month}/${year}, removed (age: ${Math.round(cacheAge / 1000 / 60 / 60)} hours)`);
        }
      }
    } catch (error) {
      console.warn('Error reading from localStorage cache:', error);
    }
    
    return null;
  }
  
  /**
   * Store expense data in cache (both memory and localStorage)
   */
  function setCachedExpenses(month, year, expenses) {
    const key = getCacheKey(month, year);
    
    // Store in memory cache
    _expenseCache.set(key, expenses);
    
    // Store in localStorage with timestamp for 24-hour expiry
    try {
      const storageKey = CACHE_PREFIX + key;
      const data = {
        version: CACHE_VERSION,
        timestamp: Date.now(),
        month: month,
        year: year,
        expenses: expenses
      };
      
      localStorage.setItem(storageKey, JSON.stringify(data));
      console.log(`Cached expenses for ${month}/${year} in localStorage (valid for 24 hours)`);
      
      // Clean up old cache entries if we exceed the limit
      cleanupCache();
      
    } catch (error) {
      console.warn('Error writing to localStorage cache:', error);
    }
  }
  
/**
 * Enhanced cleanup of expired cache entries
 */
function cleanupCache() {
  try {
    const keys = [];
    
    // Find all cache keys in localStorage
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(CACHE_PREFIX)) {
        keys.push(key);
      }
    }
    
    // Get the current date for age calculation
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    
    // Process all cache entries
    keys.forEach(key => {
      try {
        const data = JSON.parse(localStorage.getItem(key));
        
        // Skip if missing required data
        if (!data || !data.year || data.month === undefined) return;
        
        // Calculate how many months old this cache entry is
        const ageInMonths = (currentYear - data.year) * 12 + (currentMonth - data.month);
        
        // Remove entries older than MAX_CACHE_MONTHS
        if (ageInMonths > MAX_CACHE_MONTHS) {
          localStorage.removeItem(key);
        }
        
        // Also remove entries with timestamp older than 1 day
        const ageInMs = Date.now() - (data.timestamp || 0);
        if (ageInMs > 24 * 60 * 60 * 1000) { // 24 hours
          localStorage.removeItem(key);
        }
      } catch (e) {
        // If we can't parse the entry, just remove it
        localStorage.removeItem(key);
      }
    });
  } catch (error) {
    console.warn('Error during cache cleanup:', error);
  }
}
  
  /**
 * Enhanced prefetch logic 
 */
function prefetchMonth(month, year) {
  const key = getCacheKey(month, year);
  
  // Skip if already cached or currently being fetched
  if (getCachedExpenses(month, year) || _prefetchQueue.has(key)) {
    return Promise.resolve();
  }
  
  // Avoid prefetching future months that are too far ahead
  const now = new Date();
  const currentRealMonth = now.getMonth();
  const currentRealYear = now.getFullYear();
  const monthsAhead = (year - currentRealYear) * 12 + (month - currentRealMonth);
  
  // We always prefetch past months, but limit future months to 2 months ahead
  if (monthsAhead > 2) {
    return Promise.resolve();
  }
  
  console.log(`Prefetching expenses for ${month}/${year}...`);
  _prefetchQueue.add(key);
  
  return new Promise((resolve) => {
    if (!window.API || typeof API.getExpenseData !== 'function') {
      _prefetchQueue.delete(key);
      resolve();
      return;
    }
    
    API.getExpenseData(
      month,
      year,
      function(result) {
        _prefetchQueue.delete(key);
        
        if (result && result.success && result.expenses) {
          setCachedExpenses(month, year, result.expenses);
        } else {
          // Even if we get an empty result, we should cache it to avoid repeated fetches
          const emptyResult = result && result.expenses ? result.expenses : [];
          console.log(`Prefetch for ${month}/${year} returned empty or error, caching empty result`);
          setCachedExpenses(month, year, emptyResult);
        }
        
        resolve();
      },
      function(error) {
        _prefetchQueue.delete(key);
        console.log(`Prefetch error for ${month}/${year}:`, error);
        
        // Cache empty array on error to prevent repeated failing requests
        setCachedExpenses(month, year, []);
        
        resolve();
      }
    );
  });
}
  
  /**
   * Get previous month/year
   */
  function getPreviousMonth(month, year) {
    let prevMonth = month - 1;
    let prevYear = year;
    
    if (prevMonth < 0) {
      prevMonth = 11;
      prevYear = year - 1;
    }
    
    return { month: prevMonth, year: prevYear };
  }
  
  /**
   * Get an element by ID with caching
   */
  function getElement(id) {
    if (!_elements[id]) {
      _elements[id] = document.getElementById(id);
    }
    return _elements[id];
  }

  /**
   * Get currency symbol from user settings
   */
  function loadCurrencyFromSettings() {
    try {
      if (window.SimBudget && SimBudget.Settings) {
        _currencySymbol = SimBudget.Settings.getSetting('currencySymbol') || '‚Ç¨';
      } else {
        // Fallback: try localStorage directly
        const saved = localStorage.getItem('simbudget_settings');
        if (saved) {
          const settings = JSON.parse(saved);
          _currencySymbol = settings.currencySymbol || '‚Ç¨';
        }
      }
      console.log('MonthlyGrid: Using currency symbol:', _currencySymbol);
    } catch (error) {
      console.warn('MonthlyGrid: Error loading currency from settings, using default:', error);
      _currencySymbol = '‚Ç¨';
    }
  }

  /**
   * Format currency amount consistently
   * @param {number} amount - Amount to format
   * @param {number} decimals - Number of decimal places (default: 0)
   * @return {string} Formatted currency string
   */
  function formatCurrency(amount, decimals = 0) {
    return `${_currencySymbol}${amount.toFixed(decimals)}`;
  }

  /**
   * Initialize the Monthly Grid
   */
  function init(containerId) {
  if (_initialized && !containerId) {
    return;
  }
  
  console.log('Initializing Monthly Grid View...');
  
  // Initialize system month tracking
  _systemCurrentMonth = new Date().getMonth();
  _systemCurrentYear = new Date().getFullYear();
  
  // Only set current month/year if not already set (prevents overwriting when reinitializing)
  if (!_initialized) {
    _currentMonth = _systemCurrentMonth;
    _currentYear = _systemCurrentYear;
  }
  
  // Handle session start (clear cache on page refresh/new session)
  handleSessionStart();
  
  // Load currency symbol from user settings
  loadCurrencyFromSettings();
  
  // Clean up any existing event handlers first
  if (_initialized) {
    unbindEvents();
  }
  
  // Find and store container element
  if (containerId) {
    const container = document.getElementById(containerId);
    if (container) {
      _elements['monthly-grid-container'] = container;
      console.log("Found container, storing for rendering:", containerId);
    } else {
      console.error("Container not found:", containerId);
      return;
    }
  } else {
    // Try to find the default container
    const defaultContainer = document.getElementById("monthly-grid-container");
    if (!defaultContainer) {
      console.error("Default grid container not found");
      return;
    }
    _elements['monthly-grid-container'] = defaultContainer;
  }
  
  // Set up event handlers
  bindEvents();
  
  // Set up periodic check for current month change (every 10 minutes)
  if (!window._monthCheckInterval) {
    window._monthCheckInterval = setInterval(checkCurrentMonth, 10 * 60 * 1000);
    // Also check on visibility change (when user returns to tab)
    document.addEventListener('visibilitychange', function() {
      if (document.visibilityState === 'visible') {
        checkCurrentMonth();
      }
    });
  }
  
  // Load real data from spreadsheet (with smart caching)
  loadRealExpenseData();
  
  // Prevent body scrolling on mobile
  if (window.innerWidth <= 768) {
    document.body.style.overflow = 'hidden';
    
    // Allow the grid container to scroll
    const container = getElement('monthly-grid-container');
    if (container) {
      container.style.overflow = 'auto';
    }
  }
  
  _initialized = true;
  console.log('Monthly Grid View initialized');
}
  
  /**
   * ENHANCED: Load real expense data with smart caching and prefetching
   */
  function loadRealExpenseData(month = _currentMonth, year = _currentYear) {
  if (_isLoading) {
    console.log('Already loading expense data, skipping...');
    return Promise.resolve();
  }
  
  // Check cache first for instant loading
  const cachedExpenses = getCachedExpenses(month, year);
  if (cachedExpenses) {
    console.log(`Loading from cache: ${cachedExpenses.length} expenses for ${month}/${year}`);
    
    // Load categories first, then process cached data
    return loadActiveCategories()
      .then(categories => {
        processRealExpenseData(cachedExpenses);
        renderGrid();
        
        // Bidirectional prefetching - both previous and next months
        const prev = getPreviousMonth(month, year);
        const next = getNextMonth(month, year);
        
        setTimeout(() => {
          // First check if it makes sense to prefetch (avoid future months too far ahead)
          const now = new Date();
          const currentRealMonth = now.getMonth();
          const currentRealYear = now.getFullYear();
          
          // Prefetch previous month (always)
          prefetchMonth(prev.month, prev.year);
          
          // Only prefetch next month if it's not too far in the future
          // (next month OR current month + max 2 months ahead)
          const monthsAhead = (next.year - currentRealYear) * 12 + (next.month - currentRealMonth);
          if (monthsAhead <= 2) {
            prefetchMonth(next.month, next.year);
          }
        }, 100);
        
        return Promise.resolve();
      })
      .catch(error => {
        console.error('Error loading categories for cached data:', error);
        // Fall back to fresh fetch
        return fetchFreshExpenseData(month, year);
      });
  }
  
  // Not in cache, fetch fresh data
  return fetchFreshExpenseData(month, year);
}

/**
 * Failsafe mechanism to ensure current month is always accurate
 */
function checkCurrentMonth() {
  const now = new Date();
  const realCurrentMonth = now.getMonth();
  const realCurrentYear = now.getFullYear();
  
  // Compare with our stored current month/year
  if (realCurrentMonth !== _currentMonth || realCurrentYear !== _currentYear) {
    // Only update if we're viewing what we think is the current month
    const viewingCurrentMonth = (_systemCurrentMonth === _currentMonth && 
                                 _systemCurrentYear === _currentYear);
    
    // Update system tracking
    _systemCurrentMonth = realCurrentMonth;
    _systemCurrentYear = realCurrentYear;
    
    // If we were viewing the "current" month, update to the new current month
    if (viewingCurrentMonth) {
      console.log('Real current month has changed, updating view...');
      _currentMonth = realCurrentMonth;
      _currentYear = realCurrentYear;
      updateMonthYearDisplay();
      loadRealExpenseData(_currentMonth, _currentYear);
    }
    
    // Clear old cache for months that are now more than 6 months old
    cleanupCache();
  }
}
  
  /**
   * Fetch fresh expense data from the server
   */
  function fetchFreshExpenseData(month, year) {
    _isLoading = true;
    
    // Debug logging
    const currentDate = new Date(year, month, 1);
    const monthName = currentDate.toLocaleString('default', { month: 'long' });
    
    // Show loading indicator only for fresh fetches
    showLoadingIndicator();
    
    // Clear existing data
    _transactions = [];
    _categories = [];
    
    // STEP 1: Load active categories first
    return loadActiveCategories()
      .then(categories => {
        console.log('Categories loaded, now fetching fresh expenses...');
        
        // STEP 2: Load expenses for the specified month
        if (!window.API || typeof API.getExpenseData !== 'function') {
          throw new Error('API.getExpenseData function not found. Check API.html file.');
        }
        
        console.log(`Fetching fresh data for ${month}/${year}...`);
        
        return new Promise((resolve, reject) => {
          API.getExpenseData(
            month,
            year,
            function(result) {
              console.log('SUCCESS: API returned:', result);
              
              if (!result) {
                reject('Server returned null result');
                return;
              }
              
              if (!result.success) {
                reject('Server returned failure: ' + (result.error || 'No error message'));
                return;
              }
              
              if (!result.expenses || !Array.isArray(result.expenses)) {
                reject('Server returned invalid expenses data. Type: ' + typeof result.expenses);
                return;
              }
              
              resolve(result.expenses);
            },
            function(error) {
              reject('Server function call failed: ' + error);
            }
          );
        });
      })
      .then(expenses => {
        console.log('Processing ' + expenses.length + ' fresh expenses...');
        
        // Cache the fresh data
        setCachedExpenses(month, year, expenses);
        
        // STEP 3: Process the expense data
        processRealExpenseData(expenses);
        
        // STEP 4: Render the grid with fresh data
        renderGrid();
        
        console.log(`SUCCESS: Loaded ${_transactions.length} transactions for ${month}/${year}`);
        hideLoadingIndicator();
        _isLoading = false;
        
        // Start prefetching previous month in background
        const prev = getPreviousMonth(month, year);
        setTimeout(() => {
          prefetchMonth(prev.month, prev.year);
        }, 500);
        
        return Promise.resolve();
      })
      .catch(error => {
        console.error('FAILED: Error loading expense data:', error);
        showErrorMessage('Failed to load data: ' + error);
        hideLoadingIndicator();
        _isLoading = false;
        return Promise.reject(error);
      });
  }
  
  /**
   * Parse category string to extract name and emoji
   * Format: "Business üíº" -> {name: "Business", emoji: "üíº"}
   */
  function parseCategoryNameAndEmoji(categoryString) {
    // Split by space and check if last part is an emoji
    const parts = categoryString.trim().split(' ');
    
    if (parts.length >= 2) {
      // Check if the last part contains emoji characters
      const lastPart = parts[parts.length - 1];
      const emojiRegex = /[\u{1F600}-\u{1F6FF}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
      
      if (emojiRegex.test(lastPart)) {
        // Last part contains emoji, split name and emoji
        const name = parts.slice(0, -1).join(' ');
        const emoji = lastPart;
        return { name, emoji };
      }
    }
    
    // No emoji found, return the whole string as name
    return { name: categoryString, emoji: '' };
  }
  
  /**
   * Load categories exactly like QuickExpenseEntry does - FIXED to store parsed categories
   */
  function loadActiveCategories() {
    console.log('Loading categories from localStorage and API...');
    
    return new Promise((resolve, reject) => {
      // First try to load from local storage for immediate display
      const cachedCategories = localStorage.getItem('simbudget_categories');
      const activeCategories = localStorage.getItem('simbudget_active_categories');
      
      if (cachedCategories && activeCategories) {
        try {
          const allCategories = JSON.parse(cachedCategories);
          const active = JSON.parse(activeCategories);
          
          console.log('All categories from cache:', allCategories);
          console.log('Active categories list:', active);
          
          // FIXED: Parse categories immediately and store in correct format
          const parsedActiveCategories = allCategories
            .filter(cat => {
              const categoryName = typeof cat === 'string' ? cat : cat.name;
              return active.includes(categoryName);
            })
            .map(cat => {
              const categoryString = typeof cat === 'string' ? cat : cat.name;
              const parsed = parseCategoryNameAndEmoji(categoryString);
              return {
                id: parsed.name,        // Clean name as ID for matching
                name: parsed.name,      // Clean name without emoji
                emoji: parsed.emoji,    // Extracted emoji
                active: true
              };
            });
          
          // Store PARSED categories in _categories
          _categories = parsedActiveCategories;
          
          console.log('Stored parsed active categories:', parsedActiveCategories);
          resolve(parsedActiveCategories);
          return;
        } catch (e) {
          console.error('Error parsing cached categories:', e);
        }
      }
      
      // If API exists, use it to load categories
      if (window.API && typeof API.getCategories === 'function') {
        API.getCategories(
          function(result) {
            if (result && result.success) {
              if (result.categories && result.activeCategories) {
                // FIXED: Parse categories immediately
                const parsedActiveCategories = result.categories
                  .filter(cat => result.activeCategories.includes(cat))
                  .map(cat => {
                    const parsed = parseCategoryNameAndEmoji(cat);
                    return {
                      id: parsed.name,        // Clean name as ID for matching
                      name: parsed.name,      // Clean name without emoji
                      emoji: parsed.emoji,    // Extracted emoji
                      active: true
                    };
                  });
                
                // Cache the full categories array (for other components)
                localStorage.setItem('simbudget_categories', JSON.stringify(result.categories));
                localStorage.setItem('simbudget_active_categories', JSON.stringify(result.activeCategories));
                
                // Store PARSED categories in _categories
                _categories = parsedActiveCategories;
                
                console.log('Loaded and parsed active categories from API:', parsedActiveCategories);
                resolve(parsedActiveCategories);
              } else {
                reject('No categories in API result');
              }
            } else {
              reject('API call failed');
            }
          },
          function(error) {
            console.error('Error loading categories:', error);
            reject(error);
          }
        );
      } else {
        reject('API.getCategories not available');
      }
    });
  }

  /**
   * Generate transaction summary for a specific day
   * @param {number} day - Day of the month
   * @return {string} Summary string like "Netflix ‚Ç¨5, Groceries ‚Ç¨45 ..."
   */
  function generateDayTransactionSummary(day) {
    // Get all transactions for this day across all categories
    const dayTransactions = _transactions.filter(tx => {
      if (!tx.date) return false;
      
      const txDay = tx.date.getDate();
      const txMonth = tx.date.getMonth();
      const txYear = tx.date.getFullYear();
      
      return txDay === day && txMonth === _currentMonth && txYear === _currentYear;
    });
    
    if (dayTransactions.length === 0) {
      return '';
    }
    
    // Create summary items with name and amount
    const summaryItems = dayTransactions.map(tx => {
      const name = tx.description || tx.name || 'Expense';
      const amount = formatCurrency(tx.amount);
      return `${name} ${amount}`;
    });
    
    // Join with commas
    const fullSummary = summaryItems.join(', ');
    
    // Truncate if too long (keep around 50 characters)
    const maxLength = 50;
    if (fullSummary.length > maxLength) {
      // Find the last complete item that fits within the limit
      let truncated = '';
      let totalLength = 0;
      
      for (let i = 0; i < summaryItems.length; i++) {
        const testLength = truncated ? 
          truncated.length + 2 + summaryItems[i].length : // +2 for ", "
          summaryItems[i].length;
          
        if (testLength <= maxLength - 4) { // -4 for " ..."
          truncated = truncated ? truncated + ', ' + summaryItems[i] : summaryItems[i];
        } else {
          break;
        }
      }
      
      return truncated + ' ...';
    }
    
    return fullSummary;
  }

  /**
   * Parse date string - handles both ISO strings and "DD MMM YYYY" format
   * Returns a Date object or null if parsing fails
   */
  function parseSpreadsheetDate(dateString) {
    if (!dateString) {
      return null;
    }
    
    // If it's already a Date object, return it
    if (dateString instanceof Date) {
      return dateString;
    }
    
    // Convert to string if not already
    const dateStr = dateString.toString().trim();
    
    // Check if it's an ISO string (from server API)
    if (dateStr.includes('T') && (dateStr.includes('Z') || dateStr.includes('+'))) {
      const date = new Date(dateStr);
      if (!isNaN(date.getTime())) {
        return date;
      }
    }
    
    // Try "DD MMM YYYY" format
    const parts = dateStr.split(/\s+/);
    if (parts.length === 3) {
      const [dayStr, monthStr, yearStr] = parts;
      
      // Parse day
      const day = parseInt(dayStr);
      if (isNaN(day) || day < 1 || day > 31) {
        console.warn('Invalid day in date:', dateStr);
        return null;
      }
      
      // Parse year
      const year = parseInt(yearStr);
      if (isNaN(year) || year < 1900 || year > 2100) {
        console.warn('Invalid year in date:', dateStr);
        return null;
      }
      
      // Parse month (convert month abbreviation to 0-based index)
      const monthMap = {
        'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
        'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
      };
      
      const month = monthMap[monthStr];
      if (month === undefined) {
        console.warn('Invalid month in date:', dateStr);
        return null;
      }
      
      // Create date using local timezone to avoid timezone shifts
      const date = new Date(year, month, day, 12, 0, 0, 0); // Set to noon to avoid DST issues
      
      // Verify the date is valid (handles cases like Feb 30)
      if (date.getDate() !== day || date.getMonth() !== month || date.getFullYear() !== year) {
        console.warn('Date components changed during creation, invalid date:', dateStr);
        return null;
      }
      
      return date;
    }
    
    const fallbackDate = new Date(dateStr);
    if (!isNaN(fallbackDate.getTime())) {
      return fallbackDate;
    }
    
    console.warn('All parsing methods failed for:', dateStr);
    return null;
  }

  /**
   * Process real expense data from spreadsheet (expenses only, no categories)
   */
  /**
 * Process real expense data from spreadsheet (expenses only, no categories)
 * Now includes label field for identifying subscription/fixed transactions
 */
function processRealExpenseData(expenses) {
  const processedTransactions = [];
  
  // Process each expense
  expenses.forEach((expense, index) => {
    // Skip empty rows
    if (!expense.category || !expense.amount) {
      console.log('Skipping expense', index, '- missing category or amount:', expense);
      return;
    }
    
    // Parse date - ENHANCED with robust parsing
    let expenseDate;
    
    if (expense.date instanceof Date) {
      expenseDate = expense.date;
    } else if (expense.date) {
      // Try our custom parser first
      expenseDate = parseSpreadsheetDate(expense.date);
      
      if (!expenseDate) {
        // Fallback to standard Date parsing
        expenseDate = new Date(expense.date);
        
        if (isNaN(expenseDate.getTime())) {
          console.warn(`Expense ${index}: Both parsing methods failed for date:`, expense.date);
          return;
        }
      }
      
    } else {
      console.warn('No date for expense', index, ':', expense);
      return;
    }
    
    // Parse amount
    const amount = parseFloat(expense.amount);
    if (isNaN(amount) || amount <= 0) {
      console.warn('Invalid amount for expense', index, ':', expense);
      return;
    }
    
    // Parse category to get clean name (remove emoji)
    const parsed = parseCategoryNameAndEmoji(expense.category.trim());
    const cleanCategory = parsed.name; // Use only the name part for matching
    
    // Create transaction object, now including the label field
    const transaction = {
      id: expense.rowIndex || `tx-real-${index}`,
      date: expenseDate,
      category: cleanCategory,  // Store clean category name for matching with active categories
      amount: amount,
      description: expense.name || expense.description || '',
      account: expense.account || 'Main Account',
      notes: expense.notes || '',
      label: expense.label || '' // Store the label field to identify subscriptions/fixed payments
    };
    
    processedTransactions.push(transaction);
  });
  
  // Store processed transactions (categories are loaded separately)
  _transactions = processedTransactions;

  _transactions.slice(0, 5).forEach(tx => {
    // Log first few transactions to verify label field
    if (tx.label) {
      console.log(`Transaction with label: ${tx.label}`, tx);
    }
  });
}
  
  /**
   * Show loading indicator with current month info
   */
  function showLoadingIndicator() {
    const container = getElement('monthly-grid-container');
    if (container) {
      const monthName = new Date(_currentYear, _currentMonth, 1)
        .toLocaleString('default', { month: 'long' });
      
      container.innerHTML = `
        <div class="loading-indicator">
          <div class="loading-spinner"></div>
          <p>Loading ${monthName} ${_currentYear} expenses...</p>
          <p><small>Reading month-specific data from spreadsheet</small></p>
        </div>
      `;
    }
  }
  
  /**
   * Hide loading indicator
   */
  function hideLoadingIndicator() {
    const loadingEl = document.querySelector('.loading-indicator');
    if (loadingEl) {
      loadingEl.remove();
    }
  }
  
  /**
   * Show error message
   */
  function showErrorMessage(message) {
    const container = getElement('monthly-grid-container');
    if (container) {
      container.innerHTML = `
        <div class="grid-error">
          <h3>‚ùå Failed to Load Data</h3>
          <p><strong>Error:</strong> ${message}</p>
          <p><strong>Expected:</strong> Reading from spreadsheet with expense data</p>
          <button class="retry-btn" onclick="MonthlyGrid.refresh()">Retry</button>
          <hr>
          <details>
            <summary>Debugging Info</summary>
            <p><strong>Check Code.gs:</strong> Make sure getExpenseData() function exists</p>
            <p><strong>Check API.html:</strong> Make sure API.getExpenseData() function exists</p>
            <p><strong>Check Logs:</strong> Open Apps Script editor ‚Üí Executions tab</p>
            <p><strong>Check Sheet:</strong> Verify spreadsheet has expense data in correct format</p>
          </details>
        </div>
      `;
    }
  }
  
  /**
   * Refresh the grid by reloading data
   */
  function refresh() {
    console.log('Refreshing monthly grid...');
    _isLoading = false; // Reset loading flag
    
    // Clear cache for current month to force fresh fetch
    const key = getCacheKey(_currentMonth, _currentYear);
    _expenseCache.delete(key);
    
    const storageKey = CACHE_PREFIX + key;
    localStorage.removeItem(storageKey);
    
    loadRealExpenseData();
  }

  /**
   * Update currency symbol and refresh display
   */
  function updateCurrency() {
    loadCurrencyFromSettings();
    if (_initialized) {
      renderGrid(); // Re-render to show new currency
    }
  }

  // Track modal states to prevent accidental popups
  let _isOpeningModal = false;
  let _isClosingModal = false;
  
  function bindEvents() {
    // Month navigation - DON'T replace elements, just remove/add listeners properly
    const prevMonth = document.getElementById('prevMonth');
    const nextMonth = document.getElementById('nextMonth');
    
    if (prevMonth) {
      // Remove existing MonthlyGrid listeners (if any)
      prevMonth.removeEventListener('click', prevMonth._monthlyGridHandler);
      
      // Add our handler and store reference for future removal
      prevMonth._monthlyGridHandler = function(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Previous month clicked - current month:', _currentMonth);
        navigateMonth(-1);
      };
      
      prevMonth.addEventListener('click', prevMonth._monthlyGridHandler);
    } else {
      console.error('prevMonth button not found in DOM');
    }
    
    if (nextMonth) {
      // Remove existing MonthlyGrid listeners (if any)
      nextMonth.removeEventListener('click', nextMonth._monthlyGridHandler);
      
      // Add our handler and store reference for future removal
      nextMonth._monthlyGridHandler = function(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Next month clicked - current month:', _currentMonth);
        navigateMonth(1);
      };
      
      nextMonth.addEventListener('click', nextMonth._monthlyGridHandler);
    } else {
      console.error('nextMonth button not found in DOM');
    }
    
    // ENHANCED: Add refresh button handler
    const refreshExpenses = document.getElementById('refreshExpenses');
    if (refreshExpenses) {
      refreshExpenses.removeEventListener('click', refreshExpenses._monthlyGridHandler);
      
      refreshExpenses._monthlyGridHandler = function(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Refresh expenses clicked - clearing cache and reloading');
        refresh();
      };
      
      refreshExpenses.addEventListener('click', refreshExpenses._monthlyGridHandler);
    } else {
      console.warn('Refresh expenses button not found in DOM - make sure to add it to Index.html');
    }
    
    // Cell click handlers (using event delegation)
    const gridContainer = getElement('monthly-grid-container');
    if (gridContainer) {
      gridContainer.addEventListener('click', function(e) {
        if (_isClosingModal) return;
        
        const cell = e.target.closest('.grid-cell[data-day][data-category]');
        if (cell) {
          e.stopPropagation();
          
          const day = cell.getAttribute('data-day');
          const category = cell.getAttribute('data-category');
          
          _isOpeningModal = true;
          openTransactionModal(day, category);
          
          setTimeout(() => {
            _isOpeningModal = false;
          }, 300);
        }
      });
    }
    
    // Remove existing event listeners first to prevent duplicates
    document.removeEventListener('click', handleDocumentClick);
    document.removeEventListener('touchend', handleTouchEnd);
    
    // Add event listeners
    document.addEventListener('click', handleDocumentClick);
    document.addEventListener('touchend', handleTouchEnd);
  }
  
  /**
   * Clean up event listeners when MonthlyGrid is destroyed/reinitialized
   */
  function unbindEvents() {
    const prevMonth = document.getElementById('prevMonth');
    const nextMonth = document.getElementById('nextMonth');
    const refreshExpenses = document.getElementById('refreshExpenses');
    
    if (prevMonth && prevMonth._monthlyGridHandler) {
      prevMonth.removeEventListener('click', prevMonth._monthlyGridHandler);
      prevMonth._monthlyGridHandler = null;
    }
    
    if (nextMonth && nextMonth._monthlyGridHandler) {
      nextMonth.removeEventListener('click', nextMonth._monthlyGridHandler);
      nextMonth._monthlyGridHandler = null;
    }
    
    if (refreshExpenses && refreshExpenses._monthlyGridHandler) {
      refreshExpenses.removeEventListener('click', refreshExpenses._monthlyGridHandler);
      refreshExpenses._monthlyGridHandler = null;
    }
  }
  
  function handleDocumentClick(e) {
    if (_isOpeningModal || _isClosingModal) return;
    
    const modal = getElement('transaction-modal');
    if (!modal) return;
    
    const closeBtn = getElement('close-modal-btn');
    const modalCard = modal.querySelector('.modal-card');
    const addBtn = getElement('add-transaction-btn');
    
    if (closeBtn && (e.target === closeBtn || closeBtn.contains(e.target))) {
      e.preventDefault();
      e.stopPropagation();
      closeTransactionModal();
      return;
    }
    
    if (addBtn && (e.target === addBtn || addBtn.contains(e.target))) {
      e.preventDefault();
      e.stopPropagation();
      addTransactionRow();
      return;
    }
    
    if (modal.classList.contains('visible')) {
      if (e.target === modal || 
          (e.target !== modalCard && !modalCard.contains(e.target))) {
        e.preventDefault();
        e.stopPropagation();
        closeTransactionModal();
        return;
      }
    }
  }
  
  function handleTouchEnd(e) {
    if (_isOpeningModal || _isClosingModal) return;
    
    const modal = getElement('transaction-modal');
    if (!modal || !modal.classList.contains('visible')) return;
    
    const modalCard = modal.querySelector('.modal-card');
    if (modalCard && !modalCard.contains(e.target) && e.target !== modalCard) {
      e.preventDefault();
      e.stopPropagation();
      closeTransactionModal();
    }
  }
  

  /**
 * Get next month/year
 */
function getNextMonth(month, year) {
  let nextMonth = month + 1;
  let nextYear = year;
  
  if (nextMonth > 11) {
    nextMonth = 0;
    nextYear = year + 1;
  }
  
  return { month: nextMonth, year: nextYear };
}


  /**
   * ENHANCED: Navigate month with smart caching
   */
  function navigateMonth(change) {
  // Prevent navigation while loading
  if (_isLoading) {
    console.log('Navigation blocked - already loading data');
    return;
  }
  
  _currentMonth += change;
  
  if (_currentMonth > 11) {
    _currentMonth = 0;
    _currentYear++;
  } else if (_currentMonth < 0) {
    _currentMonth = 11;
    _currentYear--;
  }
  
  updateMonthYearDisplay();
  
  loadRealExpenseData(_currentMonth, _currentYear);
}
  
  function updateMonthYearDisplay() {
    const monthYearDisplay = getElement('monthYearDisplay');
    if (monthYearDisplay) {
      const monthName = new Date(_currentYear, _currentMonth, 1)
        .toLocaleString('default', { month: 'long' });
      
      
      monthYearDisplay.textContent = `${monthName} ${_currentYear}`;
    }
  }
  
  function renderGrid() {
    const container = getElement('monthly-grid-container');
    if (!container) {
      console.error("Grid container not found for rendering");
      return;
    }
    
    // Clear existing content
    container.innerHTML = '';
    
    // Get days in month
    const daysInMonth = new Date(_currentYear, _currentMonth + 1, 0).getDate();
    
    // Update month/year display
    updateMonthYearDisplay();
    
    // Categories are already parsed in _categories, just use them directly
    const categoriesToDisplay = _categories;
    
    if (categoriesToDisplay.length === 0) {
      container.innerHTML = `
        <div class="grid-error">
          <h3>No Categories Found</h3>
          <p>No expense categories found in your data for the current month.</p>
          <button class="retry-btn" onclick="MonthlyGrid.refresh()">Refresh</button>
        </div>
      `;
      return;
    }
    
    // Create table for grid
    const table = document.createElement('table');
    table.className = 'monthly-grid';
    
    // Add header with categories
    const thead = createTableHeader(categoriesToDisplay, daysInMonth);
    table.appendChild(thead);
    
    // Create rows for each day
    const tbody = createTableBody(categoriesToDisplay, daysInMonth);
    table.appendChild(tbody);
    
    // Add table to container
    container.appendChild(table);
    
    // Add the modal HTML after rendering the grid
    ensureModalExists();
  }
  
  function getTransactionsForDayAndCategory(day, categoryId) {
    // Convert categoryId to match the actual category names from data
    const transactions = _transactions.filter(tx => {
      if (!tx.date || !tx.category) return false;
      
      // Check if the day matches
      const txDay = tx.date.getDate();
      const txMonth = tx.date.getMonth();
      const txYear = tx.date.getFullYear();
      
      // Must be same day, month, and year
      const dayMatches = (txDay === day);
      const monthMatches = (txMonth === _currentMonth);
      const yearMatches = (txYear === _currentYear);
      
      // Fix category matching - categoryId might be slugified, but tx.category is the full name
      const categoryMatches = (
        tx.category === categoryId || 
        tx.category.toLowerCase().replace(/[^a-z0-9]/g, '') === categoryId ||
        categoryId === tx.category.toLowerCase().replace(/[^a-z0-9]/g, '')
      );
      
      const matches = dayMatches && monthMatches && yearMatches && categoryMatches;
      
 
      
      return matches;
    });
    
    return transactions;
  }
  
  function getMonthTotalForCategory(categoryId) {
    return _transactions
      .filter(tx => 
        tx.category === categoryId && 
        tx.date.getMonth() === _currentMonth &&
        tx.date.getFullYear() === _currentYear
      )
      .reduce((sum, tx) => sum + tx.amount, 0);
  }
  
  function getMonthGrandTotal() {
    return _transactions
      .filter(tx => 
        tx.date.getMonth() === _currentMonth &&
        tx.date.getFullYear() === _currentYear
      )
      .reduce((sum, tx) => sum + tx.amount, 0);
  }

  function ensureModalExists() {
    let modal = getElement('transaction-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'transaction-modal';
      modal.className = 'transaction-modal';
      modal.innerHTML = `
        <div class="modal-backdrop"></div>
        <div class="modal-card">
          <div class="modal-header">
            <h3 id="modal-title" class="modal-title">Transactions</h3>
            <button id="close-modal-btn" class="close-btn" aria-label="Close">
              <i class="material-icons">close</i>
            </button>
          </div>
          
          <div class="modal-content">
            <div id="transactions-list" class="transactions-list">
              <!-- Transactions will be populated here -->
            </div>
            
            <div class="modal-actions">
              <button id="add-transaction-btn" class="add-transaction-btn">
                <i class="material-icons">add</i> Add More
              </button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      _elements['transaction-modal'] = modal;
      _elements['modal-title'] = modal.querySelector('#modal-title');
      _elements['transactions-list'] = modal.querySelector('#transactions-list');
      _elements['close-modal-btn'] = modal.querySelector('#close-modal-btn');
      _elements['add-transaction-btn'] = modal.querySelector('#add-transaction-btn');
    }
  }

  function createTableHeader(categories, daysInMonth) {
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    // Date column header
    const dateHeader = document.createElement('th');
    dateHeader.className = 'date-header';
    dateHeader.textContent = 'Date';
    headerRow.appendChild(dateHeader);
    
    // Category headers with monthly totals - FIXED EMOJI DUPLICATION
    categories.forEach(category => {
      const categoryHeader = document.createElement('th');
      categoryHeader.className = 'category-header';
      categoryHeader.setAttribute('data-category', category.id);
      categoryHeader.title = `${category.emoji} ${category.name}`;
      
      // Calculate monthly total for this category
      const monthlyTotal = getMonthTotalForCategory(category.id);
      
      // Create header content with emoji on top line, name on bottom (desktop only)
      const headerContent = document.createElement('div');
      headerContent.className = 'category-header-content';
      
      const categoryEmoji = document.createElement('div');
      categoryEmoji.className = 'category-emoji';
      categoryEmoji.textContent = category.emoji; // ONLY the emoji, no name
      
      const categoryName = document.createElement('div');
      categoryName.className = 'category-name';
      categoryName.textContent = category.name; // ONLY the clean name, no emoji
      
      const categoryTotal = document.createElement('div');
      categoryTotal.className = 'category-total';
      categoryTotal.textContent = formatCurrency(monthlyTotal);
      
      headerContent.appendChild(categoryEmoji);
      headerContent.appendChild(categoryName);
      headerContent.appendChild(categoryTotal);
      categoryHeader.appendChild(headerContent);
      
      headerRow.appendChild(categoryHeader);
    });
    
    // Daily total header
    const totalHeader = document.createElement('th');
    totalHeader.className = 'total-header';
    totalHeader.title = 'Daily Total';
    
    // Calculate monthly grand total
    const grandTotal = getMonthGrandTotal();
    
    const totalHeaderContent = document.createElement('div');
    totalHeaderContent.className = 'category-header-content';
    
    const totalEmoji = document.createElement('div');
    totalEmoji.className = 'category-emoji';
    totalEmoji.textContent = 'üí∞';
    
    const totalName = document.createElement('div');
    totalName.className = 'category-name total-label';
    totalName.textContent = 'Total';
    
    const totalValue = document.createElement('div');
    totalValue.className = 'category-total';
    totalValue.textContent = formatCurrency(grandTotal);
    
    totalHeaderContent.appendChild(totalEmoji);
    totalHeaderContent.appendChild(totalName);
    totalHeaderContent.appendChild(totalValue);
    totalHeader.appendChild(totalHeaderContent);
    
    headerRow.appendChild(totalHeader);
    
    // Notes header
    const notesHeader = document.createElement('th');
    notesHeader.className = 'notes-header';
    notesHeader.title = 'Notes';
    
    const notesHeaderContent = document.createElement('div');
    notesHeaderContent.className = 'category-header-content';
    
    const notesEmoji = document.createElement('div');
    notesEmoji.className = 'category-emoji';
    notesEmoji.textContent = 'üìù';
    
    const notesName = document.createElement('div');
    notesName.className = 'category-name';
    notesName.textContent = 'Notes';
    
    notesHeaderContent.appendChild(notesEmoji);
    notesHeaderContent.appendChild(notesName);
    notesHeader.appendChild(notesHeaderContent);
    
    headerRow.appendChild(notesHeader);
    
    thead.appendChild(headerRow);
    return thead;
  }
  
  function createTableBody(categories, daysInMonth) {
    const tbody = document.createElement('tbody');
    
    // Get today's date for highlighting
    const today = new Date();
    const isCurrentMonth = today.getMonth() === _currentMonth && today.getFullYear() === _currentYear;
    const currentDay = today.getDate();
    
    // Create a row for each day
    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(_currentYear, _currentMonth, day);
      const dayOfWeek = dateObj.getDay();
      
      const isWeekend = (dayOfWeek === 0);
      const isToday = isCurrentMonth && day === currentDay;
        
      const row = document.createElement('tr');
      row.className = 'day-row';
      
      if (isWeekend) {
        row.classList.add('weekend-row');
      }
      
      if (isToday) {
        row.classList.add('today-row');
      }
      
      // Date cell
      const dateCell = document.createElement('td');
      dateCell.className = 'date-cell';
      if (isWeekend) dateCell.classList.add('weekend-cell');
      if (isToday) dateCell.classList.add('today-cell');
      
      const dayName = dateObj.toLocaleString('en-US', { weekday: 'short' });
      
      dateCell.innerHTML = `<div class="date-container">
                              <span class="day-number">${day}</span>
                              <span class="day-name">${dayName}</span>
                            </div>`;
      row.appendChild(dateCell);
      
      // Daily total for calculating at the end
      let dayTotal = 0;
      
      // Category cells
      categories.forEach(category => {
        const cell = document.createElement('td');
        cell.className = 'grid-cell';
        if (isWeekend) cell.classList.add('weekend-cell');
        if (isToday) cell.classList.add('today-cell');
        cell.setAttribute('data-day', day);
        cell.setAttribute('data-category', category.id);
        
        // Get transactions for this day and category
        const dayTransactions = getTransactionsForDayAndCategory(day, category.id);
        
        // If there are transactions, show amount and count
        if (dayTransactions.length > 0) {
          const amount = dayTransactions.reduce((sum, tx) => sum + tx.amount, 0);
          dayTotal += amount;
          
          // Determine color based on amount ranges (improved thresholds)
          let colorClass = 'amount-large';
          if (amount <= 30) {
            colorClass = 'amount-small';
          } else if (amount <= 75) {
            colorClass = 'amount-medium';
          }
          
          cell.innerHTML = `<div class="cell-content ${colorClass}">
                              <span class="amount">${formatCurrency(amount)}</span>
                              <span class="transaction-count">(${dayTransactions.length})</span>
                            </div>`;
        }
        
        row.appendChild(cell);
      });
      
      // Daily total cell
      const totalCell = document.createElement('td');
      totalCell.className = 'total-cell';
      if (isWeekend) totalCell.classList.add('weekend-cell');
      if (isToday) totalCell.classList.add('today-cell');
      
      if (dayTotal > 0) {
        totalCell.innerHTML = `<div class="total-amount">${formatCurrency(dayTotal)}</div>`;
      }
      
      row.appendChild(totalCell);
      
      // Notes cell - now shows auto-generated transaction summary
      const notesCell = document.createElement('td');
      notesCell.className = 'notes-cell';
      if (isWeekend) notesCell.classList.add('weekend-cell');
      if (isToday) notesCell.classList.add('today-cell');
      
      // Generate transaction summary for this day
      const transactionSummary = generateDayTransactionSummary(day);
      
      // Create notes content div (no longer editable)
      const notesContent = document.createElement('div');
      notesContent.className = 'notes-content';
      notesContent.textContent = transactionSummary;
      
      // Add title attribute for full summary on hover if truncated
      if (transactionSummary.includes(' ...')) {
        // Get the full summary for tooltip
        const allDayTransactions = _transactions.filter(tx => {
          if (!tx.date) return false;
          const txDay = tx.date.getDate();
          const txMonth = tx.date.getMonth();
          const txYear = tx.date.getFullYear();
          return txDay === day && txMonth === _currentMonth && txYear === _currentYear;
        });
        
        const fullSummary = allDayTransactions.map(tx => {
          const name = tx.description || tx.name || 'Expense';
          const amount = formatCurrency(tx.amount);
          return `${name} ${amount}`;
        }).join(', ');
        
        notesContent.title = fullSummary;
        notesContent.style.cursor = 'help';
      }
      
      notesCell.appendChild(notesContent);
      row.appendChild(notesCell);
      
      tbody.appendChild(row);
    }
    
    return tbody;
  }

  /**
   * ENHANCED: Open transaction modal with blazing fast entry
   * Always shows an empty transaction row for quick entry
   */
  function openTransactionModal(day, categoryId) {
    if (_isClosingModal) return;
    
    console.log('Opening modal for day:', day, 'category:', categoryId);
    
    ensureModalExists();
    
    const modal = getElement('transaction-modal');
    if (!modal) {
      console.error('Modal element not found in DOM');
      return;
    }
    
    // FIXED: Now _categories contains parsed categories with id property
    const category = _categories.find(c => c.id === categoryId);
    if (!category) {
      console.error('Category not found:', categoryId);
      console.log('Available categories:', _categories);
      return;
    }
    
    const transactions = getTransactionsForDayAndCategory(parseInt(day), categoryId);
    console.log('Transactions found:', transactions.length);
    
    const dateObj = new Date(_currentYear, _currentMonth, parseInt(day));
    const formattedDate = dateObj.toLocaleDateString('en-US', { 
      weekday: 'short', 
      month: 'short', 
      day: 'numeric'
    });
    
    const total = transactions.reduce((sum, tx) => sum + tx.amount, 0);
    
    const modalTitle = getElement('modal-title');
    if (modalTitle) {
      modalTitle.innerHTML = `
        <div class="integrated-title">
          <span class="title-category">${category.emoji} ${category.name}</span>
          <span class="title-divider">|</span>
          <span class="title-date">${formattedDate}</span>
          ${total > 0 ? `<span class="title-divider">|</span><span class="title-total">Total: ${formatCurrency(total, 2)}</span>` : ''}
        </div>
      `;
    }
    
    const transactionsList = getElement('transactions-list');
    if (transactionsList) {
      transactionsList.innerHTML = '';
      
      // First, add existing transactions if any
      if (transactions.length > 0) {
        transactions.forEach(tx => {
          const item = createTransactionItem(tx);
          transactionsList.appendChild(item);
        });
      }
      
      // ALWAYS add an empty transaction row for quick entry
      const emptyTransaction = createEmptyTransaction(day, categoryId);
      const emptyItem = createTransactionItem(emptyTransaction);
      emptyItem.classList.add('new-transaction', 'ready-for-input');
      transactionsList.appendChild(emptyItem);
      
      // Auto-focus the amount field for blazing fast entry
      setTimeout(() => {
        const amountField = emptyItem.querySelector('.transaction-amount');
        if (amountField) {
          amountField.focus();
          amountField.select(); // Select any placeholder text
        }
      }, 100);
    }
    
    modal.setAttribute('data-day', day);
    modal.setAttribute('data-category', categoryId);
    
    document.addEventListener('keydown', handleEscKey);
    
    setTimeout(() => {
      modal.classList.add('visible');
    }, 10);
  }
  
  /**
   * Create an empty transaction object for quick entry
   */
  function createEmptyTransaction(day, categoryId) {
    const newId = `tx-new-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
    
    return {
      id: newId,
      date: new Date(_currentYear, _currentMonth, parseInt(day)),
      category: categoryId,
      amount: 0,
      description: '',
      account: 'Main Account',
      notes: ''
    };
  }
  
  /**
 * Create a transaction item in the modal
 * Now handles special treatment for subscription/fixed payment items
 */
/**
 * Create a transaction item in the modal
 * Now handles special treatment for subscription/fixed payment items
 */
/**
 * Create a transaction item in the modal
 * Simplified handling for subscription/fixed payment items
 */
function createTransactionItem(tx) {
  const item = document.createElement('div');
  item.className = 'transaction-item';
  item.setAttribute('data-id', tx.id);
  
  // Check if this is a subscription or fixed payment
  const isSpecialTransaction = tx.label && 
    (tx.label.toLowerCase().includes('subscription') || 
     tx.label.toLowerCase().includes('fixed payment'));
  
  if (isSpecialTransaction) {
    item.classList.add('fixed-transaction');
  }
  
  // Use placeholders instead of default values for better UX
  const amountValue = tx.amount && tx.amount > 0 ? tx.amount : '';
  const amountPlaceholder = _currencySymbol; // Just the currency symbol
  const descriptionValue = tx.description || '';
  const descriptionPlaceholder = 'Name';
  
  // Create HTML structure - simplified for special transactions
  const row = document.createElement('div');
  row.className = 'transaction-row';
  
  // 1. Amount field
  const amountInput = document.createElement('input');
  amountInput.type = 'number';
  amountInput.className = 'transaction-amount';
  amountInput.value = amountValue;
  amountInput.placeholder = amountPlaceholder;
  amountInput.min = '0';
  amountInput.step = '0.01';
  
  // 2. Description field with recurring icon for special transactions
  const descriptionContainer = document.createElement('div');
  descriptionContainer.style.display = 'flex';
  descriptionContainer.style.alignItems = 'center';
  descriptionContainer.style.width = '100%';
  
  const descriptionInput = document.createElement('input');
  descriptionInput.type = 'text';
  descriptionInput.className = 'transaction-description';
  descriptionInput.value = descriptionValue;
  descriptionInput.placeholder = descriptionPlaceholder;
  descriptionInput.style.width = '100%';
  
  descriptionContainer.appendChild(descriptionInput);
  
  // Add recurring icon for special transactions
  if (isSpecialTransaction) {
    const recurringIcon = document.createElement('span');
    recurringIcon.className = 'recurring-icon';
    recurringIcon.innerHTML = '<i class="material-icons">repeat</i>';
    descriptionContainer.appendChild(recurringIcon);
    
    // Make inputs readonly
    amountInput.setAttribute('readonly', 'readonly');
    descriptionInput.setAttribute('readonly', 'readonly');
  }
  
  // Add the inputs to the row
  row.appendChild(amountInput);
  row.appendChild(descriptionContainer);
  
  // Skip account column for special transactions
  
  // 3. Actions column (delete button) - only for regular transactions
  if (!isSpecialTransaction) {
    // For regular transactions: account dropdown
    const accountSelect = document.createElement('select');
    accountSelect.className = 'transaction-account';
    
    // Create options
    const options = [
      { value: 'Main Account', text: 'Main Account' },
      { value: 'Credit Card', text: 'Credit Card' },
      { value: 'Savings', text: 'Savings' }
    ];
    
    options.forEach(option => {
      const optionEl = document.createElement('option');
      optionEl.value = option.value;
      optionEl.textContent = option.text;
      if (option.value === tx.account) {
        optionEl.selected = true;
      }
      accountSelect.appendChild(optionEl);
    });
    
    row.appendChild(accountSelect);
    
    // Delete button
    const actions = document.createElement('div');
    actions.className = 'transaction-actions';
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'transaction-delete';
    deleteBtn.innerHTML = '<i class="material-icons">close</i>';
    
    actions.appendChild(deleteBtn);
    row.appendChild(actions);
  } else {
    // For special transactions, just a blank div to maintain grid layout
    const spacer = document.createElement('div');
    row.appendChild(spacer);
  }
  
  // Add the row to the item
  item.appendChild(row);
  
  // Only set up event handlers for non-special transactions
  if (!isSpecialTransaction) {
    setupTransactionItemEvents(item, tx);
  }
  
  return item;
}
  
/**
 * Setup event handlers for transaction items
 * Only called for regular (non-subscription) transactions
 */
function setupTransactionItemEvents(item, tx) {
  const deleteBtn = item.querySelector('.transaction-delete');
  if (deleteBtn) {
    deleteBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      
      item.remove();
      
      const index = _transactions.findIndex(transaction => transaction.id === tx.id);
      if (index !== -1) {
        _transactions.splice(index, 1);
      }
      
      updateTransactionTotal();
      renderGrid();
    });
  }
  
  const amountInput = item.querySelector('.transaction-amount');
  if (amountInput) {
    amountInput.addEventListener('input', function() {
      tx.amount = parseFloat(this.value) || 0;
      updateTransactionTotal();
      renderGrid();
    });
    
    // Add to global transactions array when amount is entered
    amountInput.addEventListener('change', function() {
      if (parseFloat(this.value) > 0) {
        // Check if this transaction is already in the array
        const existingIndex = _transactions.findIndex(transaction => transaction.id === tx.id);
        if (existingIndex === -1) {
          // Not in array yet, add it
          _transactions.push(tx);
          console.log('Added new transaction to global array:', tx);
        }
      }
    });
  }
  
  const descriptionInput = item.querySelector('.transaction-description');
  if (descriptionInput) {
    descriptionInput.addEventListener('input', function() {
      tx.description = this.value;
    });
    
    // Move to next field when Enter is pressed
    descriptionInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        const accountSelect = item.querySelector('.transaction-account');
        if (accountSelect) {
          accountSelect.focus();
        }
      }
    });
  }
  
  const accountSelect = item.querySelector('.transaction-account');
  if (accountSelect) {
    accountSelect.addEventListener('change', function() {
      tx.account = this.value;
    });
    
    // Close modal when Enter is pressed on account select
    accountSelect.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        closeTransactionModal();
      }
    });
  }
}
  
  function updateTransactionTotal() {
    const transactionsList = getElement('transactions-list');
    const modalTitle = getElement('modal-title');
    if (!transactionsList || !modalTitle) return;
    
    const amounts = Array.from(transactionsList.querySelectorAll('.transaction-amount'))
      .map(input => parseFloat(input.value) || 0);
    
    const total = amounts.reduce((sum, amount) => sum + amount, 0);
    
    const titleTotal = modalTitle.querySelector('.title-total');
    if (titleTotal) {
      titleTotal.textContent = `Total: ${formatCurrency(total, 2)}`;
    } else if (total > 0) {
      const titleContent = modalTitle.querySelector('.integrated-title');
      if (titleContent) {
        const divider = document.createElement('span');
        divider.className = 'title-divider';
        divider.textContent = '|';
        
        const newTotal = document.createElement('span');
        newTotal.className = 'title-total';
        newTotal.textContent = `Total: ${formatCurrency(total, 2)}`;
        
        titleContent.appendChild(divider);
        titleContent.appendChild(newTotal);
      }
    }
  }
  
  function handleEscKey(e) {
    if (e.key === 'Escape') {
      closeTransactionModal();
    }
  }
  
  function closeTransactionModal() {
    console.log('Closing transaction modal');
    _isClosingModal = true;
    
    const modal = getElement('transaction-modal');
    if (modal) {
      modal.classList.remove('visible');
      console.log('Modal visibility class removed');
      
      document.removeEventListener('keydown', handleEscKey);
      
      renderGrid();
      
      setTimeout(() => {
        _isClosingModal = false;
      }, 300);
    }
  }
  
  function addTransactionRow() {
    console.log('Adding additional transaction row');
    
    const transactionsList = getElement('transactions-list');
    const modal = getElement('transaction-modal');
    
    if (!transactionsList || !modal) {
      console.error('Required elements not found');
      return;
    }
    
    const day = modal.getAttribute('data-day');
    const categoryId = modal.getAttribute('data-category');
    
    if (!day || !categoryId) {
      console.error('Missing day or category information');
      return;
    }
    
    // Create another empty transaction
    const newTx = createEmptyTransaction(day, categoryId);
    const item = createTransactionItem(newTx);
    item.classList.add('new-transaction');
    
    // Insert before the Add More button
    const addMoreButton = transactionsList.parentElement.querySelector('.modal-actions');
    transactionsList.appendChild(item);
    
    // Auto-focus the amount field
    setTimeout(() => {
      const amountField = item.querySelector('.transaction-amount');
      if (amountField) {
        amountField.focus();
      }
    }, 100);
    
    updateTransactionTotal();
  }
  
  /**
   * Set expense data from external source (enhanced)
   */
  function setExpenseData(expenses) {
    if (!expenses || !Array.isArray(expenses)) {
      console.error('Invalid expense data provided:', expenses);
      return;
    }
    
    console.log('Setting expense data in MonthlyGrid:', expenses.length, 'transactions');
    
    // Process the new data
    processRealExpenseData(expenses);
    
    // Render with the new data
    renderGrid();
  }

  /**
   * Clear cache for testing or troubleshooting
   */
  function clearCache() {
    console.log('Clearing all expense cache...');
    
    // Clear in-memory cache
    _expenseCache.clear();
    
    // Clear localStorage cache
    try {
      const keys = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(CACHE_PREFIX)) {
          keys.push(key);
        }
      }
      
      keys.forEach(key => localStorage.removeItem(key));
      console.log(`Cleared ${keys.length} cache entries from localStorage`);
    } catch (error) {
      console.warn('Error clearing localStorage cache:', error);
    }
  }

  // Public methods
  return {
    init: init,
    renderGrid: renderGrid,
    setExpenseData: setExpenseData,
    refresh: refresh,
    updateCurrency: updateCurrency,
    openTransactionModal: openTransactionModal,
    unbindEvents: unbindEvents,
    clearCache: clearCache  // For debugging
  };
})();

// Test function to examine raw date data from spreadsheet
function testRawDateData() {
  console.log("=== TESTING RAW DATE DATA FROM SPREADSHEET ===");
  
  if (!window.API || typeof API.testRawExpenseDates !== 'function') {
    console.error("API.testRawExpenseDates function not found. Need to add it to API.html");
    return;
  }
  
  API.testRawExpenseDates(
    function(result) {
      console.log("Raw date test results:", result);
      
      if (result.success && result.dates) {
        console.log("=== SPREADSHEET DATE ANALYSIS ===");
        console.log("Total rows examined:", result.totalRows);
        console.log("Non-empty dates found:", result.dates.length);
        
        // Group by what the raw value looks like
        const dateFormats = {};
        const dateTypes = {};
        
        result.dates.forEach((item, index) => {
          const rawValue = item.rawValue;
          const valueType = typeof rawValue;
          const valueString = String(rawValue);
          
          // Track types
          dateTypes[valueType] = (dateTypes[valueType] || 0) + 1;
          
          // Track formats
          if (!dateFormats[valueString]) {
            dateFormats[valueString] = {
              count: 0,
              type: valueType,
              sampleRow: item.row,
              parsedDate: item.parsedDate
            };
          }
          dateFormats[valueString].count++;
          
          // Log first 10 examples
          if (index < 10) {
            console.log(`Row ${item.row}: "${rawValue}" (${valueType}) -> ${item.parsedDate}`);
          }
        });
        
        console.log("\n=== DATE TYPE SUMMARY ===");
        Object.entries(dateTypes).forEach(([type, count]) => {
          console.log(`${type}: ${count} occurrences`);
        });
        
        console.log("\n=== DATE FORMAT SUMMARY ===");
        Object.entries(dateFormats)
          .sort((a, b) => b[1].count - a[1].count)
          .slice(0, 10) // Show top 10 formats
          .forEach(([format, info]) => {
            console.log(`"${format}" (${info.type}): ${info.count} times`);
          });
      } else {
        console.error("Failed to get date data:", result.error);
      }
    },
    function(error) {
      console.error("Error testing raw dates:", error);
    }
  );
}

// Add to window for easy testing
window.testRawDateData = testRawDateData;

// Expose globally
window.MonthlyGrid = MonthlyGrid;

</script>
<style>
/* ======================================================
   MONTHLY GRID VIEW STYLES - DASHBOARD STYLE MATCHING
   ======================================================
   Matching dashboard's signature border style and color scheme.
*/

/* ============= MAIN CONTAINER ============= */
.monthly-grid-container {
  width: 100%;
  height: 100%;
  min-height: 400px;
  position: relative;
  overflow: auto;
  padding: 8px 16px 16px 16px;
  max-height: calc(100vh - 90px);
  max-width: 1200px;
  margin: 0 auto;
  background-color: #ffffff;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

/* ============= GRID HEADER ============= */
.grid-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  padding: 8px 0;
  background-color: #fe9aa1;
  border-radius: 0px;
  padding: 12px 16px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}



.month-nav-btn {
  background: none;
  border: none;
  color: #2c3e50;
  cursor: pointer;
  width: 36px;
  height: 36px;
  border-radius: 0px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
}

.month-nav-btn:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.month-year-display {
  font-size: 18px;
  font-weight: 500;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* ============= GRID TABLE ============= */
.monthly-grid {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;
  min-width: 750px;
}

/* Headers - Sticky positioning with dashboard style */
.monthly-grid thead {
  position: sticky;
  top: 0px;
  z-index: 200;
}

.monthly-grid th {
  background-color: #f8f5f5 !important;
  padding: 6px 4px;
  text-align: left;
  font-weight: 500;
  color: #2c3e50;
  border-bottom: 1px solid #ddd;
  border-right: 1px solid #ddd;
  position: sticky;
  top: 0;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  z-index: 210;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.monthly-grid th.total-header {
  background-color: #f8e4e4 !important;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
  z-index: 220;
}

.monthly-grid th.date-header {
  width: 60px !important;
  min-width: 60px !important;
  max-width: 60px !important;
  text-align: center !important;
  padding: 6px 4px !important;
  position: sticky !important;
  left: 0 !important;
  top: 0 !important;
  z-index: 1000 !important;
  background-color: #f7f5f5 !important;
  border-bottom: 1px solid #ddd !important;
  border-right: 1px solid #ddd !important;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1) !important;
}

.category-header {
  min-width: 75px;
  width: 75px;
}

.total-header {
  width: 80px;
  text-align: center;
}

.notes-header {
  width: 120px;
}

/* Category header content layout */
.category-header-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

/* Emoji styling - centered on top */
.category-emoji {
  font-size: 18px;
  line-height: 1;
  margin: 0;
  padding: 2px 0;
  text-align: center;
}

/* Category name styling - below emoji, centered */
.category-name {
  font-size: 10px;
  text-align: center;
  line-height: 1.1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
  margin: 0;
  padding: 0;
  font-weight: 500;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* Category total styling */
.category-total {
  font-size: 13px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* Day rows and cells */
.day-row {
  background-color: #ffffff;
}

.day-row:hover {
  background-color: rgba(44, 62, 80, 0.05);
}

.weekend-row {
  background-color: rgba(255, 249, 219, 0.3) !important;
}

.weekend-row:hover {
  background-color: rgba(255, 249, 219, 0.5) !important;
}





/* Apply highlighting only to the cell */
.today-cell {
  font-weight: 500;
}

/* Fix for today's cell highlighting */


/* Only apply the blue background to the date cell */
.today-row td.date-cell {
  font-weight: 500;
  background-color: #cdeef5 !important;
}





.monthly-grid td {
  padding: 2px;
  border-bottom: 1px solid #eee;
  border-right: 1px solid #eee;
  height: 32px;
  vertical-align: middle;
}

.date-cell {
  position: sticky !important;
  left: 0 !important;
  z-index: 100 !important;
  background-color: #f7f5f5 !important;
}

.date-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
}

.day-number {
  font-size: 13px;
  font-weight: 600;
  line-height: 1;
  margin: 0;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.day-name {
  font-size: 9px;
  color: #666;
  line-height: 1;
  margin: 0;
}

.grid-cell {
  cursor: pointer;
  transition: background-color 0.2s;
  position: relative;
}

.grid-cell:hover {
  background-color: rgba(44, 62, 80, 0.1);
}

/* Cell content with color coding */
.cell-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 1px;
  padding: 3px 2px;
  color: black;
  font-weight: 500;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  border-radius: 0px;
}

/* Color coding */
.amount-small {
  background-color: rgba(76, 175, 80, 0.15); /* Light green */
  border-left: 3px solid #4CAF50;
}

.amount-medium {
  background-color: rgba(255, 193, 7, 0.15); /* Light amber */
  border-left: 3px solid #FFC107;
}

.amount-large {
  background-color: rgba(244, 67, 54, 0.15); /* Light red */
  border-left: 3px solid #F44336;
}

.amount {
  font-size: 12px;
  font-weight: 600;
  line-height: 1;
  margin: 0;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.transaction-count {
  font-size: 9px;
  color: rgba(0, 0, 0, 0.6);
  line-height: 1;
  margin: 0;
  font-style: italic;
}

.total-cell {
  font-weight: 600;
  color: #2c3e50;
  text-align: center;
  background-color: rgba(244, 67, 54, 0.08);
}

.total-amount {
  font-size: 13px;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  line-height: 1;
  font-weight: 700;
  font-family: 'Lato', sans-serif;
}

.notes-cell {
  position: relative;
}

.notes-content {
  min-height: 20px;
  padding: 3px;
  border: 1px solid transparent;
  border-radius: 0px;
  transition: border-color 0.2s, background-color 0.2s;
  outline: none;
  font-size: 10px;
  background-color: rgba(241, 241, 241, 0.5);
  line-height: 1.2;
  width: 100%;
  box-sizing: border-box;
}

.notes-content:hover, .notes-content:focus {
  border-color: #ddd;
  background-color: rgba(241, 241, 241, 0.8);
}

.notes-content:focus {
  background-color: rgba(255, 255, 255, 0.9);
  box-shadow: 0 0 0 2px rgba(44, 62, 80, 0.2);
}

/* Error states */
.grid-error {
  padding: 30px 20px;
  text-align: center;
  color: #d32f2f;
  background-color: #ffebee;
  border-radius: 0px;
  margin: 20px 0;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

.grid-error h3 {
  margin: 0 0 16px 0;
  font-size: 18px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.grid-error p {
  margin: 8px 0;
  line-height: 1.5;
}

.retry-btn {
  margin-top: 16px;
  padding: 10px 20px;
  background-color: #d32f2f;
  color: white;
  border: none;
  border-radius: 0px;
  cursor: pointer;
  font-weight: 500;
  font-size: 14px;
  transition: background-color 0.2s;
}

.retry-btn:hover {
  background-color: #b71c1c;
}

/* Loading indicator */
.loading-indicator {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 20px;
  color: #666;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #e0e0e0;
  border-top: 4px solid #2c3e50;
  border-radius: 50%;
  animation: loading-spin 1s linear infinite;
  margin-bottom: 16px;
}

@keyframes loading-spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-indicator p {
  margin: 8px 0;
  font-size: 14px;
  line-height: 1.5;
}

.loading-indicator small {
  font-size: 12px;
  color: #666;
  opacity: 0.7;
}

/* ============= TRANSACTION MODAL ============= */
.transaction-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  display: none;
  opacity: 0;
  align-items: center;
  justify-content: center;
  transition: opacity 0.3s ease;
}

.transaction-modal.visible {
  display: flex;
  opacity: 1;
}

.modal-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(3px);
}

.modal-card {
  position: relative;
  width: 90%;
  max-width: 650px;
  max-height: 85vh;
  background-color: #ffffff;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
  display: flex;
  flex-direction: column;
  transform: translateY(20px);
  transition: transform 0.3s ease;
}

.transaction-modal.visible .modal-card {
  transform: translateY(0);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  border-bottom: 1px solid #ddd;
  background-color: #fafafa;
  border-radius: 0px;
}

.modal-title {
  margin: 0;
  font-size: 18px;
  font-weight: 500;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.close-btn {
  background: none;
  border: none;
  color: #666;
  cursor: pointer;
  width: 36px;
  height: 36px;
  border-radius: 0px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
}

.close-btn:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

.modal-content {
  flex: 1;
  padding: 20px;
  overflow-y: auto;
}

.transactions-list {
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-bottom: 20px;
}

.transaction-item {
  background-color: #ffffff;
  padding: 16px;
  transition: transform 0.2s, box-shadow 0.2s;
}

.transaction-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* Transaction row layout */
.transaction-row {
  display: grid;
  grid-template-columns: 90px 1fr 60px 40px;
  gap: 12px;
  align-items: center;
}

.transaction-amount, .transaction-description {
  padding: 10px 5px;
  border: 1px solid #ddd;
  border-radius: 0px;
  font-size: 14px;
  transition: border-color 0.2s, box-shadow 0.2s;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.transaction-amount:focus, .transaction-description:focus {
  border-color: #2c3e50;
  box-shadow: 0 0 0 3px rgba(44, 62, 80, 0.1);
  outline: none;
}

/* Compact account dropdown */
.transaction-account {
  color: transparent;
  background-color: #ffffff;
  border: 1px solid #ddd;
  border-radius: 0px;
  font-size: 14px;
  width: 60px;
  cursor: pointer;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
  background-position: center;
  background-repeat: no-repeat;
  background-size: 16px;
  padding: 10px;
  transition: border-color 0.2s;
}

.transaction-account:hover, .transaction-account:focus {
  border-color: #2c3e50;
}

.transaction-actions {
  display: flex;
  justify-content: center;
}

.transaction-delete {
  background: none;
  border: none;
  color: #f44336;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity 0.2s, background-color 0.2s;
  width: 36px;
  height: 36px;
  border-radius: 0px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.transaction-delete:hover {
  opacity: 1;
  background-color: rgba(244, 67, 54, 0.1);
}

.new-transaction {
  animation: fade-in 0.3s ease-out;
}

@keyframes fade-in {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.empty-transactions {
  text-align: center;
  color: #666;
  padding: 40px 20px;
  font-style: italic;
  font-size: 15px;
}

.modal-actions {
  display: flex;
  justify-content: center;
  margin-top: 8px;
  padding-top: 16px;
}

.add-transaction-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 20px;
  background-color: #2c3e50;
  color: white;
  border: none;
  border-radius: 0px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.2s;
  font-size: 14px;
}

.add-transaction-btn:hover {
  background-color: #1e2b37;
}

/* Modal title layout */
.integrated-title {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.title-category {
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 6px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.title-divider {
  color: rgba(0, 0, 0, 0.3);
  font-weight: 300;
}

.title-date {
  color: rgba(0, 0, 0, 0.7);
  font-weight: 400;
  font-size: 0.9em;
}

.title-total {
  color: #2c3e50;
  font-weight: 600;
  margin-left: auto;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* ============= RESPONSIVE DESIGN ============= */
@media (max-width: 768px) {
  /* Ensure parent elements don't constrain height */
  .view, #expenseView, #expenseContent {
    height: 100% !important;
    max-height: none !important;
  }
  
  .monthly-grid-container {
    padding: 0px 0px 80px 0px !important; /* Add bottom padding for last day visibility */
    max-height: none !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    overflow: auto !important;
    z-index: 1 !important; /* Lower z-index so buttons appear above */
    box-sizing: border-box !important;
  }
  
  /* Ensure floating buttons stay above the grid */
  .quick-expense-btn {
    z-index: 9999 !important; /* Higher z-index to appear above grid */
  }
  
  /* Ensure sidebar toggle stays above the grid */
  #mobileSidebarToggle, .sidebar-toggle {
    z-index: 9999 !important; /* Higher z-index to appear above grid */
  }
  
  /* MOBILE: Hide category names, show only emojis */
  .category-name {
    display: none !important;
  }
  
  .category-emoji {
    font-size: 18px;
    padding: 4px 0;
  }
  
  .category-header {
    min-width: 40px !important;
    width: 40px !important;
    padding: 4px 2px !important;
  }
  
  .monthly-grid th.date-header, 
  .monthly-grid td.date-cell {
    width: 45px !important;
    min-width: 45px !important;
    max-width: 45px !important;
  }
  
  .day-name {
    font-size: 8px;
  }
  
  .day-number {
    font-size: 12px;
  }
  
  .total-header {
    width: 55px !important;
  }
  
  /* MOBILE: Transaction row optimization */
  .transaction-row {
    grid-template-columns: 45px 1fr 40px 40px;
    gap: 8px;
  }
  
  .transaction-item {
    padding: 6px;
  }
  
  .modal-header {
    padding: 16px;
  }
  
  .modal-content {
    padding: 16px;
  }
}

@media (max-width: 480px) {
  .notes-header, .notes-cell {
    display: none;
  }
  
  .monthly-grid td, .monthly-grid th {
    padding: 1px !important;
  }
  
  .category-header, .total-header {
    min-width: 35px !important;
    width: 35px !important;
  }
  
  .amount {
    font-size: 10px;
  }
  
  .transaction-count {
    display: none;
  }
  
  .integrated-title {
    font-size: 15px;
  }
}

/* ============= DARK MODE STYLES ============= */
/* Main container becomes dark */
body.dark-mode .monthly-grid-container {
  background-color: var(--dark-surface, #1e1e1e) !important;
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87)) !important;
}

/* Header becomes dark */
body.dark-mode .grid-header {
  background-color: var(--dark-surface, #1e1e1e) !important;
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87)) !important;
}

body.dark-mode .month-nav-btn {
  color: rgba(255, 255, 255, 0.87) !important;
}

body.dark-mode .month-year-display {
  color: rgba(255, 255, 255, 0.87) !important;
}

/* Table headers */
body.dark-mode .monthly-grid th {
  background-color: #334960 !important;
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  border-bottom: 1px solid var(--dark-border, rgba(255, 255, 255, 0.12));
  border-right: 1px solid var(--dark-border, rgba(255, 255, 255, 0.12));
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

body.dark-mode .monthly-grid th.date-header {
  background-color: #344960 !important;
}

body.dark-mode .monthly-grid th.total-header {
  background-color: #5f5f5f !important;
  box-shadow: 0 3px 4px rgba(0, 0, 0, 0.3) !important;
}

/* Table cells */
body.dark-mode .monthly-grid td {
  border-bottom: 1px solid var(--dark-border, rgba(255, 255, 255, 0.12));
  border-right: 1px solid var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .cell-content {
  background-color: var(--dark-surface, #1e1e1e);
  color: #e6e6e6;
}

body.dark-mode .date-cell {
  background-color: var(--dark-surface, #1e1e1e) !important;
}

body.dark-mode .weekend-row .date-cell {
  background-color: rgba(255, 249, 219, 0.05) !important;
}

body.dark-mode .today-row .date-cell {
  background-color: rgba(255, 235, 156, 0.08) !important;
}

body.dark-mode .day-name {
  color: rgba(255, 255, 255, 0.7);
}

body.dark-mode .day-number {
  color: #DDA15E !important;
}

body.dark-mode .day-row {
  background-color: var(--dark-surface, #1e1e1e);
}

body.dark-mode .day-row:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

body.dark-mode .weekend-row {
  background-color: rgba(255, 249, 219, 0.05) !important;
}

body.dark-mode .weekend-row:hover {
  background-color: rgba(255, 249, 219, 0.1) !important;
}



body.dark-mode .total-cell {
  background-color: rgba(244, 67, 54, 0.1);
}

/* Values get golden color */
body.dark-mode .amount,
body.dark-mode .total-amount,
body.dark-mode .category-total {
  color: #DDA15E !important;
}

body.dark-mode .grid-cell:hover {
  background-color: rgba(255, 255, 255, 0.08);
}

body.dark-mode .notes-content {
  background-color: rgba(58, 58, 58, 0.5);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .notes-content:hover,
body.dark-mode .notes-content:focus {
  background-color: rgba(58, 58, 58, 0.8);
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .notes-content:focus {
  background-color: rgba(40, 40, 40, 0.9);
}

/* Color coding in dark mode */
body.dark-mode .amount-small {
  background-color: rgba(76, 175, 80, 0.2);
  border-left-color: #4CAF50;
}

body.dark-mode .amount-medium {
  background-color: rgba(255, 193, 7, 0.2);
  border-left-color: #FFC107;
}

body.dark-mode .amount-large {
  background-color: rgba(244, 67, 54, 0.2);
  border-left-color: #F44336;
}

body.dark-mode .transaction-count {
  color: rgba(255, 255, 255, 0.7);
}

/* Modal dark mode */
body.dark-mode .modal-card {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .modal-header {
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
  background-color: rgba(255, 255, 255, 0.05);
}

body.dark-mode .transaction-item {
  background-color: var(--dark-surface, #1e1e1e);
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .transaction-amount,
body.dark-mode .transaction-description {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .transaction-account {
  background-color: var(--dark-surface, #1e1e1e);
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
}

body.dark-mode .title-divider {
  color: rgba(255, 255, 255, 0.3);
}

body.dark-mode .title-date {
  color: rgba(255, 255, 255, 0.7);
}

body.dark-mode .title-total {
  color: #DDA15E !important;
}

body.dark-mode .empty-transactions {
  color: rgba(255, 255, 255, 0.7);
}

body.dark-mode .add-transaction-btn {
  background-color: #DDA15E;
  color: #1e1e1e;
}

body.dark-mode .add-transaction-btn:hover {
  background-color: #c9955a;
}

/* Error states dark mode */
body.dark-mode .grid-error {
  background-color: var(--dark-surface, #1e1e1e);
  color: #ef5350;
}

body.dark-mode .loading-indicator {
  color: rgba(255, 255, 255, 0.7);
}

body.dark-mode .loading-spinner {
  border-color: #666;
  border-top-color: #DDA15E;
}

/* ============= LARGE SCREEN OPTIMIZATION ============= */
@media (min-width: 1400px) {
  .monthly-grid-container {
    max-width: 1400px;
    padding: 0;
  }
  
  .category-header {
    min-width: 85px;
    width: 85px;
  }
  
  .total-header {
    width: 90px;
  }
  
  .notes-header {
    width: 150px;
  }
}

/* Utility classes */
.hidden {
  display: none !important;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}


/* Simplified styling for fixed/subscription transactions */
.transaction-item.fixed-transaction {
  /* Remove background color and left border */
  background-color: transparent;
  border-left: none;
}

/* Remove the ::before pseudo-element with "recurring" text since we're using the icon */
.transaction-item.fixed-transaction::before {
  display: none;
}

/* Keep the grid layout but adjust for no account column */
.transaction-item.fixed-transaction .transaction-row {
  opacity: 1;
  /* Adjust grid template to remove account column */
  grid-template-columns: 90px 1fr 40px;
}

/* Style readonly inputs to look clean */
.transaction-item.fixed-transaction input {
  background-color: #f9f5fa;
  cursor: not-allowed;
  border-color: #eee;
  color: #555;
  pointer-events: none;
}

/* Hide the account column entirely */
.transaction-item.fixed-transaction .transaction-account-static {
  display: none;
}

/* Create styling for the recurring icon */
.recurring-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: #8e44ad;
  margin-left: 8px;
  vertical-align: middle;
}

.recurring-icon i {
  font-size: 18px;
}

/* Dark mode adjustments */
body.dark-mode .transaction-item.fixed-transaction input {
  background-color: #2a2a2a;
  border-color: #333;
  color: #bbb;
}

body.dark-mode .recurring-icon {
  color: #9b59b6;
}

/* Mobile adjustments */
@media (max-width: 768px) {
  .transaction-item.fixed-transaction .transaction-row {
    grid-template-columns: 45px 1fr 40px;
  }
  
  .recurring-icon i {
    font-size: 16px;
  }
}

</style>