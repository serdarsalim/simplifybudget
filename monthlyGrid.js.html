
<script>
var MonthlyGrid = (function() {
  // Private variables
  let _initialized = false;
  let _currentMonth = new Date().getMonth();
  let _currentYear = new Date().getFullYear();
  let _categories = [];
  let _transactions = [];
  let _isLoading = false;
 let _currencySymbol = '$';
  
  // ENHANCED: Smart caching system
  let _expenseCache = new Map(); // In-memory cache for current session
  let _prefetchQueue = new Set(); // Track ongoing prefetch operations
  const CACHE_PREFIX = 'monthlyGrid_expenses_';
  const CACHE_VERSION = '1.0';
  const MAX_CACHE_MONTHS = 6; // Limit cache size
  const SESSION_STORAGE_KEY = 'monthlyGrid_sessionActive'; // Track if session is new
  
  // DOM element cache for performance
  const _elements = {};
  
    
/**
 * Show day details popup with all transactions
 */
function showDayDetailsPopup(day) {
  // Get all transactions for this day
  const dayTransactions = _transactions.filter(tx => {
    if (!tx.date) return false;
    const txDay = tx.date.getDate();
    const txMonth = tx.date.getMonth();
    const txYear = tx.date.getFullYear();
    return txDay === day && txMonth === _currentMonth && txYear === _currentYear;
  });
  
  if (dayTransactions.length === 0) {
    return; // No transactions to show
  }
  
  // Format the date for header
  const dateObj = new Date(_currentYear, _currentMonth, day);
  const dayName = dateObj.toLocaleDateString('en-US', { weekday: 'short' });
  const monthDay = dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  
  // Create popup
  const popup = document.createElement('div');
  popup.className = 'day-details-popup';
  popup.innerHTML = `
    <div class="popup-backdrop"></div>
    <div class="popup-content">
      <div class="popup-header">
        <h3>Spending on ${dayName}, ${monthDay}</h3>
        <button class="popup-close">×</button>
      </div>
      <div class="popup-body">
        ${dayTransactions.map(tx => {
          const category = _categories.find(c => c.id === tx.category);
          const categoryDisplay = category ? `${category.emoji} ${category.name}` : tx.category;
          
          return `
            <div class="transaction-detail">
              <div class="detail-category">${categoryDisplay}</div>
              <div class="detail-name">${tx.description || 'Expense'}</div>
              <div class="detail-amount">${formatCurrency(tx.amount)}</div>
              <div class="detail-account">${tx.account || 'Main Account'}</div>
            </div>
          `;
        }).join('')}
      </div>
    </div>
  `;
  
  // Add to page
  document.body.appendChild(popup);
  
  // Close handlers
  const closeBtn = popup.querySelector('.popup-close');
  const backdrop = popup.querySelector('.popup-backdrop');
  
  function closePopup() {
    popup.remove();
  }
  
  closeBtn.addEventListener('click', closePopup);
  backdrop.addEventListener('click', closePopup);
  
  // Show popup
  setTimeout(() => popup.classList.add('visible'), 10);
}

/**
   * Generate cache key for a specific month/year
   */
  function getCacheKey(month, year) {
    return `${year}-${String(month).padStart(2, '0')}`;
  }
  
  /**
   * Check if this is a new session (page refresh/new tab) and clear cache if so
   */
  function handleSessionStart() {
    // Check if this is a new session
    const isSessionActive = sessionStorage.getItem(SESSION_STORAGE_KEY);
    
    if (!isSessionActive) {
      // This is a new session (page refresh/new tab)
      clearCache();
      sessionStorage.setItem(SESSION_STORAGE_KEY, 'true');
    } 
  }
  
  /**
   * Get expense data from cache (memory first, then localStorage)
   */
  function getCachedExpenses(month, year) {
    const key = getCacheKey(month, year);
    
  
    
    // Check localStorage cache
    try {
      const storageKey = CACHE_PREFIX + key;
      const cached = localStorage.getItem(storageKey);
      if (cached) {
        const data = JSON.parse(cached);
        
        // Check cache version and 24-hour expiry (within session)
        const cacheAge = Date.now() - data.timestamp;
        const isExpired = cacheAge > 24 * 60 * 60 * 1000; // 24 hours
        
        if (data.version === CACHE_VERSION && !isExpired) {
          
          // Store in memory cache for faster access
          _expenseCache.set(key, data.expenses);
          
          return data.expenses;
        } else {
          // Cache expired, remove it
          localStorage.removeItem(storageKey);
        }
      }
    } catch (error) {
      console.warn('Error reading from localStorage cache:', error);
    }
    
    return null;
  }
  
  /**
   * Store expense data in cache (both memory and localStorage)
   */
  function setCachedExpenses(month, year, expenses) {
    const key = getCacheKey(month, year);
    
    // Store in memory cache
    _expenseCache.set(key, expenses);
    
    // Store in localStorage with timestamp for 24-hour expiry
    try {
      const storageKey = CACHE_PREFIX + key;
      const data = {
        version: CACHE_VERSION,
        timestamp: Date.now(),
        month: month,
        year: year,
        expenses: expenses
      };
      
      localStorage.setItem(storageKey, JSON.stringify(data));
      
      // Clean up old cache entries if we exceed the limit
      cleanupCache();
      
    } catch (error) {
      console.warn('Error writing to localStorage cache:', error);
    }
  }
  
/**
 * Enhanced cleanup of expired cache entries
 */
function cleanupCache() {
  try {
    const keys = [];
    
    // Find all cache keys in localStorage
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(CACHE_PREFIX)) {
        keys.push(key);
      }
    }
    
    // Get the current date for age calculation
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    
    // Process all cache entries
    keys.forEach(key => {
      try {
        const data = JSON.parse(localStorage.getItem(key));
        
        // Skip if missing required data
        if (!data || !data.year || data.month === undefined) return;
        
        // Calculate how many months old this cache entry is
        const ageInMonths = (currentYear - data.year) * 12 + (currentMonth - data.month);
        
        // Remove entries older than MAX_CACHE_MONTHS
        if (ageInMonths > MAX_CACHE_MONTHS) {
          localStorage.removeItem(key);
        }
        
        // Also remove entries with timestamp older than 1 day
        const ageInMs = Date.now() - (data.timestamp || 0);
        if (ageInMs > 24 * 60 * 60 * 1000) { // 24 hours
          localStorage.removeItem(key);
        }
      } catch (e) {
        // If we can't parse the entry, just remove it
        localStorage.removeItem(key);
      }
    });
  } catch (error) {
    console.warn('Error during cache cleanup:', error);
  }
}
  
  /**
 * Enhanced prefetch logic 
 */
function prefetchMonth(month, year) {
  const key = getCacheKey(month, year);
  
  // Skip if already cached or currently being fetched
  if (getCachedExpenses(month, year) || _prefetchQueue.has(key)) {
    return Promise.resolve();
  }
  
  // Avoid prefetching future months that are too far ahead
  const now = new Date();
  const currentRealMonth = now.getMonth();
  const currentRealYear = now.getFullYear();
  const monthsAhead = (year - currentRealYear) * 12 + (month - currentRealMonth);
  
  // We always prefetch past months, but limit future months to 2 months ahead
  if (monthsAhead > 2) {
    return Promise.resolve();
  }
  
  _prefetchQueue.add(key);
  
  return new Promise((resolve) => {
    if (!window.API || typeof API.getExpenseData !== 'function') {
      _prefetchQueue.delete(key);
      resolve();
      return;
    }
    
    API.getExpenseData(
      month,
      year,
      function(result) {
        _prefetchQueue.delete(key);
        
        if (result && result.success && result.expenses) {
          setCachedExpenses(month, year, result.expenses);
        } else {
          // Even if we get an empty result, we should cache it to avoid repeated fetches
          const emptyResult = result && result.expenses ? result.expenses : [];
          console.log(`Prefetch for ${month}/${year} returned empty or error, caching empty result`);
          setCachedExpenses(month, year, emptyResult);
        }
        
        resolve();
      },
      function(error) {
        _prefetchQueue.delete(key);
        console.log(`Prefetch error for ${month}/${year}:`, error);
        
        // Cache empty array on error to prevent repeated failing requests
        setCachedExpenses(month, year, []);
        
        resolve();
      }
    );
  });
}
  
  /**
   * Get previous month/year
   */
  function getPreviousMonth(month, year) {
    let prevMonth = month - 1;
    let prevYear = year;
    
    if (prevMonth < 0) {
      prevMonth = 11;
      prevYear = year - 1;
    }
    
    return { month: prevMonth, year: prevYear };
  }
  
  /**
   * Get an element by ID with caching
   */
  function getElement(id) {
    if (!_elements[id]) {
      _elements[id] = document.getElementById(id);
    }
    return _elements[id];
  }

    // BRUTE FORCE FIX for monthlyGrid.js

// Replace the loadCurrencyFromSettings function with this:
function loadCurrencyFromSettings() {
  // First try - immediate
  if (window.SimBudget && SimBudget.Settings) {
    _currencySymbol = SimBudget.Settings.getSetting('currencySymbol') || '$';
  } else {
    _currencySymbol = '$'; // Default
  }
  
  // BRUTE FORCE: Keep checking for 10 seconds with increasing intervals
  const checkTimes = [100, 300, 500, 1000, 2000, 3000, 5000, 8000];
  
  checkTimes.forEach(delay => {
    setTimeout(() => {
      if (window.SimBudget && SimBudget.Settings) {
        const newSymbol = SimBudget.Settings.getSetting('currencySymbol') || '$';
        
        // Only update if it changed
        if (newSymbol !== _currencySymbol) {
          _currencySymbol = newSymbol;
          renderGrid(); // Re-render with new currency
        }
      }
    }, delay);
  });
}

      
  /**
   * Format currency amount consistently
   * @param {number} amount - Amount to format
   * @param {number} decimals - Number of decimal places (default: 0)
   * @return {string} Formatted currency string
   */
  function formatCurrency(amount, decimals = 0) {
    return `${_currencySymbol}${amount.toFixed(decimals)}`;
  }

  /**
   * Initialize the Monthly Grid
   */
  function init(containerId) {
  if (_initialized && !containerId) {
    return;
  }
  
  
  // Initialize system month tracking
  _systemCurrentMonth = new Date().getMonth();
  _systemCurrentYear = new Date().getFullYear();
  
  // Only set current month/year if not already set (prevents overwriting when reinitializing)
  if (!_initialized) {
    _currentMonth = _systemCurrentMonth;
    _currentYear = _systemCurrentYear;
  }
  
  // Handle session start (clear cache on page refresh/new session)
  handleSessionStart();
  
  // Load currency symbol from user settings
  loadCurrencyFromSettings();
  
  // Clean up any existing event handlers first
  if (_initialized) {
    unbindEvents();
  }
  
  // Remove any existing currency change listener first
  document.removeEventListener('currency-changed', handleCurrencyChange);
  // Add the currency change listener
  document.addEventListener('currency-changed', handleCurrencyChange);
  

  // Find and store container element
  if (containerId) {
    const container = document.getElementById(containerId);
    if (container) {
      _elements['monthly-grid-container'] = container;
    } else {
      console.error("Container not found:", containerId);
      return;
    }
  } else {
    // Try to find the default container
    const defaultContainer = document.getElementById("monthly-grid-container");
    if (!defaultContainer) {
      console.error("Default grid container not found");
      return;
    }
    _elements['monthly-grid-container'] = defaultContainer;
  }
  
  // Set up event handlers
  bindEvents();
  
  // Set up periodic check for current month change (every 10 minutes)
  if (!window._monthCheckInterval) {
    window._monthCheckInterval = setInterval(checkCurrentMonth, 10 * 60 * 1000);
    // Also check on visibility change (when user returns to tab)
    document.addEventListener('visibilitychange', function() {
      if (document.visibilityState === 'visible') {
        checkCurrentMonth();
      }
    });
  }
  

  
  // Load real data from spreadsheet (with smart caching)
  loadRealExpenseData();
  
  // Prevent body scrolling on mobile
  if (window.innerWidth <= 768) {
    document.body.style.overflow = 'hidden';
    
    // Allow the grid container to scroll
    const container = getElement('monthly-grid-container');
    if (container) {
      container.style.overflow = 'auto';
    }
  }
  
  _initialized = true;
}

/**
 * ADDED: Handle currency change events
 * @param {Event} event - The currency-changed event
 */
function handleCurrencyChange(event) {  
  // Update the currency symbol
  _currencySymbol = event.detail.symbol;
  
  // Re-render the grid with new currency
  renderGrid();
}
  
  /**
   * ENHANCED: Load real expense data with smart caching and prefetching
   */
  function loadRealExpenseData(month = _currentMonth, year = _currentYear) {
  if (_isLoading) {
    return Promise.resolve();
  }
  
  // Check cache first for instant loading
  const cachedExpenses = getCachedExpenses(month, year);
  if (cachedExpenses) {
    
    // Load categories first, then process cached data
    return loadActiveCategories()
      .then(categories => {
        processRealExpenseData(cachedExpenses);
        renderGrid();
        
        // Bidirectional prefetching - both previous and next months
        const prev = getPreviousMonth(month, year);
        const next = getNextMonth(month, year);
        
        setTimeout(() => {
          // First check if it makes sense to prefetch (avoid future months too far ahead)
          const now = new Date();
          const currentRealMonth = now.getMonth();
          const currentRealYear = now.getFullYear();
          
          // Prefetch previous month (always)
          prefetchMonth(prev.month, prev.year);
          
          // Only prefetch next month if it's not too far in the future
          // (next month OR current month + max 2 months ahead)
          const monthsAhead = (next.year - currentRealYear) * 12 + (next.month - currentRealMonth);
          if (monthsAhead <= 2) {
            prefetchMonth(next.month, next.year);
          }
        }, 100);
        
        return Promise.resolve();
      })
      .catch(error => {
        console.error('Error loading categories for cached data:', error);
        // Fall back to fresh fetch
        return fetchFreshExpenseData(month, year);
      });
  }
  
  // Not in cache, fetch fresh data
  return fetchFreshExpenseData(month, year);
}

/**
 * Failsafe mechanism to ensure current month is always accurate
 */
function checkCurrentMonth() {
  const now = new Date();
  const realCurrentMonth = now.getMonth();
  const realCurrentYear = now.getFullYear();
  
  // Compare with our stored current month/year
  if (realCurrentMonth !== _currentMonth || realCurrentYear !== _currentYear) {
    // Only update if we're viewing what we think is the current month
    const viewingCurrentMonth = (_systemCurrentMonth === _currentMonth && 
                                 _systemCurrentYear === _currentYear);
    
    // Update system tracking
    _systemCurrentMonth = realCurrentMonth;
    _systemCurrentYear = realCurrentYear;
    
    // If we were viewing the "current" month, update to the new current month
    if (viewingCurrentMonth) {
      _currentMonth = realCurrentMonth;
      _currentYear = realCurrentYear;
      updateMonthYearDisplay();
      loadRealExpenseData(_currentMonth, _currentYear);
    }
    
    // Clear old cache for months that are now more than 6 months old
    cleanupCache();
  }
}
  
  /**
   * Fetch fresh expense data from the server
   */
  function fetchFreshExpenseData(month, year) {
    _isLoading = true;
    
    // Debug logging
    const currentDate = new Date(year, month, 1);
    const monthName = currentDate.toLocaleString('default', { month: 'long' });
    
    // Show loading indicator only for fresh fetches
    showLoadingIndicator();
    
    // Clear existing data
    _transactions = [];
    _categories = [];
    
    // STEP 1: Load active categories first
    return loadActiveCategories()
      .then(categories => {
        
        // STEP 2: Load expenses for the specified month
        if (!window.API || typeof API.getExpenseData !== 'function') {
          throw new Error('API.getExpenseData function not found. Check API.html file.');
        }
                
        return new Promise((resolve, reject) => {
          API.getExpenseData(
            month,
            year,
            function(result) {
             // console.log('SUCCESS: API returned:', result);
              
              if (!result) {
                reject('Server returned null result');
                return;
              }
              
              if (!result.success) {
                reject('Server returned failure: ' + (result.error || 'No error message'));
                return;
              }
              
              if (!result.expenses || !Array.isArray(result.expenses)) {
                reject('Server returned invalid expenses data. Type: ' + typeof result.expenses);
                return;
              }
              
              resolve(result.expenses);
            },
            function(error) {
              reject('Server function call failed: ' + error);
            }
          );
        });
      })
      .then(expenses => {
        
        // Cache the fresh data
        setCachedExpenses(month, year, expenses);
        
        // STEP 3: Process the expense data
        processRealExpenseData(expenses);
        
        // STEP 4: Render the grid with fresh data
        renderGrid();
        
        hideLoadingIndicator();
        _isLoading = false;
        
        // Start prefetching previous month in background
        const prev = getPreviousMonth(month, year);
        setTimeout(() => {
          prefetchMonth(prev.month, prev.year);
        }, 500);
        
        return Promise.resolve();
      })
      .catch(error => {
        console.error('FAILED: Error loading expense data:', error);
        showErrorMessage('Failed to load data: ' + error);
        hideLoadingIndicator();
        _isLoading = false;
        return Promise.reject(error);
      });
  }
  
  /**
   * Parse category string to extract name and emoji
   * Format: "Business 💼" -> {name: "Business", emoji: "💼"}
   */
  function parseCategoryNameAndEmoji(categoryString) {
    // Split by space and check if last part is an emoji
    const parts = categoryString.trim().split(' ');
    
    if (parts.length >= 2) {
      // Check if the last part contains emoji characters
      const lastPart = parts[parts.length - 1];
      const emojiRegex = /[\u{1F600}-\u{1F6FF}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
      
      if (emojiRegex.test(lastPart)) {
        // Last part contains emoji, split name and emoji
        const name = parts.slice(0, -1).join(' ');
        const emoji = lastPart;
        return { name, emoji };
      }
    }
    
    // No emoji found, return the whole string as name
    return { name: categoryString, emoji: '' };
  }
  

    /**
   * Add non-active categories that have spending in the current month
   * Called after transactions are loaded
   */
  /**
 * Add non-active categories that have spending in the current month
 */
function addInactiveCategoriesWithSpending() {
  // Get all unique category names used in transactions for current month
  const usedCategories = new Set();
  
  _transactions.forEach(tx => {
    if (tx.date.getMonth() === _currentMonth && 
        tx.date.getFullYear() === _currentYear) {
      usedCategories.add(tx.category);
    }
  });
  
  // Build list of active category IDs for quick lookup
  const activeIds = new Set(_categories.map(c => c.id));
  
  // For each used category not in active list, add it
  usedCategories.forEach(categoryId => {
    if (!activeIds.has(categoryId)) {
      // Parse the category string to extract name and emoji
      const parsed = parseCategoryNameAndEmoji(categoryId);
      
      _categories.push({
        id: parsed.name,
        name: parsed.name,
        emoji: parsed.emoji || '🛸', // Use default emoji only if none found
        active: false,  // Mark as inactive but shown
        hasTransactions: true
      });
      
    }
  });
}




  /**
   * Load categories exactly like QuickExpenseEntry does - FIXED to store parsed categories
   */
  function loadActiveCategories() {
    
    return new Promise((resolve, reject) => {
      // First try to load from local storage for immediate display
      const cachedCategories = localStorage.getItem('simbudget_categories');
      const activeCategories = localStorage.getItem('simbudget_active_categories');
      
      if (cachedCategories && activeCategories) {
        try {
          const allCategories = JSON.parse(cachedCategories);
          const active = JSON.parse(activeCategories);
          
          
          // FIXED: Parse categories immediately and store in correct format
          const parsedActiveCategories = allCategories
            .filter(cat => {
              const categoryName = typeof cat === 'string' ? cat : cat.name;
              return active.includes(categoryName);
            })
            .map(cat => {
              const categoryString = typeof cat === 'string' ? cat : cat.name;
              const parsed = parseCategoryNameAndEmoji(categoryString);
              return {
                id: parsed.name,        // Clean name as ID for matching
                name: parsed.name,      // Clean name without emoji
                emoji: parsed.emoji,    // Extracted emoji
                active: true
              };
            });
          
          // Store PARSED categories in _categories
          _categories = parsedActiveCategories;
          resolve(parsedActiveCategories);
          return;
        } catch (e) {
          console.error('Error parsing cached categories:', e);
        }
      }
      
      // If API exists, use it to load categories
      if (window.API && typeof API.getCategories === 'function') {
        API.getCategories(
          function(result) {
            if (result && result.success) {
              if (result.categories && result.activeCategories) {
                // FIXED: Parse categories immediately
                const parsedActiveCategories = result.categories
                  .filter(cat => result.activeCategories.includes(cat))
                  .map(cat => {
                    const parsed = parseCategoryNameAndEmoji(cat);
                    return {
                      id: parsed.name,        // Clean name as ID for matching
                      name: parsed.name,      // Clean name without emoji
                      emoji: parsed.emoji,    // Extracted emoji
                      active: true
                    };
                  });
                
                // Cache the full categories array (for other components)
                localStorage.setItem('simbudget_categories', JSON.stringify(result.categories));
                localStorage.setItem('simbudget_active_categories', JSON.stringify(result.activeCategories));
                
                // Store PARSED categories in _categories
                _categories = parsedActiveCategories;
                
                console.log('Loaded and parsed active categories from API:', parsedActiveCategories);
                resolve(parsedActiveCategories);
              } else {
                reject('No categories in API result');
              }
            } else {
              reject('API call failed');
            }
          },
          function(error) {
            console.error('Error loading categories:', error);
            reject(error);
          }
        );
      } else {
        reject('API.getCategories not available');
      }
    });
  }

  /**
   * Generate transaction summary for a specific day
   * @param {number} day - Day of the month
   * @return {string} Summary string like "Netflix €5, Groceries €45 ..."
   */
  function generateDayTransactionSummary(day) {
    // Get all transactions for this day across all categories
    const dayTransactions = _transactions.filter(tx => {
      if (!tx.date) return false;
      
      const txDay = tx.date.getDate();
      const txMonth = tx.date.getMonth();
      const txYear = tx.date.getFullYear();
      
      return txDay === day && txMonth === _currentMonth && txYear === _currentYear;
    });
    
    if (dayTransactions.length === 0) {
      return '';
    }
    
    // Create summary items with name and amount
    const summaryItems = dayTransactions.map(tx => {
      const name = tx.description || tx.name || 'Expense';
      const amount = formatCurrency(tx.amount);
      return `${name} ${amount}`;
    });
    
    // Join with commas
    const fullSummary = summaryItems.join(', ');
    
    // Truncate if too long (keep around 50 characters)
    const maxLength = 50;
    if (fullSummary.length > maxLength) {
      // Find the last complete item that fits within the limit
      let truncated = '';
      let totalLength = 0;
      
      for (let i = 0; i < summaryItems.length; i++) {
        const testLength = truncated ? 
          truncated.length + 2 + summaryItems[i].length : // +2 for ", "
          summaryItems[i].length;
          
        if (testLength <= maxLength - 4) { // -4 for " ..."
          truncated = truncated ? truncated + ', ' + summaryItems[i] : summaryItems[i];
        } else {
          break;
        }
      }
      
      return truncated + ' ...';
    }
    
    return fullSummary;
  }

  /**
   * Parse date string - handles both ISO strings and "DD MMM YYYY" format
   * Returns a Date object or null if parsing fails
   */
  function parseSpreadsheetDate(dateString) {
    if (!dateString) {
      return null;
    }
    
    // If it's already a Date object, return it
    if (dateString instanceof Date) {
      return dateString;
    }
    
    // Convert to string if not already
    const dateStr = dateString.toString().trim();
    
    // Check if it's an ISO string (from server API)
    if (dateStr.includes('T') && (dateStr.includes('Z') || dateStr.includes('+'))) {
      const date = new Date(dateStr);
      if (!isNaN(date.getTime())) {
        return date;
      }
    }
    
    // Try "DD MMM YYYY" format
    const parts = dateStr.split(/\s+/);
    if (parts.length === 3) {
      const [dayStr, monthStr, yearStr] = parts;
      
      // Parse day
      const day = parseInt(dayStr);
      if (isNaN(day) || day < 1 || day > 31) {
        console.warn('Invalid day in date:', dateStr);
        return null;
      }
      
      // Parse year
      const year = parseInt(yearStr);
      if (isNaN(year) || year < 1900 || year > 2100) {
        console.warn('Invalid year in date:', dateStr);
        return null;
      }
      
      // Parse month (convert month abbreviation to 0-based index)
      const monthMap = {
        'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
        'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
      };
      
      const month = monthMap[monthStr];
      if (month === undefined) {
        console.warn('Invalid month in date:', dateStr);
        return null;
      }
      
      // Create date using local timezone to avoid timezone shifts
      const date = new Date(year, month, day, 12, 0, 0, 0); // Set to noon to avoid DST issues
      
      // Verify the date is valid (handles cases like Feb 30)
      if (date.getDate() !== day || date.getMonth() !== month || date.getFullYear() !== year) {
        console.warn('Date components changed during creation, invalid date:', dateStr);
        return null;
      }
      
      return date;
    }
    
    const fallbackDate = new Date(dateStr);
    if (!isNaN(fallbackDate.getTime())) {
      return fallbackDate;
    }
    
    console.warn('All parsing methods failed for:', dateStr);
    return null;
  }

/**
 * Process real expense data from spreadsheet (expenses only, no categories)
 * Now properly preserves transaction IDs from server
 */
function processRealExpenseData(expenses) {
  const processedTransactions = [];

  // Process each expense
  expenses.forEach((expense, index) => {
    // Skip empty rows
    if (!expense.category || !expense.amount) {
      console.log('Skipping expense', index, '- missing category or amount:', expense);
      return;
    }
    
    // Parse date - ENHANCED with robust parsing
    let expenseDate;
    
    if (expense.date instanceof Date) {
      expenseDate = expense.date;
    } else if (expense.date) {
      // Try our custom parser first
      expenseDate = parseSpreadsheetDate(expense.date);
      
      if (!expenseDate) {
        // Fallback to standard Date parsing
        expenseDate = new Date(expense.date);
        
        if (isNaN(expenseDate.getTime())) {
          console.warn(`Expense ${index}: Both parsing methods failed for date:`, expense.date);
          return;
        }
      }
      
    } else {
      console.warn('No date for expense', index, ':', expense);
      return;
    }
    
    // Parse amount
    const amount = parseFloat(expense.amount);
    if (isNaN(amount) || amount <= 0) {
      console.warn('Invalid amount for expense', index, ':', expense);
      return;
    }
    
    // Parse category to get clean name (remove emoji)
    const parsed = parseCategoryNameAndEmoji(expense.category.trim());
    const cleanCategory = parsed.name; // Use only the name part for matching
    
    // IMPORTANT: Use the transaction ID from server if available, otherwise generate one
    // This ensures transaction IDs are preserved when updating
    const transactionId = expense.transactionId || expense.rowIndex || `tx-real-${index}`;
    
    // Ensure the ID follows the standard format 'tx-timestamp-random'
    const formattedId = transactionId.toString().startsWith('tx-') 
      ? transactionId 
      : `tx-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
    
    // Create transaction object, now including the label field and preserving transaction ID
    const transaction = {
      id: formattedId, // IMPORTANT: Use formatted transaction ID
      date: expenseDate,
      category: cleanCategory,  // Store clean category name for matching with active categories
      amount: amount,
      description: expense.name || expense.description || '',
      account: expense.account || 'Main Account',
      notes: expense.notes || '',
      label: expense.label || '', // Store the label field to identify subscriptions/fixed payments
      originalTransactionId: transactionId // Store original for debugging
    };
    
    processedTransactions.push(transaction);
    
  });
  
  // Store processed transactions (categories are loaded separately)
  _transactions = processedTransactions;
    addInactiveCategoriesWithSpending();

  _transactions.slice(0, 5).forEach(tx => {
  });
}
  
  /**
   * Show loading indicator with current month info
   */
  function showLoadingIndicator() {
    const container = getElement('monthly-grid-container');
    if (container) {
      const monthName = new Date(_currentYear, _currentMonth, 1)
        .toLocaleString('default', { month: 'long' });
      
      container.innerHTML = `
        <div class="loading-indicator">
          <div class="loading-spinner"></div>
          <p>Loading ${monthName} ${_currentYear} expenses...</p>
          <p><small>Reading month-specific data from spreadsheet</small></p>
        </div>
      `;
    }
  }
  
  /**
   * Hide loading indicator
   */
  function hideLoadingIndicator() {
    const loadingEl = document.querySelector('.loading-indicator');
    if (loadingEl) {
      loadingEl.remove();
    }
  }
  
  /**
   * Show error message
   */
  function showErrorMessage(message) {
    const container = getElement('monthly-grid-container');
    if (container) {
      container.innerHTML = `
        <div class="grid-error">
          <h3>❌ Failed to Load Data</h3>
          <p><strong>Error:</strong> ${message}</p>
          <p><strong>Expected:</strong> Reading from spreadsheet with expense data</p>
          <button class="retry-btn" onclick="MonthlyGrid.refresh()">Retry</button>
          <hr>
          <details>
            <summary>Debugging Info</summary>
            <p><strong>Check Code.gs:</strong> Make sure getExpenseData() function exists</p>
            <p><strong>Check API.html:</strong> Make sure API.getExpenseData() function exists</p>
            <p><strong>Check Logs:</strong> Open Apps Script editor → Executions tab</p>
            <p><strong>Check Sheet:</strong> Verify spreadsheet has expense data in correct format</p>
          </details>
        </div>
      `;
    }
  }
  


/**
 * Update currency symbol and refresh display
 */
function updateCurrency() {
  loadCurrencyFromSettings();
  if (_initialized) {
    renderGrid(); // Re-render to show new currency
  }
}

  // Track modal states to prevent accidental popups
  let _isOpeningModal = false;
  let _isClosingModal = false;
  
  function bindEvents() {
    // Month navigation - DON'T replace elements, just remove/add listeners properly
    const prevMonth = document.getElementById('prevMonth');
    const nextMonth = document.getElementById('nextMonth');
    
    if (prevMonth) {
      // Remove existing MonthlyGrid listeners (if any)
      prevMonth.removeEventListener('click', prevMonth._monthlyGridHandler);
      
      // Add our handler and store reference for future removal
      prevMonth._monthlyGridHandler = function(e) {
        e.preventDefault();
        e.stopPropagation();
        navigateMonth(-1);
      };
      
      prevMonth.addEventListener('click', prevMonth._monthlyGridHandler);
    } else {
      console.error('prevMonth button not found in DOM');
    }
    
    if (nextMonth) {
      // Remove existing MonthlyGrid listeners (if any)
      nextMonth.removeEventListener('click', nextMonth._monthlyGridHandler);
      
      // Add our handler and store reference for future removal
      nextMonth._monthlyGridHandler = function(e) {
        e.preventDefault();
        e.stopPropagation();
        navigateMonth(1);
      };
      
      nextMonth.addEventListener('click', nextMonth._monthlyGridHandler);
    } else {
      console.error('nextMonth button not found in DOM');
    }
    

    const refreshExpenses = document.getElementById('refreshExpenses');
if (refreshExpenses) {
  // Remove any existing listeners first
  if (refreshExpenses._monthlyGridHandler) {
    refreshExpenses.removeEventListener('click', refreshExpenses._monthlyGridHandler);
  }
  
  // Create a new handler that does aggressive cache clearing
  refreshExpenses._monthlyGridHandler = function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // Reset session tracking (from your index.html)
    sessionStorage.removeItem('monthlyGrid_sessionActive');
    
    // Signal fresh data needed (from your index.html)
    window.FORCE_FRESH_DATA = true;
    
    // Clear BOTH in-memory and localStorage cache
    clearCache();
    
    // Force a complete refresh
    refresh();
  };
  
  // Add the new handler
  refreshExpenses.addEventListener('click', refreshExpenses._monthlyGridHandler);
} else {
  console.warn('Refresh expenses button not found in DOM - make sure to add it to Index.html');
}
    
    // Cell click handlers (using event delegation)
    const gridContainer = getElement('monthly-grid-container');
    if (gridContainer) {
      gridContainer.addEventListener('click', function(e) {
        if (_isClosingModal) return;
        
        const cell = e.target.closest('.grid-cell[data-day][data-category]');
        if (cell) {
          e.stopPropagation();
          
          const day = cell.getAttribute('data-day');
          const category = cell.getAttribute('data-category');
          
          _isOpeningModal = true;
          openTransactionModal(day, category);
          
          setTimeout(() => {
            _isOpeningModal = false;
          }, 300);
        }
      });
    }
    
    // Remove existing event listeners first to prevent duplicates
    document.removeEventListener('click', handleDocumentClick);
    document.removeEventListener('touchend', handleTouchEnd);
    
    // Add event listeners
    document.addEventListener('click', handleDocumentClick);
    document.addEventListener('touchend', handleTouchEnd);
  }
  
  /**
   * Clean up event listeners when MonthlyGrid is destroyed/reinitialized
   */
  function unbindEvents() {
    const prevMonth = document.getElementById('prevMonth');
    const nextMonth = document.getElementById('nextMonth');
    const refreshExpenses = document.getElementById('refreshExpenses');
    
    if (prevMonth && prevMonth._monthlyGridHandler) {
      prevMonth.removeEventListener('click', prevMonth._monthlyGridHandler);
      prevMonth._monthlyGridHandler = null;
    }
    
    if (nextMonth && nextMonth._monthlyGridHandler) {
      nextMonth.removeEventListener('click', nextMonth._monthlyGridHandler);
      nextMonth._monthlyGridHandler = null;
    }
    
    if (refreshExpenses && refreshExpenses._monthlyGridHandler) {
      refreshExpenses.removeEventListener('click', refreshExpenses._monthlyGridHandler);
      refreshExpenses._monthlyGridHandler = null;
    }
  }
  
  function handleDocumentClick(e) {
    if (_isOpeningModal || _isClosingModal) return;
    
    const modal = getElement('transaction-modal');
    if (!modal) return;
    
    const modalCard = modal.querySelector('.modal-card');
    const addBtn = getElement('add-transaction-btn');
    
    if (addBtn && (e.target === addBtn || addBtn.contains(e.target))) {
      e.preventDefault();
      e.stopPropagation();
      addTransactionRow();
      return;
    }
    
    if (modal.classList.contains('visible')) {
      if (e.target === modal || 
          (e.target !== modalCard && !modalCard.contains(e.target))) {
        e.preventDefault();
        e.stopPropagation();
        closeTransactionModal();
        return;
      }
    }
  }
  
  function handleTouchEnd(e) {
    if (_isOpeningModal || _isClosingModal) return;
    
    const modal = getElement('transaction-modal');
    if (!modal || !modal.classList.contains('visible')) return;
    
    const modalCard = modal.querySelector('.modal-card');
    if (modalCard && !modalCard.contains(e.target) && e.target !== modalCard) {
      e.preventDefault();
      e.stopPropagation();
      closeTransactionModal();
    }
  }
  

  /**
 * Get next month/year
 */
function getNextMonth(month, year) {
  let nextMonth = month + 1;
  let nextYear = year;
  
  if (nextMonth > 11) {
    nextMonth = 0;
    nextYear = year + 1;
  }
  
  return { month: nextMonth, year: nextYear };
}


  /**
   * ENHANCED: Navigate month with smart caching
   */
  function navigateMonth(change) {
  // Prevent navigation while loading
  if (_isLoading) {
    console.log('Navigation blocked - already loading data');
    return;
  }
  
  _currentMonth += change;
  
  if (_currentMonth > 11) {
    _currentMonth = 0;
    _currentYear++;
  } else if (_currentMonth < 0) {
    _currentMonth = 11;
    _currentYear--;
  }
  
  updateMonthYearDisplay();
  
  loadRealExpenseData(_currentMonth, _currentYear);
}
  
  function updateMonthYearDisplay() {
    const monthYearDisplay = getElement('monthYearDisplay');
    if (monthYearDisplay) {
      const monthName = new Date(_currentYear, _currentMonth, 1)
        .toLocaleString('default', { month: 'long' });
      
      
      monthYearDisplay.textContent = `${monthName} ${_currentYear}`;
    }
  }
  
  function renderGrid() {
    const container = getElement('monthly-grid-container');
    if (!container) {
      console.error("Grid container not found for rendering");
      return;
    }
    
    // Clear existing content
    container.innerHTML = '';
    
    // Get days in month
    const daysInMonth = new Date(_currentYear, _currentMonth + 1, 0).getDate();
    
    // Update month/year display
    updateMonthYearDisplay();
    
    // Categories are already parsed in _categories, just use them directly
    const categoriesToDisplay = _categories;
    
    if (categoriesToDisplay.length === 0) {
      container.innerHTML = `
        <div class="grid-error">
          <h3>No Categories Found</h3>
          <p>No expense categories found in your data for the current month.</p>
          <button class="retry-btn" onclick="MonthlyGrid.refresh()">Refresh</button>
        </div>
      `;
      return;
    }
    
    // Create table for grid
    const table = document.createElement('table');
    table.className = 'monthly-grid';
    
    // Add header with categories
    const thead = createTableHeader(categoriesToDisplay, daysInMonth);
    table.appendChild(thead);
    
    // Create rows for each day
    const tbody = createTableBody(categoriesToDisplay, daysInMonth);
    table.appendChild(tbody);
    
    // Add table to container
    container.appendChild(table);
    
    // Add the modal HTML after rendering the grid
    ensureModalExists();
  }
  
  function getTransactionsForDayAndCategory(day, categoryId) {
    // Convert categoryId to match the actual category names from data
    const transactions = _transactions.filter(tx => {
      if (!tx.date || !tx.category) return false;
      
      // Check if the day matches
      const txDay = tx.date.getDate();
      const txMonth = tx.date.getMonth();
      const txYear = tx.date.getFullYear();
      
      // Must be same day, month, and year
      const dayMatches = (txDay === day);
      const monthMatches = (txMonth === _currentMonth);
      const yearMatches = (txYear === _currentYear);
      
      // Fix category matching - categoryId might be slugified, but tx.category is the full name
      const categoryMatches = (
        tx.category === categoryId || 
        tx.category.toLowerCase().replace(/[^a-z0-9]/g, '') === categoryId ||
        categoryId === tx.category.toLowerCase().replace(/[^a-z0-9]/g, '')
      );
      
      const matches = dayMatches && monthMatches && yearMatches && categoryMatches;
      
 
      
      return matches;
    });
    
    return transactions;
  }
  
  function getMonthTotalForCategory(categoryId) {
    return _transactions
      .filter(tx => 
        tx.category === categoryId && 
        tx.date.getMonth() === _currentMonth &&
        tx.date.getFullYear() === _currentYear
      )
      .reduce((sum, tx) => sum + tx.amount, 0);
  }
  
  function getMonthGrandTotal() {
    return _transactions
      .filter(tx => 
        tx.date.getMonth() === _currentMonth &&
        tx.date.getFullYear() === _currentYear
      )
      .reduce((sum, tx) => sum + tx.amount, 0);
  }

  function ensureModalExists() {
    let modal = getElement('transaction-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'transaction-modal';
      modal.className = 'transaction-modal';
      modal.innerHTML = `
        <div class="modal-backdrop"></div>
        <div class="modal-card">
          <div class="modal-header">
            <h3 id="modal-title" class="modal-title">Transactions</h3>
          </div>
          
          <div class="modal-content">
            <div id="transactions-list" class="transactions-list">
              <!-- Transactions will be populated here -->
            </div>
            
            <div class="modal-actions">
              <button id="add-transaction-btn" class="add-transaction-btn">
                <i class="material-icons">add</i> Add More
              </button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      _elements['transaction-modal'] = modal;
      _elements['modal-title'] = modal.querySelector('#modal-title');
      _elements['transactions-list'] = modal.querySelector('#transactions-list');
      _elements['add-transaction-btn'] = modal.querySelector('#add-transaction-btn');
    }
  }

  function createTableHeader(categories, daysInMonth) {
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    // Date column header
    const dateHeader = document.createElement('th');
    dateHeader.className = 'date-header';
    dateHeader.textContent = 'Date';
    headerRow.appendChild(dateHeader);
    
    // Category headers with monthly totals - FIXED EMOJI DUPLICATION
    categories.forEach(category => {
      const categoryHeader = document.createElement('th');
      categoryHeader.className = 'category-header';
      categoryHeader.setAttribute('data-category', category.id);
      categoryHeader.title = `${category.emoji} ${category.name}`;
      
      // Calculate monthly total for this category
      const monthlyTotal = getMonthTotalForCategory(category.id);
      
      // Create header content with emoji on top line, name on bottom (desktop only)
      const headerContent = document.createElement('div');
      headerContent.className = 'category-header-content';
      
      const categoryEmoji = document.createElement('div');
      categoryEmoji.className = 'category-emoji';
      categoryEmoji.textContent = category.emoji; // ONLY the emoji, no name
      
      const categoryName = document.createElement('div');
      categoryName.className = 'category-name';
      categoryName.textContent = category.name; // ONLY the clean name, no emoji
      
      const categoryTotal = document.createElement('div');
      categoryTotal.className = 'category-total';
      categoryTotal.textContent = formatCurrency(monthlyTotal);
      
      headerContent.appendChild(categoryEmoji);
      headerContent.appendChild(categoryName);
      headerContent.appendChild(categoryTotal);
      categoryHeader.appendChild(headerContent);
      
      headerRow.appendChild(categoryHeader);
    });
    
    // Daily total header
    const totalHeader = document.createElement('th');
    totalHeader.className = 'total-header';
    totalHeader.title = 'Daily Total';
    
    // Calculate monthly grand total
    const grandTotal = getMonthGrandTotal();
    
    const totalHeaderContent = document.createElement('div');
    totalHeaderContent.className = 'category-header-content';
    
    const totalEmoji = document.createElement('div');
    totalEmoji.className = 'category-emoji';
    totalEmoji.textContent = '💰';
    
    const totalName = document.createElement('div');
    totalName.className = 'category-name total-label';
    totalName.textContent = 'Total';
    
    const totalValue = document.createElement('div');
    totalValue.className = 'category-total';
    totalValue.textContent = formatCurrency(grandTotal);
    
    totalHeaderContent.appendChild(totalEmoji);
    totalHeaderContent.appendChild(totalName);
    totalHeaderContent.appendChild(totalValue);
    totalHeader.appendChild(totalHeaderContent);
    
    headerRow.appendChild(totalHeader);
    
    // Notes header
    const notesHeader = document.createElement('th');
    notesHeader.className = 'notes-header';
    notesHeader.title = 'Notes';
    
    const notesHeaderContent = document.createElement('div');
    notesHeaderContent.className = 'category-header-content';
    
    const notesEmoji = document.createElement('div');
    notesEmoji.className = 'category-emoji';
    notesEmoji.textContent = '📝';
    
    const notesName = document.createElement('div');
    notesName.className = 'category-name';
    notesName.textContent = 'Notes';
    
    notesHeaderContent.appendChild(notesEmoji);
    notesHeaderContent.appendChild(notesName);
    notesHeader.appendChild(notesHeaderContent);
    
    headerRow.appendChild(notesHeader);
    
    thead.appendChild(headerRow);
    return thead;
  }
  
  function createTableBody(categories, daysInMonth) {
    const tbody = document.createElement('tbody');
    
    // Get today's date for highlighting
    const today = new Date();
    const isCurrentMonth = today.getMonth() === _currentMonth && today.getFullYear() === _currentYear;
    const currentDay = today.getDate();
    
    // Create a row for each day
    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(_currentYear, _currentMonth, day);
      const dayOfWeek = dateObj.getDay();
      
      const isWeekend = (dayOfWeek === 0);
      const isToday = isCurrentMonth && day === currentDay;
        
      const row = document.createElement('tr');
      row.className = 'day-row';
      
      if (isWeekend) {
        row.classList.add('weekend-row');
      }
      
      if (isToday) {
        row.classList.add('today-row');
      }
      
      // Date cell
      const dateCell = document.createElement('td');
      dateCell.className = 'date-cell';
      if (isWeekend) dateCell.classList.add('weekend-cell');
      if (isToday) dateCell.classList.add('today-cell');
      
      const dayName = dateObj.toLocaleString('en-US', { weekday: 'short' });
      
      dateCell.innerHTML = `<div class="date-container">
                              <span class="day-number">${day}</span>
                              <span class="day-name">${dayName}</span>
                            </div>`;
      row.appendChild(dateCell);
      
      // Daily total for calculating at the end
      let dayTotal = 0;
      
      // Category cells
      categories.forEach(category => {
        const cell = document.createElement('td');
        cell.className = 'grid-cell';
        if (isWeekend) cell.classList.add('weekend-cell');
        if (isToday) cell.classList.add('today-cell');
        cell.setAttribute('data-day', day);
        cell.setAttribute('data-category', category.id);
        
        // Get transactions for this day and category
        const dayTransactions = getTransactionsForDayAndCategory(day, category.id);
        
        // If there are transactions, show amount and count
        if (dayTransactions.length > 0) {
          const amount = dayTransactions.reduce((sum, tx) => sum + tx.amount, 0);
          dayTotal += amount;
          
          // Check if any transaction is recurring/subscription
          const hasRecurring = dayTransactions.some(tx => 
            tx.label && (
              tx.label.toLowerCase().includes('subscription') || 
              tx.label.toLowerCase().includes('fixed payment')
            )
          );
          
          // Determine color based on amount ranges
          let colorClass = 'amount-large';
          if (amount <= 30) {
            colorClass = 'amount-small';
          } else if (amount <= 75) {
            colorClass = 'amount-medium';
          }
          
          cell.innerHTML = `<div class="cell-content ${colorClass} ${hasRecurring ? 'recurring' : ''}"><span class="amount">${formatCurrency(amount)}</span><span class="transaction-count">(${dayTransactions.length})</span></div>`;
        }
        
        row.appendChild(cell);
      });
      
      // Daily total cell
      const totalCell = document.createElement('td');
      totalCell.className = 'total-cell';
      if (isWeekend) totalCell.classList.add('weekend-cell');
      if (isToday) totalCell.classList.add('today-cell');
      
      if (dayTotal > 0) {
        totalCell.innerHTML = `<div class="total-amount">${formatCurrency(dayTotal)}</div>`;
      }
      
      row.appendChild(totalCell);
      
      // Notes cell - now shows auto-generated transaction summary
      const notesCell = document.createElement('td');
      notesCell.className = 'notes-cell';
      if (isWeekend) notesCell.classList.add('weekend-cell');
      if (isToday) notesCell.classList.add('today-cell');
      
      // Generate transaction summary for this day
      const transactionSummary = generateDayTransactionSummary(day);
      
      // Create notes content div with click handler
      const notesContent = document.createElement('div');
      notesContent.className = 'notes-content';
      notesContent.textContent = transactionSummary;
      notesContent.setAttribute('data-day', day);
      
      // Add click handler for day details popup
      notesContent.addEventListener('click', function(e) {
        e.stopPropagation();
        showDayDetailsPopup(day);
      });
      
      // Add title attribute for full summary on hover if truncated
      if (transactionSummary.includes(' ...')) {
        // Get the full summary for tooltip
        const allDayTransactions = _transactions.filter(tx => {
          if (!tx.date) return false;
          const txDay = tx.date.getDate();
          const txMonth = tx.date.getMonth();
          const txYear = tx.date.getFullYear();
          return txDay === day && txMonth === _currentMonth && txYear === _currentYear;
        });
        
        const fullSummary = allDayTransactions.map(tx => {
          const name = tx.description || tx.name || 'Expense';
          const amount = formatCurrency(tx.amount);
          return `${name} ${amount}`;
        }).join(', ');
        
        notesContent.title = fullSummary;
        notesContent.style.cursor = 'help';
      }
      
      notesCell.appendChild(notesContent);
      row.appendChild(notesCell);
      
      tbody.appendChild(row);
    }
    
    return tbody;
  }

  /**
   * ENHANCED: Open transaction modal with blazing fast entry
   * Always shows an empty transaction row for quick entry
   */
  function openTransactionModal(day, categoryId) {
    if (_isClosingModal) return;
    
    
    ensureModalExists();
    
    const modal = getElement('transaction-modal');
    if (!modal) {
      console.error('Modal element not found in DOM');
      return;
    }
    
    // FIXED: Now _categories contains parsed categories with id property
    const category = _categories.find(c => c.id === categoryId);
    if (!category) {
      console.error('Category not found:', categoryId);
      return;
    }
    
    const transactions = getTransactionsForDayAndCategory(parseInt(day), categoryId);
    
    const dateObj = new Date(_currentYear, _currentMonth, parseInt(day));
    const formattedDate = dateObj.toLocaleDateString('en-US', { 
      weekday: 'short', 
      month: 'short', 
      day: 'numeric'
    });
    
    const total = transactions.reduce((sum, tx) => sum + tx.amount, 0);
    
    const modalTitle = getElement('modal-title');
    if (modalTitle) {
      modalTitle.innerHTML = `
        <div class="integrated-title">
          <span class="title-category">${category.emoji} ${category.name}</span>
          <span class="title-divider">|</span>
          <span class="title-date">${formattedDate}</span>
          ${total > 0 ? `<span class="title-divider">|</span><span class="title-total">Total: ${formatCurrency(total, 2)}</span>` : ''}
        </div>
      `;
    }
    
    const transactionsList = getElement('transactions-list');
    if (transactionsList) {
      transactionsList.innerHTML = '';
      
      // First, add existing transactions if any
      if (transactions.length > 0) {
        transactions.forEach(tx => {
          const item = createTransactionItem(tx);
          transactionsList.appendChild(item);
        });
      }
      
      // ALWAYS add an empty transaction row for quick entry
      const emptyTransaction = createEmptyTransaction(day, categoryId);
      const emptyItem = createTransactionItem(emptyTransaction);
      emptyItem.classList.add('new-transaction', 'ready-for-input');
      transactionsList.appendChild(emptyItem);
      
      // Auto-focus the description field for natural workflow
      setTimeout(() => {
        const descriptionField = emptyItem.querySelector('.transaction-description');
        if (descriptionField) {
          descriptionField.focus();
          descriptionField.select();
        }
      }, 100);
    }
    
    modal.setAttribute('data-day', day);
    modal.setAttribute('data-category', categoryId);
    
    document.addEventListener('keydown', handleEscKey);
    
    setTimeout(() => {
      modal.classList.add('visible');
    }, 10);
  }
  
  /**
   * Create an empty transaction object for quick entry
   */
  function createEmptyTransaction(day, categoryId) {
    const newId = `tx-new-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
    
    return {
      id: newId,
      date: new Date(_currentYear, _currentMonth, parseInt(day)),
      category: categoryId,
      amount: 0,
      description: '',
      account: 'Main Account',
      notes: ''
    };
  }
  
  /**
 * Create a transaction item in the modal - REORDERED FIELDS: description, amount, account
 */
function createTransactionItem(tx) {
  const item = document.createElement('div');
  item.className = 'transaction-item';
  item.setAttribute('data-id', tx.id);
  
  // Check if this is a subscription or fixed payment
  const isSpecialTransaction = tx.label && 
    (tx.label.toLowerCase().includes('subscription') || 
     tx.label.toLowerCase().includes('fixed payment'));
  
  if (isSpecialTransaction) {
    item.classList.add('fixed-transaction');
  }
  
  // Use placeholders instead of default values for better UX
  const amountValue = tx.amount && tx.amount > 0 ? tx.amount : '';
  const amountPlaceholder = _currencySymbol;
  const descriptionValue = tx.description || '';
  const descriptionPlaceholder = 'Expense name';
  
  // Create HTML structure - REORDERED: description first, then amount, then account
  const row = document.createElement('div');
  row.className = 'transaction-row';
  
  // 1. Description field FIRST (most natural to enter)
  const descriptionContainer = document.createElement('div');
  descriptionContainer.style.display = 'flex';
  descriptionContainer.style.alignItems = 'center';
  descriptionContainer.style.width = '100%';
  
  const descriptionInput = document.createElement('input');
  descriptionInput.type = 'text';
  descriptionInput.className = 'transaction-description';
  descriptionInput.value = descriptionValue;
  descriptionInput.placeholder = descriptionPlaceholder;
  descriptionInput.style.width = '100%';
  
  descriptionContainer.appendChild(descriptionInput);
  
  // Add recurring icon for special transactions
  if (isSpecialTransaction) {
    const recurringIcon = document.createElement('span');
    recurringIcon.className = 'recurring-icon';
    recurringIcon.innerHTML = '<i class="material-icons">repeat</i>';
    descriptionContainer.appendChild(recurringIcon);
    
    // Make inputs readonly
    descriptionInput.setAttribute('readonly', 'readonly');
  }
  
  // 2. Amount field SECOND
  const amountInput = document.createElement('input');
  amountInput.type = 'number';
  amountInput.className = 'transaction-amount';
  amountInput.value = amountValue;
  amountInput.placeholder = amountPlaceholder;
  amountInput.min = '0';
  amountInput.step = '0.01';
  
  if (isSpecialTransaction) {
    amountInput.setAttribute('readonly', 'readonly');
  }
  
  // Add the reordered inputs to the row: description, amount
  row.appendChild(descriptionContainer);
  row.appendChild(amountInput);
  
  // 3. Account dropdown and actions for regular transactions
  if (!isSpecialTransaction) {
    // Account dropdown
    const accountSelect = document.createElement('select');
    accountSelect.className = 'transaction-account';
    
    // Create options
    const options = [
      { value: 'Main Account', text: 'Main Account' },
      { value: 'Credit Card', text: 'Credit Card' },
      { value: 'Savings', text: 'Savings' }
    ];
    
    options.forEach(option => {
      const optionEl = document.createElement('option');
      optionEl.value = option.value;
      optionEl.textContent = option.text;
      if (option.value === tx.account) {
        optionEl.selected = true;
      }
      accountSelect.appendChild(optionEl);
    });
    
    row.appendChild(accountSelect);
    
    // Delete button
    const actions = document.createElement('div');
    actions.className = 'transaction-actions';
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'transaction-delete';
    deleteBtn.innerHTML = '<i class="material-icons">close</i>';
    
    actions.appendChild(deleteBtn);
    row.appendChild(actions);
  } else {
    // For special transactions, just a blank div to maintain grid layout
    const spacer = document.createElement('div');
    row.appendChild(spacer);
  }
  
  // Add the row to the item
  item.appendChild(row);
  
  // Only set up event handlers for non-special transactions
  if (!isSpecialTransaction) {
    setupTransactionItemEvents(item, tx);
  }
  
  return item;
}


/**
 * Setup event handlers for transaction items
 * Modified to use TransactionManager
 */
function setupTransactionItemEvents(item, tx) {
const deleteBtn = item.querySelector('.transaction-delete');
if (deleteBtn) {
  deleteBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    
    // Remove from UI immediately for better UX
    item.remove();
    
    // Use our clearing function instead of deletion
    if (tx.id) {
      clearTransactionById(tx.id, true);
    }
    
    // Update transaction total in modal
    updateTransactionTotal();
  });
}
    
      const amountInput = item.querySelector('.transaction-amount');
      const descriptionInput = item.querySelector('.transaction-description');
      const accountSelect = item.querySelector('.transaction-account');
      
        // In MonthlyGrid.js - look for the updateTransactionQueue function inside setupTransactionItemEvents
        // This function is called when a transaction is updated or added



    // WITH THIS UPDATED VERSION:
    function updateTransactionQueue() {
      // Only queue transactions with valid amounts
      if (parseFloat(amountInput.value) > 0) {
        // Get the category emoji
        let categoryEmoji = '';
        if (window.getCategoryEmoji) {
          categoryEmoji = getCategoryEmoji(tx.category);
        } else {
          // Fallback: Try to find the category in the categories array
          const category = _categories.find(c => c.id === tx.category);
          if (category && category.emoji) {
            categoryEmoji = category.emoji;
          }
        }
    
    // Create transaction for queue
    const transaction = {
      id: tx.id,
      date: tx.date,
      amount: parseFloat(amountInput.value) || 0,
      category: tx.category,
      description: descriptionInput.value,
      account: accountSelect ? accountSelect.value : 'Main Account',
      notes: tx.notes || '',
      emoji: categoryEmoji
    };
    
    // Update the transaction in our local array
    tx.amount = transaction.amount;
    tx.description = transaction.description;
    if (accountSelect) {
      tx.account = transaction.account;
    }
    
    // Add/update in TransactionManager's queue
    if (window.TransactionManager) {
      // Check if this transaction is already in the queue
      const existingTx = TransactionManager.getQueue().find(qTx => qTx.id === transaction.id);
      
      if (existingTx) {
        TransactionManager.updateTransaction(transaction);
      } else {
        TransactionManager.addTransaction(transaction);
      }
    }
    
    // Check if this transaction is already in our local array
    const existingIndex = _transactions.findIndex(t => t.id === tx.id);
    if (existingIndex === -1) {
      // Add to local transactions array for immediate UI update
      _transactions.push(tx);
    } else {
      // Update the existing transaction
      _transactions[existingIndex] = tx;
    }
    
    // CRITICAL FIX: Update the cache with the updated transactions array
    // This ensures the transaction persists when switching months/categories
    const key = getCacheKey(_currentMonth, _currentYear);
    
    // Get currently cached expenses for this month
    let cachedExpenses = getCachedExpenses(_currentMonth, _currentYear) || [];
    
    // Check if this transaction already exists in cache
    const cachedIndex = cachedExpenses.findIndex(e => e.rowIndex === tx.id || e.id === tx.id);
    
    if (cachedIndex >= 0) {
      // Update existing transaction in cache
      cachedExpenses[cachedIndex] = {
        ...cachedExpenses[cachedIndex],
        amount: transaction.amount,
        name: transaction.description,
        description: transaction.description,
        account: transaction.account,
        notes: transaction.notes
      };
    } else {
      // Add new transaction to cache
      cachedExpenses.push({
        rowIndex: tx.id,
        id: tx.id,
        date: tx.date,
        category: tx.category,
        amount: transaction.amount,
        name: transaction.description,
        description: transaction.description,
        account: transaction.account,
        notes: transaction.notes
      });
    }
    
    // Update cache with modified expenses
    setCachedExpenses(_currentMonth, _currentYear, cachedExpenses);
  }
}
   item._updateTransactionQueue = updateTransactionQueue;

   if (amountInput) {
    // Update when amount changes
    amountInput.addEventListener('input', function() {
      tx.amount = parseFloat(this.value) || 0;
      updateTransactionTotal();
    });
  }
  
  if (descriptionInput) {
    // Update transaction when description changes
    descriptionInput.addEventListener('input', function() {
      tx.description = this.value;
    });
    
    // Move to amount field when Enter is pressed on description
    descriptionInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (amountInput) {
          amountInput.focus();
          amountInput.select();
        }
      }
    });
    
    // Queue for saving when description is complete (on blur)
    descriptionInput.addEventListener('blur', function() {
      if (parseFloat(amountInput.value) > 0 && this.value.trim()) {
        updateTransactionQueue();
      }
    });
  }
  
  if (amountInput) {
    // Move to account field when Enter is pressed on amount
    amountInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (accountSelect) {
          accountSelect.focus();
        }
      }
    });
    
    // Queue for saving when amount is complete (on blur)
    amountInput.addEventListener('blur', function() {
      if (parseFloat(this.value) > 0 && descriptionInput.value.trim()) {
        updateTransactionQueue();
      }
    });
  }
  
 if (accountSelect) {
  // Update transaction data in memory only (don't save)
  accountSelect.addEventListener('change', function() {
    tx.account = this.value;
    // Auto-save when account is selected and other fields are filled
    if (parseFloat(amountInput.value) > 0 && descriptionInput.value.trim()) {
      updateTransactionQueue();
    }
  });
}
}
  
  function updateTransactionTotal() {
    const transactionsList = getElement('transactions-list');
    const modalTitle = getElement('modal-title');
    if (!transactionsList || !modalTitle) return;
    
    const amounts = Array.from(transactionsList.querySelectorAll('.transaction-amount'))
      .map(input => parseFloat(input.value) || 0);
    
    const total = amounts.reduce((sum, amount) => sum + amount, 0);
    
    const titleTotal = modalTitle.querySelector('.title-total');
    if (titleTotal) {
      titleTotal.textContent = `Total: ${formatCurrency(total, 2)}`;
    } else if (total > 0) {
      const titleContent = modalTitle.querySelector('.integrated-title');
      if (titleContent) {
        const divider = document.createElement('span');
        divider.className = 'title-divider';
        divider.textContent = '|';
        
        const newTotal = document.createElement('span');
        newTotal.className = 'title-total';
        newTotal.textContent = `Total: ${formatCurrency(total, 2)}`;
        
        titleContent.appendChild(divider);
        titleContent.appendChild(newTotal);
      }
    }
  }
  
  function handleEscKey(e) {
    if (e.key === 'Escape') {
      closeTransactionModal();
    }
  }
  


  


/**
 * Close the transaction modal - with final transaction saving
 */
function closeTransactionModal() {
  _isClosingModal = true;
  
  const modal = getElement('transaction-modal');
  if (modal) {
    // Save all transactions before closing
    const transactionsList = getElement('transactions-list');
    if (transactionsList) {
      const items = transactionsList.querySelectorAll('.transaction-item');
      
      // Process each transaction - FIXED VERSION
      items.forEach(item => {
        const amountInput = item.querySelector('.transaction-amount');
        const descriptionInput = item.querySelector('.transaction-description');
        
        // Only save transactions with valid amounts AND descriptions
        if (amountInput && descriptionInput && 
            parseFloat(amountInput.value) > 0 && 
            descriptionInput.value.trim()) {
          // We need to trigger the save in the item's context
          if (item._updateTransactionQueue) {
            // Use the function stored on the item during setup
            item._updateTransactionQueue();
          }
        }
      });
    }
    
    // Hide modal
    modal.classList.remove('visible');
    document.removeEventListener('keydown', handleEscKey);
    
    // Process queue
    if (window.TransactionManager) {
      setTimeout(function() {
        TransactionManager.forceProcessing();
      }, 200);
    }
    
    renderGrid();
    
    setTimeout(() => {
      _isClosingModal = false;
    }, 300);
  }
}

  
/**
 * Add a new transaction row and force-save any existing transactions
 */
function addTransactionRow() {
  
  const transactionsList = getElement('transactions-list');
  const modal = getElement('transaction-modal');
  
  if (!transactionsList || !modal) {
    console.error('Required elements not found');
    return;
  }
  
  // Force save any existing transactions before adding new one
  const existingTransactions = transactionsList.querySelectorAll('.transaction-item');
  if (existingTransactions.length > 0) {
    const lastTransaction = existingTransactions[existingTransactions.length - 1];
    // Dispatch event to force-save the previous transaction
    lastTransaction.dispatchEvent(new CustomEvent('forceSave'));
  }
  
  const day = modal.getAttribute('data-day');
  const categoryId = modal.getAttribute('data-category');
  
  if (!day || !categoryId) {
    console.error('Missing day or category information');
    return;
  }
  
  // Create another empty transaction
  const newTx = createEmptyTransaction(day, categoryId);
  const item = createTransactionItem(newTx);
  item.classList.add('new-transaction');
  
  // Add to DOM
  transactionsList.appendChild(item);
  
  // Auto-focus the description field (new workflow)
  setTimeout(() => {
    const descriptionField = item.querySelector('.transaction-description');
    if (descriptionField) {
      descriptionField.focus();
    }
  }, 100);
  
  updateTransactionTotal();
}



/**
 * Clear a transaction by directly clearing the row in the spreadsheet
 */
function clearTransactionById(transactionId, skipRender) {
  if (!transactionId) return false;
  
  
  // Find transaction in _transactions array for UI updates
  const txIndex = _transactions.findIndex(tx => tx.id === transactionId);
  if (txIndex === -1) {
    console.warn('Transaction not found for clearing:', transactionId);
    return false;
  }
  
  // Remove from local transactions array for UI
  _transactions.splice(txIndex, 1);
  
  // Update the cache
  const key = getCacheKey(_currentMonth, _currentYear);
  let cachedExpenses = getCachedExpenses(_currentMonth, _currentYear) || [];
  const cachedIndex = cachedExpenses.findIndex(e => 
    e.rowIndex === transactionId || e.id === transactionId);
  
  if (cachedIndex >= 0) {
    cachedExpenses.splice(cachedIndex, 1);
    setCachedExpenses(_currentMonth, _currentYear, cachedExpenses);
  }
  
  // Use our new API function to clear the row on the server
  API.clearTransactionRow(transactionId, function(result) {
    
    // Re-render the grid unless specified not to
    if (!skipRender) {
      renderGrid();
    }
  }, function(error) {
    console.error('Failed to clear transaction row:', error);
  });
  
  return true;
}


/**
 * Refresh the grid with optional force reload from server
 */
function refresh(forceServerRefresh) {
  _isLoading = false; // Reset loading flag
  
  if (forceServerRefresh) {
    // Clear cache for current month to force fresh fetch
    const key = getCacheKey(_currentMonth, _currentYear);
    _expenseCache.delete(key);
    
    const storageKey = CACHE_PREFIX + key;
    localStorage.removeItem(storageKey);
    
    // Force processing of any pending transactions first
    if (window.TransactionManager) {
      TransactionManager.forceProcessing();
      
      // Wait for processing to complete before refreshing
      setTimeout(function() {
        loadRealExpenseData();
      }, 500);
    } else {
      loadRealExpenseData();
    }
  } else {
    loadRealExpenseData();
  }
}
  
  /**
   * Set expense data from external source (enhanced)
   */
  function setExpenseData(expenses) {
    if (!expenses || !Array.isArray(expenses)) {
      console.error('Invalid expense data provided:', expenses);
      return;
    }
        
    // Process the new data
    processRealExpenseData(expenses);
    
    // Render with the new data
    renderGrid();
  }

  /**
   * Clear cache for testing or troubleshooting
   */
  function clearCache() {
    
    // Clear in-memory cache
    _expenseCache.clear();
    
    // Clear localStorage cache
    try {
      const keys = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(CACHE_PREFIX)) {
          keys.push(key);
        }
      }
      
      keys.forEach(key => localStorage.removeItem(key));
    } catch (error) {
      console.warn('Error clearing localStorage cache:', error);
    }
  }

  // Public methods
  return {
    init: init,
    renderGrid: renderGrid,
    setExpenseData: setExpenseData,
    refresh: refresh,
    updateCurrency: updateCurrency,
    openTransactionModal: openTransactionModal,
    unbindEvents: unbindEvents,
    clearCache: clearCache  // For debugging
  };
})();


// Expose globally
window.MonthlyGrid = MonthlyGrid;

</script>

<style>
/* ======================================================
   MONTHLY GRID VIEW STYLES - IMPROVED UX VERSION
   ======================================================
   Enhanced mobile-first design with better touch targets
   and visual hierarchy
*/

/* ============= MAIN CONTAINER ============= */
.monthly-grid-container {
  width: 100%;
  height: 100%;
  min-height: 400px;
  position: relative;
  overflow: auto;
  padding: 8px 16px 16px 16px;
  max-height: calc(100vh - 90px);
  max-width: 1200px;
  margin: 0 auto;
  background-color: #ffffff;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

/* ============= GRID HEADER ============= */
.grid-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  padding: 8px 0;
  background-color: #fe9aa1;
  border-radius: 0px;
  padding: 12px 16px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

.month-nav-btn {
  background: none;
  border: none;
  color: #2c3e50;
  cursor: pointer;
  width: 36px;
  height: 36px;
  border-radius: 0px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
}

.month-nav-btn:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.month-year-display {
  font-size: 18px;
  font-weight: 500;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* ============= GRID TABLE ============= */
.monthly-grid {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;
  min-width: 720px;
}

/* Headers - Sticky positioning with dashboard style */
.monthly-grid thead {
  position: sticky;
  top: 0px;
  z-index: 200;
}

.monthly-grid th {
  background-color: #f8f5f5 !important;
  padding: 6px 4px;
  text-align: left;
  font-weight: 500;
  color: #2c3e50;
  border-bottom: 1px solid #ddd;
  border-right: 1px solid #ddd;
  position: sticky;
  top: 0;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  z-index: 210;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.monthly-grid th.total-header {
  background-color: #f8e4e4 !important;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
  z-index: 220;
}

.monthly-grid th.date-header {
  width: 60px !important;
  min-width: 60px !important;
  max-width: 60px !important;
  text-align: center !important;
  padding: 6px 4px !important;
  position: sticky !important;
  left: 0 !important;
  top: 0 !important;
  z-index: 1000 !important;
  background-color: #f7f5f5 !important;
  border-bottom: 1px solid #ddd !important;
  border-right: 1px solid #ddd !important;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1) !important;
}

.category-header {
  min-width: 69px;
  width: 69px;
}

.total-header {
  width: 77px;
  text-align: center;
}

.notes-header {
  width: 117px;
}

/* Category header content layout */
.category-header-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

/* Emoji styling - centered on top */
.category-emoji {
  font-size: 18px;
  line-height: 1;
  margin: 0;
  padding: 2px 0;
  text-align: center;
}

/* Category name styling - below emoji, centered */
.category-name {
  font-size: 10px;
  text-align: center;
  line-height: 1.1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
  margin: 0;
  padding: 0;
  font-weight: 500;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* Category total styling */
.category-total {
  font-size: 13px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* Day rows and cells */
.day-row {
  background-color: #ffffff;
}

.day-row:hover {
  background-color: rgba(44, 62, 80, 0.05);
}

.weekend-row {
  background-color: rgba(255, 249, 219, 0.3) !important;
}

.weekend-row:hover {
  background-color: rgba(255, 249, 219, 0.5) !important;
}

/* Apply highlighting only to the cell */
.today-cell {
  font-weight: 500;
}

/* Only apply the blue background to the date cell */
.today-row td.date-cell {
  font-weight: 500;
  background-color: #ffb3d9 !important;
}

.monthly-grid td {
  padding: 2px;
  border-bottom: 1px solid #eee;
  border-right: 1px solid #eee;
  height: 20px;
  vertical-align: middle;
}

.date-cell {
  position: sticky !important;
  left: 0 !important;
  z-index: 100 !important;
  background-color: #f7f5f5 !important;
}

.date-container {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 2px;
  gap: 2px;
}

.day-number {
  font-size: 13px;
  font-weight: 600;
  line-height: 1;
  margin: 0;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.day-name {
  font-size: 11px;
  color: #666;
  line-height: 1;
  margin: 0;
}

.grid-cell {
  cursor: pointer;
  transition: background-color 0.2s;
  position: relative;
}

.grid-cell:hover {
  background-color: rgba(44, 62, 80, 0.1);
}

/* Cell content with improved color coding */
.cell-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 1px;
  padding: 3px 2px;
  color: black;
  font-weight: 500;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  border-radius: 0px;
}

/* Color coding */
.amount-small {
  background-color: rgb(156 242 251 / 15%); /* Light blue */
}

.amount-medium {
  background-color: rgba(255, 193, 7, 0.15); /* Light amber */
}

.amount-large {
  background-color: rgba(244, 67, 54, 0.15); /* Light red */
}

/* Left border only for recurring payments */
.cell-content.recurring {
  border-left: 3px solid #1F618D;
}

.amount {
  font-size: 12px;
  font-weight: 600;
  line-height: 1;
  margin: 0;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.transaction-count {
  font-size: 9px;
  color: rgba(0, 0, 0, 0.6);
  line-height: 1;
  margin: 0;
  font-style: italic;
}

.total-cell {
  font-weight: 600;
  color: #2c3e50;
  text-align: center;
  background-color: rgba(244, 67, 54, 0.08);
}

.total-amount {
  font-size: 13px;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  line-height: 1;
  font-weight: 700;
  font-family: 'Lato', sans-serif;
}

.notes-cell {
  position: relative;
}

.notes-content {
  min-height: 20px;
  padding: 3px;
  border: 1px solid transparent;
  border-radius: 0px;
  transition: border-color 0.2s, background-color 0.2s;
  outline: none;
  font-size: 10px;
  background-color: rgba(241, 241, 241, 0.5);
  line-height: 1.2;
  width: 100%;
  box-sizing: border-box;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  cursor: pointer;
}

.notes-content:hover, .notes-content:focus {
  border-color: #ddd;
  background-color: rgba(241, 241, 241, 0.8);
}

.notes-content:focus {
  background-color: rgba(255, 255, 255, 0.9);
  box-shadow: 0 0 0 2px rgba(44, 62, 80, 0.2);
}

/* Error states */
.grid-error {
  padding: 30px 20px;
  text-align: center;
  color: #d32f2f;
  background-color: #ffebee;
  border-radius: 0px;
  margin: 20px 0;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

.grid-error h3 {
  margin: 0 0 16px 0;
  font-size: 18px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.grid-error p {
  margin: 8px 0;
  line-height: 1.5;
}

.retry-btn {
  margin-top: 16px;
  padding: 10px 20px;
  background-color: #d32f2f;
  color: white;
  border: none;
  border-radius: 0px;
  cursor: pointer;
  font-weight: 500;
  font-size: 14px;
  transition: background-color 0.2s;
}

.retry-btn:hover {
  background-color: #b71c1c;
}

/* Loading indicator */
.loading-indicator {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 20px;
  color: #666;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #e0e0e0;
  border-top: 4px solid #2c3e50;
  border-radius: 50%;
  animation: loading-spin 1s linear infinite;
  margin-bottom: 16px;
}

@keyframes loading-spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-indicator p {
  margin: 8px 0;
  font-size: 14px;
  line-height: 1.5;
}

.loading-indicator small {
  font-size: 12px;
  color: #666;
  opacity: 0.7;
}

/* ============= TRANSACTION MODAL - IMPROVED UX ============= */
.transaction-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  display: none;
  opacity: 0;
  align-items: center;
  justify-content: center;
  transition: opacity 0.3s ease;
}

.transaction-modal.visible {
  display: flex;
  opacity: 1;
}

.modal-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(3px);
}

.modal-card {
  position: relative;
  width: 90%;
  max-width: 700px; /* Slightly wider for better UX */
  max-height: 85vh;
  background-color: #ffffff;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
  display: flex;
  flex-direction: column;
  transform: translateY(20px);
  transition: transform 0.3s ease;
}

.transaction-modal.visible .modal-card {
  transform: translateY(0);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  border-bottom: 1px solid #ddd;
  background-color: #fafafa;
  border-radius: 0px;
}

.modal-title {
  margin: 0;
  font-size: 18px;
  font-weight: 500;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.modal-content {
  flex: 1;
  padding: 20px;
  overflow-y: auto;
}

.transactions-list {
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-bottom: 20px;
}

.transaction-item {
  background-color: #ffffff;
  padding: 16px;
  transition: transform 0.2s, box-shadow 0.2s;
}

.transaction-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* UPDATED: Transaction row layout for new field order: description, amount, account, actions */
.transaction-row {
  display: grid;
  grid-template-columns: 1fr 90px 60px 40px;
  gap: 12px;
  align-items: center;
}

.transaction-description, .transaction-amount {
  padding: 10px 5px;
  border: 1px solid #ddd;
  border-radius: 0px;
  font-size: 14px;
  transition: border-color 0.2s, box-shadow 0.2s;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.transaction-description:focus, .transaction-amount:focus {
  border-color: #2c3e50;
  box-shadow: 0 0 0 3px rgba(44, 62, 80, 0.1);
  outline: none;
}

/* Compact account dropdown */
.transaction-account {
  color: transparent;
  background-color: #ffffff;
  border: 1px solid #ddd;
  border-radius: 0px;
  font-size: 14px;
  width: 60px;
  cursor: pointer;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
  background-position: center;
  background-repeat: no-repeat;
  background-size: 16px;
  padding: 10px;
  transition: border-color 0.2s;
}

.transaction-account:hover, .transaction-account:focus {
  border-color: #2c3e50;
}

.transaction-actions {
  display: flex;
  justify-content: center;
}

.transaction-delete {
  background: none;
  border: none;
  color: #f44336;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity 0.2s, background-color 0.2s;
  width: 36px;
  height: 36px;
  border-radius: 0px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.transaction-delete:hover {
  opacity: 1;
  background-color: rgba(244, 67, 54, 0.1);
}

.new-transaction {
  animation: fade-in 0.3s ease-out;
}

@keyframes fade-in {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.empty-transactions {
  text-align: center;
  color: #666;
  padding: 40px 20px;
  font-style: italic;
  font-size: 15px;
}

.modal-actions {
  display: flex;
  justify-content: center;
  margin-bottom: 8px;
}

.add-transaction-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 20px;
  background-color: #2c3e50;
  color: white;
  border: none;
  border-radius: 0px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.2s;
  font-size: 14px;
}

.add-transaction-btn:hover {
  background-color: #1e2b37;
}

/* Modal title layout */
.integrated-title {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.title-category {
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 6px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.title-divider {
  color: rgba(0, 0, 0, 0.3);
  font-weight: 300;
}

.title-date {
  color: rgba(0, 0, 0, 0.7);
  font-weight: 400;
  font-size: 0.9em;
}

.title-total {
  color: #2c3e50;
  font-weight: 600;
  margin-left: auto;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* ============= DAY DETAILS POPUP ============= */
.day-details-popup {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.day-details-popup.visible {
  opacity: 1;
}

.popup-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(2px);
}

.popup-content {
  position: relative;
  width: 90%;
  max-width: 500px;
  max-height: 70vh;
  background-color: #ffffff;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
  display: flex;
  flex-direction: column;
}

.popup-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #ddd;
  background-color: #fafafa;
}

.popup-header h3 {
  margin: 0;
  font-size: 16px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.popup-close {
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #666;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 0px;
  transition: background-color 0.2s;
}

.popup-close:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.popup-body {
  flex: 1;
  padding: 16px 20px;
  overflow-y: auto;
}

.transaction-detail {
  display: grid;
  grid-template-columns: 1fr 1fr 80px 100px;
  gap: 12px;
  padding: 8px 0;
  border-bottom: 1px solid #eee;
  align-items: center;
}

.transaction-detail:last-child {
  border-bottom: none;
}

.detail-category {
  font-size: 13px;
  font-weight: 500;
}

.detail-name {
  font-size: 13px;
  color: #333;
}

.detail-amount {
  font-size: 13px;
  font-weight: 600;
  text-align: right;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
}

.detail-account {
  font-size: 12px;
  color: #666;
  text-align: right;
}

/* Dark mode for popup */
body.dark-mode .popup-content {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .popup-header {
  background-color: rgba(255, 255, 255, 0.05);
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .transaction-detail {
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .detail-amount {
  color: #DDA15E;
}

body.dark-mode .popup-close {
  color: rgba(255, 255, 255, 0.7);
}

/* Mobile popup adjustments */
@media (max-width: 768px) {
  .popup-content {
    width: 95%;
    max-height: 80vh;
  }
  
  .transaction-detail {
    grid-template-columns: 1fr 60px 80px;
    gap: 8px;
  }
  
  .detail-account {
    display: none;
  }
}

/* ============= RESPONSIVE DESIGN - MOBILE FIRST ============= */
@media (max-width: 768px) {
  /* Ensure parent elements don't constrain height */
  .view, #expenseView, #expenseContent {
    height: 100% !important;
    max-height: none !important;
  }
  
  .monthly-grid-container {
    padding: 0px 0px 120px 0px !important;
    max-height: none !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    overflow: auto !important;
    z-index: 1 !important;
    box-sizing: border-box !important;
    /* STICKY SCROLLING - Allow scroll but prevent bounce/momentum */
    touch-action: pan-x pan-y !important;
    -webkit-overflow-scrolling: auto !important;
    overscroll-behavior: none !important;
  }
  
  .monthly-grid {
    /* PREVENT TABLE DRAGGING - but allow container scrolling */
    touch-action: pan-x pan-y !important;
    user-select: none !important;
    -webkit-user-select: none !important;
  }
  
  .monthly-grid td, .monthly-grid th {
    /* PREVENT CELL DRAGGING */
    user-select: none !important;
    -webkit-user-select: none !important;
  }
  
  /* Ensure floating buttons stay above the grid */
  .quick-expense-btn {
    z-index: 9999 !important;
  }
  
  /* Ensure sidebar toggle stays above the grid */
  #mobileSidebarToggle, .sidebar-toggle {
    z-index: 9999 !important;
  }
  
  /* MOBILE: Improved touch targets */
  .month-nav-btn {
    width: 48px !important;
    height: 48px !important;
  }
  
  /* MOBILE: Hide category names, show only emojis */
  .category-name {
    display: none !important;
  }
  
  .category-emoji {
    font-size: 16px;
    padding: 2px 0;
  }
  
  .category-header {
    min-width: 35px !important;
    width: 35px !important;
    padding: 2px 1px !important;
  }
  
  .monthly-grid th.date-header, 
  .monthly-grid td.date-cell {
    width: 40px !important;
    min-width: 40px !important;
    max-width: 40px !important;
  }
  
  .day-name {
    font-size: 7px;
  }
  
  .day-number {
    font-size: 11px;
  }
  
  .total-header {
    width: 45px !important;
  }
  
  /* MOBILE: Hide transaction count */
  .transaction-count {
    display: none !important;
  }
  
  /* MOBILE: Ultra compact cells */
  .monthly-grid td {
    height: 15px !important;
    padding: 0px !important;
  }
  
  .monthly-grid th {
    padding: 2px 1px !important;
  }
  
  .cell-content {
    padding: 1px !important;
    gap: 0px !important;
    min-height: 15px;
  }
  
  .amount {
    font-size: 9px;
    line-height: 1;
  }
  
  /* MOBILE: Transaction row optimization - UPDATED for new field order */
  .transaction-row {
    grid-template-columns: 1fr 45px 40px 40px;
    gap: 8px;
  }
  
  .transaction-item {
    padding: 6px;
  }
  
  .modal-header {
    padding: 16px;
  }
  
  .modal-content {
    padding: 16px;
  }
}

@media (max-width: 480px) {
 
  
  .monthly-grid td, .monthly-grid th {
    padding: 2px !important;
  }
  
  .category-header, .total-header {
    min-width: 44px !important;
    width: 44px !important;
  }
  
  .amount {
    font-size: 11px;
  }
  
  .integrated-title {
    font-size: 15px;
  }
  
  /* MOBILE: Further optimize transaction modal */
  .transaction-row {
    grid-template-columns: 1fr 70px 44px !important; /* Remove account on very small screens */
    gap: 8px !important;
  }
  
  .transaction-account {
    display: none !important; /* Hide account selector on very small screens */
  }
}

/* ============= DARK MODE STYLES ============= */
/* Main container becomes dark */
body.dark-mode .monthly-grid-container {
  background-color: var(--dark-surface, #1e1e1e) !important;
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87)) !important;
}

/* Header becomes dark */
body.dark-mode .grid-header {
  background-color: var(--dark-surface, #1e1e1e) !important;
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87)) !important;
}

body.dark-mode .month-nav-btn {
  color: rgba(255, 255, 255, 0.87) !important;
}

body.dark-mode .month-year-display {
  color: rgba(255, 255, 255, 0.87) !important;
}

/* Table headers */
body.dark-mode .monthly-grid th {
  background-color: #334960 !important;
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  border-bottom: 1px solid var(--dark-border, rgba(255, 255, 255, 0.12));
  border-right: 1px solid var(--dark-border, rgba(255, 255, 255, 0.12));
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

body.dark-mode .monthly-grid th.date-header {
  background-color: #344960 !important;
}

body.dark-mode .monthly-grid th.total-header {
  background-color: #5f5f5f !important;
  box-shadow: 0 3px 4px rgba(0, 0, 0, 0.3) !important;
}

/* Table cells */
body.dark-mode .monthly-grid td {
  border-bottom: 1px solid var(--dark-border, rgba(255, 255, 255, 0.12));
  border-right: 1px solid var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .cell-content {
  background-color: var(--dark-surface, #1e1e1e);
  color: #e6e6e6;
}

body.dark-mode .date-cell {
  background-color: var(--dark-surface, #1e1e1e) !important;
}

body.dark-mode .weekend-row .date-cell {
  background-color: rgba(255, 249, 219, 0.05) !important;
}

body.dark-mode .today-row .date-cell {
  background-color: rgba(255, 235, 156, 0.08) !important;
}

body.dark-mode .day-name {
  color: rgba(255, 255, 255, 0.7);
}

body.dark-mode .day-number {
  color: #DDA15E !important;
}

body.dark-mode .day-row {
  background-color: var(--dark-surface, #1e1e1e);
}

body.dark-mode .day-row:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

body.dark-mode .weekend-row {
  background-color: rgba(255, 249, 219, 0.05) !important;
}

body.dark-mode .weekend-row:hover {
  background-color: rgba(255, 249, 219, 0.1) !important;
}

body.dark-mode .total-cell {
  background-color: rgba(244, 67, 54, 0.1);
}

/* Values get golden color */
body.dark-mode .amount,
body.dark-mode .total-amount,
body.dark-mode .category-total {
  color: #DDA15E !important;
}

body.dark-mode .grid-cell:hover {
  background-color: rgba(255, 255, 255, 0.08);
}

body.dark-mode .notes-content {
  background-color: rgba(58, 58, 58, 0.5);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .notes-content:hover,
body.dark-mode .notes-content:focus {
  background-color: rgba(58, 58, 58, 0.8);
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .notes-content:focus {
  background-color: rgba(40, 40, 40, 0.9);
}

/* Enhanced color coding in dark mode */
body.dark-mode .amount-small {
  background-color: rgba(76, 175, 80, 0.2);
  border-left-color: #4CAF50;
}

body.dark-mode .amount-medium {
  background-color: rgba(255, 193, 7, 0.2);
  border-left-color: #FFC107;
}

body.dark-mode .amount-large {
  background-color: rgba(244, 67, 54, 0.2);
  border-left-color: #F44336;
}

body.dark-mode .transaction-count {
  color: rgba(255, 255, 255, 0.7);
}

/* Modal dark mode */
body.dark-mode .modal-card {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .modal-header {
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
  background-color: rgba(255, 255, 255, 0.05);
}

body.dark-mode .transaction-item {
  background-color: var(--dark-surface, #1e1e1e);
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .transaction-amount,
body.dark-mode .transaction-description {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .transaction-account {
  background-color: var(--dark-surface, #1e1e1e);
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
}

body.dark-mode .title-divider {
  color: rgba(255, 255, 255, 0.3);
}

body.dark-mode .title-date {
  color: rgba(255, 255, 255, 0.7);
}

body.dark-mode .title-total {
  color: #DDA15E !important;
}

body.dark-mode .empty-transactions {
  color: rgba(255, 255, 255, 0.7);
}

body.dark-mode .add-transaction-btn {
  background-color: #DDA15E;
  color: #1e1e1e;
}

body.dark-mode .add-transaction-btn:hover {
  background-color: #c9955a;
}

/* Error states dark mode */
body.dark-mode .grid-error {
  background-color: var(--dark-surface, #1e1e1e);
  color: #ef5350;
}

body.dark-mode .loading-indicator {
  color: rgba(255, 255, 255, 0.7);
}

body.dark-mode .loading-spinner {
  border-color: #666;
  border-top-color: #DDA15E;
}

/* ============= MACBOOK 13" OPTIMIZATION ============= */
@media (min-width: 1280px) and (max-width: 1680px) {
  /* Horizontal layout for transaction count to save vertical space */
  .cell-content {
    flex-direction: row;
    gap: 4px;
    justify-content: center;
    align-items: center;
  }
  
  .transaction-count {
    font-size: 8px;
    margin-left: 2px;
  }
  
  /* Reduce cell height for more days on MacBook */
  .monthly-grid td {
    height: 21px;
    padding: 1px;
  }
  
  .cell-content {
    padding: 2px 1px;
  }
}
@media (min-width: 1400px) {
  .monthly-grid-container {
    max-width: 1400px;
    padding: 0;
  }
  
  .category-header {
    min-width: 95px;
    width: 95px;
  }
  
  .total-header {
    width: 100px;
  }
  
  .notes-header {
    width: 160px;
  }
  
  /* Large screen: Show category names alongside emojis */
  .category-emoji {
    font-size: 18px;
  }
  
  .category-name {
    font-size: 12px !important;
  }
}

/* ============= MEDIUM-LARGE SCREEN OPTIMIZATION ============= */
@media (min-width: 1400px) {
  .category-header {
    min-width: 85px;
    width: 85px;
  }
}

/* ============= LARGE SCREEN OPTIMIZATION ============= */
@media (min-width: 1681px) {
  .monthly-grid-container {
    max-width: 1600px;
    padding: 0;
  }
  
  .category-header {
    min-width: 95px;
    width: 85px;
  }
  
  .total-header {
    width: 100px;
  }
  
  .notes-header {
    width: 160px;
  }
  
  /* Large screen: Show category names alongside emojis */
  .category-emoji {
    font-size: 18px;
  }
  
  .category-name {
    font-size: 12px !important;
  }
  
  /* Increase cell height for very large screens */
  .monthly-grid td {
    height: 32px;
    padding: 4px;
  }
  
  .cell-content {
    padding: 4px 3px;
  }
}

/* Utility classes */
.hidden {
  display: none !important;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* Enhanced styling for fixed/subscription transactions */
.transaction-item.fixed-transaction {
  background-color: rgba(142, 68, 173, 0.05);
  border-left: 4px solid #8e44ad;
}

.transaction-item.fixed-transaction .transaction-row {
  opacity: 0.8;
  grid-template-columns: 1fr 90px 44px;
}

/* Style readonly inputs to look clean */
.transaction-item.fixed-transaction input {
  background-color: #f9f5fa;
  cursor: not-allowed;
  border-color: #d6c7dc;
  color: #555;
  pointer-events: none;
}

/* Create styling for the recurring icon */
.recurring-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: #8e44ad;
  margin-left: 8px;
  vertical-align: middle;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.recurring-icon i {
  font-size: 18px;
}

/* Dark mode adjustments */
body.dark-mode .transaction-item.fixed-transaction {
  background-color: rgba(155, 89, 182, 0.1);
  border-left-color: #9b59b6;
}

body.dark-mode .transaction-item.fixed-transaction input {
  background-color: #2a2a2a;
  border-color: #444;
  color: #bbb;
}

body.dark-mode .recurring-icon {
  color: #9b59b6;
}

/* Mobile adjustments */
@media (max-width: 768px) {
  .transaction-item.fixed-transaction .transaction-row {
    grid-template-columns: 1fr 45px 40px;
  }
  
  .recurring-icon i {
    font-size: 16px;
  }
}
</style>