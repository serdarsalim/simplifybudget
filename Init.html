<script>

  /**
 * Init.html - Initialization script for SimBudget
 * Handles application startup, event binding, and view management
 */

// Main SimBudget namespace
var SimBudget = (function() {
  // Private variables
  let _initialized = false;
  let _currentView = 'budget';
  
  // Cache system for data
  const _cache = {
    // Cache storage with data and metadata
    data: {
      budget: { content: null, timestamp: null },
      expense: { content: null, timestamp: null },
      income: { content: null, timestamp: null },
      recurring: { content: null, timestamp: null },
      netWorth: { content: null, timestamp: null },
      reports: { content: null, timestamp: null }
    },
    
    // Cache configuration
    config: {
      // Default cache expiry time in milliseconds (5 minutes)
      expiryTime: 5 * 60 * 1000,
      
      // Flags to determine if certain actions should invalidate cache
      invalidateOnMonthYearChange: true
    },
    
    // Store data in cache
    set: function(key, data) {
      if (!this.data[key]) return false;
      
      this.data[key].content = data;
      this.data[key].timestamp = new Date().getTime();
      return true;
    },
    
    // Get data from cache if valid
    get: function(key) {
      const cacheEntry = this.data[key];
      if (!cacheEntry || !cacheEntry.content) return null;
      
      const now = new Date().getTime();
      if ((now - cacheEntry.timestamp) > this.config.expiryTime) {
        // Cache expired
        return null;
      }
      
      return cacheEntry.content;
    },
    
    // Check if cache for key is valid
    isValid: function(key) {
      return this.get(key) !== null;
    },
    
    // Invalidate specific cache entries
    invalidate: function(key) {
      if (key && this.data[key]) {
        this.data[key].content = null;
        this.data[key].timestamp = null;
      }
    },
    
    // Invalidate all cache entries
    invalidateAll: function() {
      Object.keys(this.data).forEach(key => {
        this.invalidate(key);
      });
    },
    
    // Invalidate related caches when a type of data is modified
    invalidateRelated: function(key) {
      // Define relationships between data types
      const relationships = {
        budget: ['reports'],
        expense: ['budget', 'reports'],
        income: ['budget', 'reports'],
        recurring: ['reports'],
        netWorth: ['reports']
      };
      
      // Invalidate the primary key
      this.invalidate(key);
      
      // Invalidate related keys
      if (relationships[key]) {
        relationships[key].forEach(relatedKey => {
          this.invalidate(relatedKey);
        });
      }
    }
  };
  
  // Settings module
  const Settings = {
    // Default settings
    defaults: {
      currencySymbol: 'â‚¬',
      dateFormat: 'MM/DD/YYYY',
      darkMode: false,
      showRemaining: true,
      enableAlerts: true,
      startingDay: '1',
      language: 'en'
    },
    
    // Get a setting with fallback to default
    getSetting: function(key) {
      const userSettings = Utils.getLocalStorage('simbudget_settings', {});
      return userSettings[key] !== undefined ? userSettings[key] : this.defaults[key];
    },
    
    // Set a setting
    setSetting: function(key, value) {
      const userSettings = Utils.getLocalStorage('simbudget_settings', {});
      userSettings[key] = value;
      return Utils.setLocalStorage('simbudget_settings', userSettings);
    },
    
    // Save all settings
    saveAll: function(settings) {
      return Utils.setLocalStorage('simbudget_settings', settings);
    },
    
    // Get all settings
    getAll: function() {
      const userSettings = Utils.getLocalStorage('simbudget_settings', {});
      // Merge with defaults for any missing settings
      return { ...this.defaults, ...userSettings };
    },
    
    // Convenience methods for common settings
    getCurrencySymbol: function() {
      return this.getSetting('currencySymbol');
    },
    
    getDateFormat: function() {
      return this.getSetting('dateFormat');
    },
    
    isDarkMode: function() {
      return this.getSetting('darkMode');
    }
  };
  
  // View management
  const Views = {
    // Switch to a view
    switchTo: function(viewName) {
      if (!viewName) return;
      
      // Hide all views
      document.querySelectorAll('.view').forEach(view => {
        view.classList.remove('active-view');
      });
      
      // Show the selected view
      const targetView = document.getElementById(viewName + 'View');
      if (targetView) {
        targetView.classList.add('active-view');
        _currentView = viewName;
        
        // Update sidebar active state
        document.querySelectorAll('.sidebar-item').forEach(item => {
          item.classList.remove('active');
        });
        
        const activeItem = document.querySelector(`.sidebar-item[data-view="${viewName}"]`);
        if (activeItem) {
          activeItem.classList.add('active');
        }
        
        // Load data for the view
        SimBudget.loadViewData(viewName);
      }
    },
    
    // Get current view
    getCurrent: function() {
      return _currentView;
    }
  };
  
  // Public methods
  return {
    // Settings module reference
    Settings: Settings,
    
    // Views module reference
    Views: Views,
    
    /**
     * Initialize the application
     */
    initialize: function() {
      if (_initialized) return;
      
      console.log('Initializing SimBudget...');
      
      // Set up event listeners
      this.bindEvents();
      
      // Set up month and year selectors
      this.setupMonthYearSelectors();
      
      // Check for existing sheet URL
      this.checkExistingConnection();
      
      // Apply settings
      this.applySettings();
      
      // Load user info
      this.loadUserInfo();
      
      // Load initial budget data
      this.loadViewData('budget');
      
      _initialized = true;
      console.log('SimBudget initialized');
    },
    
    /**
     * Set up month and year selectors
     */
    setupMonthYearSelectors: function() {
      const yearSelector = document.getElementById('yearSelector');
      if (yearSelector) {
        // Clear existing options
        yearSelector.innerHTML = '';
        
        // Populate with 2 years before and after current year
        const currentYear = new Date().getFullYear();
        for (let year = currentYear - 2; year <= currentYear + 2; year++) {
          const option = document.createElement('option');
          option.value = year;
          option.textContent = year;
          yearSelector.appendChild(option);
        }
        
        // Set current year as selected
        yearSelector.value = currentYear;
      }
    },
    
    /**
     * Update month and year when changed by user
     */
    updateMonthYear: function(month, year) {
      API.setMonthYear(month, year,
        function(result) {
          console.log('Month/year updated:', month, year);
          
          // Invalidate budget cache when month/year changes
          if (_cache.config.invalidateOnMonthYearChange) {
            _cache.invalidateRelated('budget');
          }
          
          // Reload budget data with new month/year
          SimBudget.loadViewData('budget');
        },
        function(error) {
          Utils.showToast('Error updating month/year: ' + error, 'error');
        }
      );
    },
    
    /**
     * Bind all event listeners
     */
    bindEvents: function() {
      // Sidebar toggle
      const toggleBtn = document.getElementById('toggleSidebar');
      if (toggleBtn) {
        toggleBtn.addEventListener('click', toggleSidebar);
      }
      
      // Sidebar navigation
      document.querySelectorAll('.sidebar-item').forEach(item => {
        item.addEventListener('click', handleSidebarItemClick);
      });
      
      // Month and year selectors
      const monthSelector = document.getElementById('monthSelector');
      const yearSelector = document.getElementById('yearSelector');
      
      if (monthSelector && yearSelector) {
        monthSelector.addEventListener('change', function() {
          SimBudget.updateMonthYear(this.value, yearSelector.value);
        });
        
        yearSelector.addEventListener('change', function() {
          SimBudget.updateMonthYear(monthSelector.value, this.value);
        });
      }
      
      // Settings panel
      const saveSettingsBtn = document.getElementById('saveSettingsBtn');
      if (saveSettingsBtn) {
        saveSettingsBtn.addEventListener('click', this.saveSettings);
      }
      
      const resetSettingsBtn = document.getElementById('resetSettings');
      if (resetSettingsBtn) {
        resetSettingsBtn.addEventListener('click', this.resetSettings);
      }
      
      const testConnectionBtn = document.getElementById('testConnection');
      if (testConnectionBtn) {
        testConnectionBtn.addEventListener('click', this.testConnection);
      }
      
      // Responsive design - auto-collapse sidebar on small screens
      window.addEventListener('resize', Utils.debounce(function() {
        const sidebar = document.getElementById('sidebar');
        if (window.innerWidth < 768 && sidebar && sidebar.classList.contains('expanded')) {
          toggleSidebar();
        }
      }, 250));
      
      // Set up view-specific buttons
      document.getElementById('refreshBudget').addEventListener('click', () => {
        // Force refresh by invalidating cache
        _cache.invalidate('budget');
        this.loadViewData('budget');
      });
      
      document.getElementById('refreshNetWorth').addEventListener('click', () => {
        // Force refresh by invalidating cache
        _cache.invalidate('netWorth');
        this.loadViewData('netWorth');
      });
      
      // TODO: Set up other view-specific buttons (add expense, add income, etc.)
    },
    
    /**
     * Check for existing connection and load if available
     */
    checkExistingConnection: function() {
      API.getUserCredentials(
        function(result) {
          if (result.sheetUrl) {
            const urlInput = document.getElementById('budgetSheetUrl');
            if (urlInput) {
              urlInput.value = result.sheetUrl;
            }
            
            // Auto-test connection 
            SimBudget.testConnection();
          }
        },
        function(error) {
          console.error('Error getting user credentials:', error);
        }
      );
    },
    
    /**
     * Apply user settings
     */
    applySettings: function() {
      const settings = Settings.getAll();
      
      // Apply dark mode if enabled
      if (settings.darkMode) {
        document.body.classList.add('dark-mode');
      } else {
        document.body.classList.remove('dark-mode');
      }
      
      // Set values in settings form
      const currencyInput = document.getElementById('currencySymbol');
      if (currencyInput) {
        currencyInput.value = settings.currencySymbol;
      }
      
      const dateFormatSelect = document.getElementById('dateFormat');
      if (dateFormatSelect) {
        dateFormatSelect.value = settings.dateFormat;
      }
      
      const darkModeCheckbox = document.getElementById('darkMode');
      if (darkModeCheckbox) {
        darkModeCheckbox.checked = settings.darkMode;
      }
      
      const languageSelect = document.getElementById('languageSelector');
      if (languageSelect) {
        languageSelect.value = settings.language;
      }
      
      const showRemainingCheckbox = document.getElementById('showRemaining');
      if (showRemainingCheckbox) {
        showRemainingCheckbox.checked = settings.showRemaining;
      }
      
      const enableAlertsCheckbox = document.getElementById('enableAlerts');
      if (enableAlertsCheckbox) {
        enableAlertsCheckbox.checked = settings.enableAlerts;
      }
      
      const startingDaySelect = document.getElementById('startingDay');
      if (startingDaySelect) {
        startingDaySelect.value = settings.startingDay;
      }
    },
    
    /**
     * Load user info
     */
    loadUserInfo: function() {
      API.getUserCredentials(
        function(result) {
          const userEmailEl = document.getElementById('userEmail');
          if (userEmailEl) {
            userEmailEl.textContent = result.email || 'Not signed in';
          }
        },
        function(error) {
          console.error('Error getting user credentials:', error);
          const userEmailEl = document.getElementById('userEmail');
          if (userEmailEl) {
            userEmailEl.textContent = 'Error loading user info';
          }
        }
      );
    },
    
    /**
     * Save settings
     */
    saveSettings: function() {
      // Get values from form
      const settings = {
        currencySymbol: document.getElementById('currencySymbol').value,
        dateFormat: document.getElementById('dateFormat').value,
        darkMode: document.getElementById('darkMode').checked,
        showRemaining: document.getElementById('showRemaining').checked,
        enableAlerts: document.getElementById('enableAlerts').checked,
        startingDay: document.getElementById('startingDay').value,
        language: document.getElementById('languageSelector').value
      };
      
      // Save to local storage
      if (SimBudget.Settings.saveAll(settings)) {
        // Apply settings
        SimBudget.applySettings();
        
        // Save sheet URL if provided
        const sheetUrl = document.getElementById('budgetSheetUrl').value;
        if (sheetUrl) {
          API.setBudgetSheetUrl(sheetUrl, 
            function() {
              Utils.showStatus('Settings saved successfully', false, document.getElementById('settingsStatus'), 3000);
              
              // Invalidate all caches when sheet URL changes
              _cache.invalidateAll();
            },
            function(error) {
              Utils.showStatus('Settings saved but sheet URL could not be saved: ' + error, true, document.getElementById('settingsStatus'));
            }
          );
        } else {
          Utils.showStatus('Settings saved successfully', false, document.getElementById('settingsStatus'), 3000);
        }
      } else {
        Utils.showStatus('Error saving settings', true, document.getElementById('settingsStatus'));
      }
    },
    
    /**
     * Reset settings to defaults
     */
    resetSettings: function() {
      // Reset to defaults
      if (SimBudget.Settings.saveAll(SimBudget.Settings.defaults)) {
        // Apply settings
        SimBudget.applySettings();
        
        Utils.showStatus('Settings reset to defaults', false, document.getElementById('settingsStatus'), 3000);
      } else {
        Utils.showStatus('Error resetting settings', true, document.getElementById('settingsStatus'));
      }
    },
    
    /**
     * Test connection to sheet
     */
    testConnection: function() {
      const sheetUrl = document.getElementById('budgetSheetUrl').value;
      if (!sheetUrl) {
        Utils.showStatus('Please enter a spreadsheet URL', true, document.getElementById('connectionStatus'));
        return;
      }
      
      // Show loading state
      Utils.showStatus('Testing connection...', false, document.getElementById('connectionStatus'));
      
      API.verifySheetUrl(sheetUrl,
        function(result) {
          Utils.showStatus('Connection successful!', false, document.getElementById('connectionStatus'), 3000);
          
          // Invalidate all caches when connection changes
          _cache.invalidateAll();
        },
        function(error) {
          Utils.showStatus('Connection failed: ' + error, true, document.getElementById('connectionStatus'));
        }
      );
    },
    
    /**
     * Load data for a specific view with caching
     * @param {string} viewName - Name of the view to load
     * @param {boolean} forceRefresh - Whether to bypass cache and force a refresh
     */
    loadViewData: function(viewName, forceRefresh = false) {
      // Check cache first unless force refresh is requested
      if (!forceRefresh && _cache.isValid(viewName)) {
        console.log(`Using cached data for ${viewName} view`);
        this.renderViewFromCache(viewName);
        return;
      }
      
      // Otherwise load from server
      switch(viewName) {
        case 'budget':
          this.loadBudgetData();
          break;
        case 'expense':
          this.loadExpenseData();
          break;
        case 'income':
          // TODO: Add income data loading
          break;
        case 'recurring':
          // TODO: Add recurring data loading
          break;
        case 'netWorth':
          // TODO: Add net worth data loading
          break;
        case 'reports':
          // TODO: Add reports data loading
          break;
        case 'setup':
          // TODO: Add setup data loading
          break;
        case 'settings':
          // Settings data is loaded inline
          break;
      }
    },
    
    /**
     * Render view using cached data
     * @param {string} viewName - Name of the view to render
     */
    renderViewFromCache: function(viewName) {
      const cachedData = _cache.get(viewName);
      if (!cachedData) return;
      
      switch(viewName) {
        case 'budget':
          this.renderBudgetView(cachedData);
          break;
        case 'expense':
          this.renderExpenseView(cachedData);
          break;
        // Add cases for other views as they're implemented
      }
    },
    
    /**
     * Load budget data
     */
    loadBudgetData: function() {
      const contentArea = document.getElementById('budgetContent');
      
      // Show loading state
      contentArea.innerHTML = '<div class="loading-spinner"></div>';
      
      API.getBudgetData(
        function(result) {
          // Cache the result
          _cache.set('budget', result.budget);
          
          // Render the view
          SimBudget.renderBudgetView(result.budget);
        },
        function(error) {
          contentArea.innerHTML = `
            <div class="error-message">
              <i class="material-icons">error</i>
              <span>Error loading budget data: ${error}</span>
            </div>
          `;
        }
      );
    },
    
    /**
     * Render budget view with provided data
     * @param {Object} budget - Budget data to render
     */
    renderBudgetView: function(budget) {
      const contentArea = document.getElementById('budgetContent');
      
      // Update month and year selectors to match spreadsheet values
      const monthSelector = document.getElementById('monthSelector');
      const yearSelector = document.getElementById('yearSelector');
      
      if (monthSelector && budget.month) {
        monthSelector.value = budget.month;
      }
      
      if (yearSelector && budget.year) {
        yearSelector.value = budget.year;
      }
      
      // Store budget data globally for local calculations
      this._currentBudgetData = budget;
      
      // Create budget summary
      let html = `
        <div class="budget-alerts">
          <div id="budget-info-message" class="info-message">${budget.infoMessage || ''}</div>
        </div>
        
        <div class="budget-summary">
          <div class="budget-card">
            <div class="budget-header">Income</div>
            <div class="budget-amount">${Utils.formatCurrency(budget.income)}</div>
          </div>
          <div class="budget-card">
            <div class="budget-header">Spent</div>
            <div class="budget-amount">${Utils.formatCurrency(budget.spent)}</div>
          </div>
          <div class="budget-card">
            <div class="budget-header">Left to Spend</div>
            <div class="budget-amount">${Utils.formatCurrency(budget.leftToSpend)}</div>
          </div>
        </div>
        
        <div class="budget-categories">
          <h2>Budget Categories</h2>
          <div class="table-container">
            <table class="budget-table">
              <thead>
                <tr>
                  <th>Category</th>
                  <th>Budgeted</th>
                  <th>Actual</th>
                  <th>Progress</th>
                </tr>
              </thead>
              <tbody>
      `;
      
      // Add rows for each category
      budget.categories.forEach(function(category) {
        const percentSpent = category.budgeted > 0 ? (category.actual / category.budgeted) * 100 : 0;
        const progressClass = percentSpent > 100 ? 'over-budget' : (percentSpent > 80 ? 'near-limit' : '');
        
        html += `
          <tr>
            <td class="category-name">${category.name}</td>
            <td class="budget-value" data-category="${category.name}" data-value="${category.budgeted}">${Utils.formatCurrency(category.budgeted)}</td>
            <td class="actual-value">${Utils.formatCurrency(category.actual)}</td>
            <td class="progress-cell">
              <div class="progress-bar-container">
                <div class="progress-bar ${progressClass}" style="width: ${Math.min(percentSpent, 100)}%"></div>
              </div>
              <div class="progress-percentage">${Math.round(percentSpent)}%</div>
            </td>
          </tr>
        `;
      });
      
      html += `
            </tbody>
          </table>
        </div>
      `;
      
      // Update the budget content
      contentArea.innerHTML = html;
      
      // Make the budgeted amounts editable
      document.querySelectorAll('.budget-value').forEach(cell => {
        cell.setAttribute('contenteditable', 'true');
        cell.setAttribute('title', 'Click to edit budget amount');
        cell.classList.add('editable');
        
        // Get the category name from data attribute
        const categoryName = cell.dataset.category;
        const originalValue = parseFloat(cell.dataset.value);
        
        // Variables for auto-save debounce
        let saveTimeout = null;
        let isSaving = false;
        
        // Handle key presses
        cell.addEventListener('keydown', function(e) {
          // Prevent Enter from creating a new line - just blur the field instead
          if (e.key === 'Enter') {
            e.preventDefault();
            this.blur(); 
          }
          
          // Cancel on Escape key press
          if (e.key === 'Escape') {
            e.preventDefault();
            // Reset to the original formatted value
            this.textContent = Utils.formatCurrency(originalValue);
            this.blur();
            
            // Cancel any pending save
            if (saveTimeout) {
              clearTimeout(saveTimeout);
              saveTimeout = null;
            }
          }
        });
        
        // Validate input - allow only numbers, decimal point, and currency symbols
        cell.addEventListener('input', function(e) {
          // Cancel any pending save
          if (saveTimeout) {
            clearTimeout(saveTimeout);
          }
          
          // Clean the value to show just numbers
          const rawValue = this.textContent.replace(/[^0-9.-]+/g, '');
          const numValue = parseFloat(rawValue);
          
          if (isNaN(numValue)) {
            // Invalid input, will be corrected on blur
            return;
          }
          
          // Apply the styling to indicate editing is in progress
          this.classList.add('editing');
          
          // Schedule auto-save after 1 second of no typing
          saveTimeout = setTimeout(() => {
            // Don't save if we're already saving
            if (isSaving) return;
            
            // Get the current numeric value
            const cleanValue = this.textContent.replace(/[^0-9.-]+/g, '');
            const numValue = parseFloat(cleanValue);
            
            // Don't save if invalid number
            if (isNaN(numValue)) {
              this.classList.remove('editing');
              return;
            }
            
            // Store the current value to use in our local state update
            const newBudgetValue = numValue;
            
            // Don't save if the value hasn't changed significantly (within small rounding error)
            if (Math.abs(numValue - originalValue) < 0.001) {
              this.classList.remove('editing');
              return;
            }
            
            // Indicate saving
            isSaving = true;
            this.classList.add('saving');
            
            // Format with currency symbol for display
            this.textContent = Utils.formatCurrency(numValue);
            
            // Save the new value to the spreadsheet in the background
            API.updateBudgetValue(categoryName, numValue,
              (result) => {
                // Update was successful
                isSaving = false;
                this.classList.remove('editing', 'saving');
                this.classList.add('saved');
                
                // Update our local data with the final value
                let budgetChanged = false;
                SimBudget._currentBudgetData.categories.forEach(cat => {
                  if (cat.name === categoryName) {
                    // Only mark changed if there's a significant difference
                    if (Math.abs(cat.budgeted - newBudgetValue) > 0.001) {
                      budgetChanged = true;
                      cat.budgeted = newBudgetValue;
                    }
                  }
                });
                
                // Update cached data with the new value
                const cachedBudget = _cache.get('budget');
                if (cachedBudget) {
                  cachedBudget.categories.forEach(cat => {
                    if (cat.name === categoryName) {
                      cat.budgeted = newBudgetValue;
                    }
                  });
                  _cache.set('budget', cachedBudget);
                }
                
                // Always update the info message based on local calculations
                if (budgetChanged) {
                  SimBudget.updateInfoMessage(true); // Force update
                }
                
                // Show a subtle success indicator
                setTimeout(() => {
                  this.classList.remove('saved');
                }, 1500);
              },
              (error) => {
                // Update failed
                isSaving = false;
                this.classList.remove('editing', 'saving');
                this.classList.add('error');
                
                // Invalidate cache to ensure fresh data next time
                _cache.invalidateRelated('budget');
                
                // Show error toast
                Utils.showToast('Error updating budget: ' + error, 'error');
                
                // Remove error indicator after a delay
                setTimeout(() => {
                  this.classList.remove('error');
                }, 1500);
              }
            );
          }, 1000); // Wait 1 second after typing stops
        });
        
        // Format value on blur
        cell.addEventListener('blur', function() {
          // Get numeric value
          const value = parseFloat(this.textContent.replace(/[^0-9.-]+/g, ''));
          if (!isNaN(value)) {
            // Format with currency symbol
            this.textContent = Utils.formatCurrency(value);
          } else {
            // If not a valid number, revert to original
            this.textContent = Utils.formatCurrency(originalValue);
          }
        });
        
        // Select all text when focused
        cell.addEventListener('focus', function() {
          const range = document.createRange();
          range.selectNodeContents(this);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        });
      });
    },
    
    /**
     * Update the info message based on local budget calculations
     * @param {boolean} force - If true, force a message update even if nothing changed
     */
    updateInfoMessage: function(force = false) {
      if (!this._currentBudgetData) return;
      
      const budget = this._currentBudgetData;
      const infoMessageElement = document.getElementById('budget-info-message');
      if (!infoMessageElement) return;
      
      // Calculate total budgeted amount from final values only
      let totalBudgeted = 0;
      budget.categories.forEach(cat => {
        // Only use budgeted values that are numbers, not in-progress edits
        if (typeof cat.budgeted === 'number') {
          totalBudgeted += cat.budgeted || 0;
        }
      });
      
      // Store the current message for comparison
      const currentMessage = infoMessageElement.textContent;
      
      // Calculate the new message
      let message = '';
      let messageType = 'info'; // Default styling
      
      // Helper function for comparing floating point numbers with a small tolerance
      const isApproximatelyEqual = (a, b) => Math.abs(a - b) < 0.01;
      
      if (budget.income === 0 || budget.income === '') {
        message = `You budgeted ${Utils.formatCurrency(totalBudgeted)}. Tip: Align it with your income.`;
      } else if (isApproximatelyEqual(budget.income, totalBudgeted)) {
        // Positive confirmation when budget matches income (with tolerance for floating point)
        message = `Your budget of ${Utils.formatCurrency(totalBudgeted)} perfectly matches your income!`;
        messageType = 'success';
      } else if (budget.income > totalBudgeted) {
        message = `You've budgeted ${Utils.formatCurrency(totalBudgeted)} with ${Utils.formatCurrency(Math.max(0, budget.income - totalBudgeted))} left to allocate.`;
        messageType = 'info';
      } else if (totalBudgeted > budget.income) {
        message = `You've budgeted ${Utils.formatCurrency(totalBudgeted)}, exceeding income by ${Utils.formatCurrency(totalBudgeted - budget.income)}.`;
        messageType = 'warning';
      }
      
      // Update the message element only if it changed or force is true
      if (force || currentMessage !== message) {
        // Trigger a reflow to ensure animation works properly
        infoMessageElement.style.opacity = '0.99';
        
        // Update content after a tiny delay to allow CSS transition
        setTimeout(() => {
          infoMessageElement.textContent = message;
          
          // Update the class based on the message type
          infoMessageElement.className = 'info-message';
          infoMessageElement.classList.add(messageType);
          
          // Restore opacity
          infoMessageElement.style.opacity = '1';
        }, 50);
      }
      
      // Show or hide the message container based on content
      if (message) {
        infoMessageElement.style.display = 'block';
      } else {
        infoMessageElement.style.display = 'none';
      }
      
      // Update cached budget data with new message
      const cachedBudget = _cache.get('budget');
      if (cachedBudget) {
        cachedBudget.infoMessage = message;
        _cache.set('budget', cachedBudget);
      }
    },
    
    /**
     * Load expense data
     */
    loadExpenseData: function() {
      const contentArea = document.getElementById('expenseContent');
      
      // Show loading state
      contentArea.innerHTML = '<div class="loading-spinner"></div>';
      
      API.getExpenseData(
        function(result) {
          // Cache the result
          _cache.set('expense', result.expenses);
          
          // Render the expenses
          SimBudget.renderExpenseView(result.expenses);
        },
        function(error) {
          contentArea.innerHTML = `
            <div class="error-message">
              <i class="material-icons">error</i>
              <span>Error loading expense data: ${error}</span>
            </div>
          `;
        }
      );
    },
    
    /**
     * Render expense view with provided data
     * @param {Array} expenses - Expense data to render
     */
    renderExpenseView: function(expenses) {
      const contentArea = document.getElementById('expenseContent');
      
      // Create expense list
      let html = `
        <div class="expense-controls">
          <div class="search-container">
            <input type="text" id="expenseSearch" placeholder="Search expenses...">
            <i class="material-icons">search</i>
          </div>
          <div class="filter-container">
            <select id="categoryFilter">
              <option value="">All Categories</option>
              <!-- Categories will be added dynamically -->
            </select>
            <select id="dateFilter">
              <option value="">All Dates</option>
              <option value="current-month">Current Month</option>
              <option value="last-month">Last Month</option>
              <option value="last-3-months">Last 3 Months</option>
              <option value="current-year">Current Year</option>
            </select>
          </div>
        </div>
        
        <div class="expense-list">
          <table class="expense-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Amount</th>
                <th>Category</th>
                <th>Description</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody>
      `;
      
      // Add rows for each expense
      if (expenses.length === 0) {
        html += `
          <tr>
            <td colspan="5" class="no-data">No expenses found</td>
          </tr>
        `;
      } else {
        expenses.forEach(function(expense) {
          html += `
            <tr data-row-index="${expense.rowIndex}">
              <td>${Utils.formatDate(expense.date)}</td>
              <td>${Utils.formatCurrency(expense.amount)}</td>
              <td>${expense.category}</td>
              <td>${expense.name}</td>
              <td>
                <button class="btn icon-btn edit-expense" data-id="${expense.rowIndex}">
                  <i class="material-icons">edit</i>
                </button>
                <button class="btn icon-btn delete-expense" data-id="${expense.rowIndex}">
                  <i class="material-icons">delete</i>
                </button>
              </td>
            </tr>
          `;
        });
      }
      
      html += `
            </tbody>
          </table>
        </div>
      `;
      
      // Update the expense content
      contentArea.innerHTML = html;
      
      // Set up the edit and delete buttons
      document.querySelectorAll('.edit-expense').forEach(button => {
        button.addEventListener('click', function() {
          const rowIndex = this.getAttribute('data-id');
          // TODO: Add edit expense functionality
          alert('Edit expense ' + rowIndex);
        });
      });
      
      document.querySelectorAll('.delete-expense').forEach(button => {
        button.addEventListener('click', function() {
          const rowIndex = this.getAttribute('data-id');
          // TODO: Add delete expense functionality
          alert('Delete expense ' + rowIndex);
        });
      });
      
      // Set up search functionality
      const searchInput = document.getElementById('expenseSearch');
      if (searchInput) {
        searchInput.addEventListener('input', Utils.debounce(function() {
          const searchValue = this.value.toLowerCase();
          document.querySelectorAll('.expense-table tbody tr').forEach(row => {
            if (row.classList.contains('no-data')) return;
            
            const text = row.textContent.toLowerCase();
            if (text.includes(searchValue)) {
              row.style.display = '';
            } else {
              row.style.display = 'none';
            }
          });
        }, 300));
      }
    }
  };
})();

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  if (typeof SimBudget !== 'undefined') {
    SimBudget.initialize();
  } else {
    console.error('SimBudget object not found. Initialization failed.');
  }
});
</script>