
<script>
/**
 * CategoriesManager - smart caching Architecture
 * Features:
 * - Preserves spreadsheet order
 * - Only fetches from spreadsheet on first load or manual refresh
 * - Toggles update immediately inshallah yani
 */

var CategoriesManager = (function() {
  // Private variables
  let _initialized = false;
  let _categories = [];
  let _isLoading = false;
  let _isSaving = false;
  
  // DOM element cache for performance
  const _elements = {};
  
  /**
   * Get an element by ID with caching
   * @param {string} id - Element ID
   * @return {HTMLElement} Element
   */
  function getElement(id) {
    if (!_elements[id]) {
      _elements[id] = document.getElementById(id);
    }
    return _elements[id];
  }
  
  /**
   * Initialize the Categories Manager
   * Checks cache first, at least it should, then spreadsheet if needed
   */
  function init() {
    console.log('CategoriesManager: Starting initialization...');
    
    if (_initialized && _categories.length > 0) {
      console.log('CategoriesManager: Already initialized, just rendering');
      renderCategories();
      return;
    }
    
    // Find container
    const container = getElement('categories-container');
    if (!container) {
      console.error('CategoriesManager: Container not found');
      return;
    }
    
    _elements['categories-container'] = container;
    
    // Show loading state
    showLoadingIndicator();
    
    //  Check timestamp changes first
    loadCategoriesWithTimestamp();

  }
  
  
/**
 * Load categories using timestamp-based caching
 */
function loadCategoriesWithTimestamp() {
  console.log('CategoriesManager: Loading categories with timestamp checking...');
  
  // Check CacheManager first
  const cachedData = window.CacheManager.getCategoriesWithTimestamp();
  
  if (cachedData && cachedData.categories && cachedData.timestamp) {
    console.log('CategoriesManager: Found cached categories, checking timestamp...');
    
    // We have cached data, now check if it's fresh
    checkTimestampAndLoad(cachedData);
  } else {
    console.log('CategoriesManager: No cached categories, fetching fresh...');
    
    // No cached data, fetch fresh from server
    fetchFreshCategories();
  }
}

/**
 * Check if cached data is fresh by comparing timestamps
 */
function checkTimestampAndLoad(cachedData) {
  API.getCategoriesWithTimestamp(
    function(result) {
      if (result && result.success) {
        const serverTimestamp = new Date(result.timestamp).getTime();
        const cachedTimestamp = new Date(cachedData.timestamp).getTime();
        
        console.log('CategoriesManager: Server timestamp:', result.timestamp);
        console.log('CategoriesManager: Cached timestamp:', cachedData.timestamp);
        
        if (serverTimestamp > cachedTimestamp) {
          console.log('CategoriesManager: Server data is newer, fetching fresh...');
          fetchFreshCategories();
        } else {
          console.log('CategoriesManager: Cached data is current, using cache...');
          useCachedCategories(cachedData);
        }
      } else {
        console.error('CategoriesManager: Error checking timestamp, using cache anyway');
        useCachedCategories(cachedData);
      }
    },
    function(error) {
      console.error('CategoriesManager: Error checking timestamp:', error);
      useCachedCategories(cachedData);
    }
  );
}

/**
 * Fetch fresh categories from server and cache them
 */
function fetchFreshCategories() {
  API.getCategoriesWithTimestamp(
    function(result) {
      if (result && result.success && result.categories) {
        console.log('CategoriesManager: Fresh categories loaded from server');
        
        // Server now returns processed categories - use them directly
        _categories = result.categories;
        
        // Cache the fresh data
        window.CacheManager.setCategoriesWithTimestamp(_categories, result.timestamp);
        
        // Render categories
        renderCategories();
        _initialized = true;
        hideLoadingIndicator();
        
      } else {
        console.error('CategoriesManager: Invalid server response:', result);
        showError(result ? result.error : 'Invalid response from server');
        hideLoadingIndicator();
      }
    },
    function(error) {
      console.error('CategoriesManager: Server error:', error);
      showError('Error loading from server: ' + error);
      hideLoadingIndicator();
    }
  );
}

/**
 * Use cached categories without server call
 */
function useCachedCategories(cachedData) {
  _categories = cachedData.categories;
  renderCategories();
  _initialized = true;
  hideLoadingIndicator();
}

 
  
  /**
   * Process categories from spreadsheet data
   * Preserves original order and creates proper structure
   * @param {Array} categories - Raw category data from spreadsheet
   * @param {Array} activeCategories - List of active category names
   * @return {Array} Processed categories with active state
   */
  function processCategories(categories, activeCategories) {
    console.log('CategoriesManager: Processing categories...', { categories, activeCategories });
    
    if (!Array.isArray(categories)) {
      console.error('CategoriesManager: Categories is not an array:', categories);
      return [];
    }
    
    // Ensure activeCategories is an array
    const activeList = Array.isArray(activeCategories) ? activeCategories : [];
    
    // Process each category and preserve order
    const processed = categories
      .filter(cat => typeof cat === 'string' && cat.trim() !== '')
      .map((categoryString, index) => {
        const parsed = parseCategoryNameAndEmoji(categoryString);
        
        return {
          id: parsed.name,           // Clean name as ID
          name: parsed.name,         // Clean name without emoji
          emoji: parsed.emoji,       // Extracted emoji
          fullName: categoryString,  // Original string with emoji
          active: activeList.includes(categoryString), // Check if active
          order: index              // Preserve spreadsheet order
        };
      });
    
    console.log('CategoriesManager: Processed categories:', processed);
    return processed;
  }
  

  

 

 /**
 * Toggle a category's active status
 * Updates spreadsheet, timestamp, and cache
 * @param {number} index - Index of the category to toggle
 * @param {boolean} active - New active status
 * @param {Function} successCallback - Called on success
 * @param {Function} errorCallback - Called on error
 */
function toggleCategory(index, active, successCallback, errorCallback) {
  console.log('CategoriesManager: Toggling category at index', index, 'to', active);
  
  if (_isSaving) {
    console.log('CategoriesManager: Already saving, please wait...');
    if (errorCallback) errorCallback('Already saving');
    return;
  }
  
  if (!_categories[index]) {
    console.error('CategoriesManager: Invalid category index:', index);
    if (errorCallback) errorCallback('Invalid category index');
    return;
  }
  
  // DEBUG: Show category details
  const category = _categories[index];
  console.log('CategoriesManager: Category details:', {
    name: category.name,
    fullName: category.fullName,
    currentActive: category.active,
    newActive: active
  });
  
  const oldActive = category.active;
  category.active = active;
  
  // Update UI immediately
  const card = document.querySelector(`.category-card[data-index="${index}"]`);
  console.log('CategoriesManager: Found card element:', !!card);
  if (card) {
    if (active) {
      card.classList.add('active');
    } else {
      card.classList.remove('active');
    }
    console.log('CategoriesManager: UI updated for card');
  }
  
  // Set saving flag
  _isSaving = true;
  
  // DEBUG: Check API availability
  console.log('CategoriesManager: Checking API availability...');
  console.log('CategoriesManager: window.API exists:', !!window.API);
  console.log('CategoriesManager: updateCategoryStatus exists:', !!(window.API && typeof API.updateCategoryStatus === 'function'));
  
  if (!window.API || typeof API.updateCategoryStatus !== 'function') {
    console.error('CategoriesManager: API.updateCategoryStatus not available');
    category.active = oldActive;
    _isSaving = false;
    if (errorCallback) errorCallback('API not available');
    return;
  }
  
  console.log('CategoriesManager: Calling API.updateCategoryStatus with:', category.name, active);
  
  console.log('CategoriesManager: Calling API.updateCategoryStatus with:', category.fullName, active);

API.updateCategoryStatus(
  category.fullName, // Make sure this is fullName not name
  active,
  function(result) {
  console.log('CategoriesManager: SUCCESS CALLBACK FIRED - Result:', result);
  console.log('CategoriesManager: Result type:', typeof result);
  console.log('CategoriesManager: Result success:', result?.success);
  
  if (result && result.success) {
    console.log('CategoriesManager: Category status updated in spreadsheet');
    
    // 🚀 Update server timestamp since categories changed
    console.log('CategoriesManager: Updating categories timestamp...');
    API.updateCategoriesTimestamp(
      function(timestampResult) {
        console.log('CategoriesManager: SUCCESS - Categories timestamp updated:', timestampResult);
        
        // Update CacheManager cache with new UTC timestamp
        const newTimestamp = timestampResult.timestamp || new Date().toISOString();
        window.CacheManager.setCategoriesWithTimestamp(_categories, newTimestamp);
        console.log('CategoriesManager: Cache updated with timestamp:', newTimestamp);

                // 🚀 ADD THIS: Broadcast to other tabs
        console.log('CategoriesManager: Broadcasting category change to other tabs');
        localStorage.setItem('simbudget-categories-changed', JSON.stringify({
          timestamp: Date.now(),
          categories: _categories,
          changedCategory: category.name,
          newActiveStatus: active
        }));
        
      },
      function(timestampError) {
        console.warn('CategoriesManager: ERROR - Failed to update timestamp:', timestampError);
        // Update cache with current UTC timestamp as fallback
        const fallbackTimestamp = new Date().toISOString();
        window.CacheManager.setCategoriesWithTimestamp(_categories, fallbackTimestamp);
        console.log('CategoriesManager: Cache updated with fallback timestamp:', fallbackTimestamp);
      }
    );
    
    // Update QuickExpenseEntry dropdown
    updateQuickExpenseDropdown();
    
    // Broadcast notifications
    if (window.notifyMonthlyGridOfCategoryChange) {
      notifyMonthlyGridOfCategoryChange();
    }
    
    if (window.notifyDashboardOfCategoryChange) {
      notifyDashboardOfCategoryChange();
    }
    
    document.dispatchEvent(new CustomEvent('categories-changed', {
      detail: { 
        changedCategory: category.name,
        newActiveStatus: active,
        allCategories: _categories
      }
    }));
    
  } else {
    console.log('CategoriesManager: Server returned success=false:', result?.error);
  }
  
  _isSaving = false;
  if (successCallback) successCallback(result);
},
  function(error) {
    console.log('CategoriesManager: ERROR CALLBACK FIRED - Error:', error);
    console.log('CategoriesManager: Error type:', typeof error);
    
    // Revert changes
    category.active = oldActive;
    if (card) {
      if (oldActive) {
        card.classList.add('active');
      } else {
        card.classList.remove('active');
      }
    }
    
    _isSaving = false;
    if (errorCallback) errorCallback(error);
  }
);
}



  
/**
 * Refresh categories from spreadsheet
 * Forces fresh fetch bypassing cache and timestamp checks
 */
function refreshCategories() {
  console.log('CategoriesManager: Manual refresh triggered');
  
  if (_isLoading || _isSaving) {
    console.log('CategoriesManager: Already loading/saving, skipping refresh');
    return;
  }
  
  // Clear existing data
  _categories = [];
  _initialized = false;
  
  // Clear CacheManager cache to force fresh fetch
  if (window.CacheManager && typeof CacheManager.invalidate === 'function') {
    console.log('CategoriesManager: Clearing CacheManager cache');
    CacheManager.invalidate('categories_with_timestamp');
  }
  
  // Show loading indicator
  showLoadingIndicator();
  
  // Force fresh fetch from server (bypass timestamp checking)
  console.log('CategoriesManager: Forcing fresh fetch from server');
  fetchFreshCategories();
}
  
  /**
   * Render categories to the UI
   */
  function renderCategories() {
    console.log('CategoriesManager: Rendering categories...', _categories.length);
    
    const container = getElement('categories-container');
    if (!container) {
      console.error('CategoriesManager: Categories container not found');
      return;
    }
    
    // Clear existing content
    container.innerHTML = '';
    
    // If no categories to render, show message
    if (!_categories || _categories.length === 0) {
      container.innerHTML = '<div class="categories-message">No categories found</div>';
      return;
    }
    
    // Create grid container
    const grid = document.createElement('div');
    grid.className = 'categories-grid';
    
    // Create cards for each category (preserve order)
    _categories
      .sort((a, b) => (a.order || 0) - (b.order || 0)) // Sort by original spreadsheet order
      .forEach((category, index) => {
        const card = createCategoryCard(category, index);
        grid.appendChild(card);
      });
    
    // Add grid to container
    container.appendChild(grid);
  }
  
/**
 * Robust emoji validation function that works across all browsers
 * @param {string} text - Text to validate
 * @return {boolean} True if it's a valid emoji
 */
function isValidEmoji(text) {
  if (!text || text.length === 0) return false;
  
  // Method 1: Comprehensive regex for most common emoji ranges
  const emojiRegex = /^[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F700}-\u{1F77F}]|[\u{1F780}-\u{1F7FF}]|[\u{1F800}-\u{1F8FF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA00}-\u{1FA6F}]|[\u{1FA70}-\u{1FAFF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{2300}-\u{23FF}]|[\u{2B00}-\u{2BFF}]|[\u{25A0}-\u{25FF}]|[\u{2190}-\u{21FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{3030}]|[\u{303D}]|[\u{3297}]|[\u{3299}]|[\u{24C2}]|[\u{1F004}]|[\u{1F0CF}]|[\u{1F18E}]$/u;
  
  if (emojiRegex.test(text)) return true;
  
  // Method 2: Check for variation selector (like ▶️)
  if (text.length === 2 && text.charCodeAt(1) === 0xFE0F) {
    return true;
  }
  
  // Method 3: Basic heuristic - single character that's not alphanumeric or common punctuation
  if (text.length === 1) {
    const char = text.charCodeAt(0);
    // Exclude basic ASCII alphanumeric and common punctuation
    if (char > 127 && // Non-ASCII
        !/[a-zA-Z0-9\s.,!?;:'"()\-_]/.test(text)) {
      return true;
    }
  }
  
  // Method 4: Check if it's a multi-character emoji sequence (like flag emojis)
  if (text.length >= 2 && text.length <= 8) {
    // Contains high surrogate pairs (emoji territory)
    for (let i = 0; i < text.length; i++) {
      const char = text.charCodeAt(i);
      if (char >= 0xD800 && char <= 0xDFFF) { // Surrogate pairs
        return true;
      }
    }
  }
  
  return false;
}

/**
 * Robust emoji validation function that works across all browsers
 * @param {string} text - Text to validate
 * @return {boolean} True if it's a valid emoji
 */
function isValidEmoji(text) {
  if (!text || text.length === 0) return false;
  
  // Method 1: Comprehensive regex for most common emoji ranges
  const emojiRegex = /^[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F700}-\u{1F77F}]|[\u{1F780}-\u{1F7FF}]|[\u{1F800}-\u{1F8FF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA00}-\u{1FA6F}]|[\u{1FA70}-\u{1FAFF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{2300}-\u{23FF}]|[\u{2B00}-\u{2BFF}]|[\u{25A0}-\u{25FF}]|[\u{2190}-\u{21FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{3030}]|[\u{303D}]|[\u{3297}]|[\u{3299}]|[\u{24C2}]|[\u{1F004}]|[\u{1F0CF}]|[\u{1F18E}]$/u;
  
  if (emojiRegex.test(text)) return true;
  
  // Method 2: Check for variation selector (like ▶️)
  if (text.length === 2 && text.charCodeAt(1) === 0xFE0F) {
    return true;
  }
  
  // Method 3: Basic heuristic - single character that's not alphanumeric or common punctuation
  if (text.length === 1) {
    const char = text.charCodeAt(0);
    // Exclude basic ASCII alphanumeric and common punctuation
    if (char > 127 && // Non-ASCII
        !/[a-zA-Z0-9\s.,!?;:'"()\-_]/.test(text)) {
      return true;
    }
  }
  
  // Method 4: Check if it's a multi-character emoji sequence (like flag emojis)
  if (text.length >= 2 && text.length <= 8) {
    // Contains high surrogate pairs (emoji territory)
    for (let i = 0; i < text.length; i++) {
      const char = text.charCodeAt(i);
      if (char >= 0xD800 && char <= 0xDFFF) { // Surrogate pairs
        return true;
      }
    }
  }
  
  return false;
}

/**
 * Create a category card element with inline editing
 * @param {Object} category - Category data
 * @param {number} index - Index in the array
 * @return {HTMLElement} Card element
 */
function createCategoryCard(category, index) {
  const card = document.createElement('div');
  card.className = 'category-card';
  card.dataset.index = index;
  
  // Set active class if category is active
  if (category.active) {
    card.classList.add('active');
  }
  
  // Create checkbox for active toggle
  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.className = 'category-toggle';
  checkbox.checked = category.active;
  checkbox.id = `category-toggle-${index}`;
  
  // Add saving indicator
  const savingIndicator = document.createElement('div');
  savingIndicator.className = 'saving-indicator';
  savingIndicator.innerHTML = '<div class="spinner"></div>';
  savingIndicator.style.display = 'none';
  
  // Add change listener for active/inactive toggle
  checkbox.addEventListener('change', function() {
    // Show saving indicator
    savingIndicator.style.display = 'inline-block';
    this.disabled = true;
    
    // Toggle the category
    toggleCategory(index, this.checked, function() {
      // On success, hide indicator and re-enable checkbox
      savingIndicator.style.display = 'none';
      checkbox.disabled = false;
    }, function() {
      // On error, revert the checkbox and show error
      checkbox.checked = !checkbox.checked;
      savingIndicator.style.display = 'none';
      checkbox.disabled = false;
      
      // Flash the card red to indicate error
      card.classList.add('save-error');
      setTimeout(function() {
        card.classList.remove('save-error');
      }, 1000);
    });
  });
  
  // AWESOMICO: Create clickable emoji
  const emojiSpan = document.createElement('span');
  emojiSpan.className = 'category-emoji clickable-emoji';
  emojiSpan.textContent = category.emoji || '📝';
  emojiSpan.title = 'Click to change emoji';
  
  // Emoji click handler
  emojiSpan.addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    startEmojiEdit(index, emojiSpan);
  });
  
  // AWESOMICO: Create clickable category name
  const nameSpan = document.createElement('span');
  nameSpan.className = 'category-name-cat clickable-name';
  nameSpan.textContent = category.name;
  nameSpan.title = 'Click to rename category';
  
  // Name click handler  
  nameSpan.addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    startNameEdit(index, nameSpan);
  });
  
  // Create label container (NOT a label element to avoid checkbox issues)
  const labelContainer = document.createElement('div');
  labelContainer.className = 'category-label-container';
  
  // Append emoji and name to container
  labelContainer.appendChild(emojiSpan);
  labelContainer.appendChild(document.createTextNode(' ')); // Space between emoji and name
  labelContainer.appendChild(nameSpan);
  
  // Append elements to card
  card.appendChild(checkbox);
  card.appendChild(savingIndicator);
  card.appendChild(labelContainer);
  
  return card;
}

/**
 * Start emoji editing using contenteditable (cross-platform reliable)
 * @param {number} index - Category index
 * @param {HTMLElement} emojiElement - The emoji span element
 */
function startEmojiEdit(index, emojiElement) {
  console.log('CategoriesManager: Starting emoji edit for index', index);
  
  // Create contenteditable div for emoji input
  const editableDiv = document.createElement('div');
  editableDiv.contentEditable = true;
  editableDiv.className = 'emoji-editor';
  editableDiv.setAttribute('data-placeholder', '😊');
  
  // Position near the clicked emoji
  const rect = emojiElement.getBoundingClientRect();
  editableDiv.style.position = 'absolute';
  editableDiv.style.left = rect.left + 'px';
  editableDiv.style.top = (rect.bottom + 5) + 'px';
  editableDiv.style.width = '40px';
  editableDiv.style.height = '30px';
  editableDiv.style.fontSize = '20px';
  editableDiv.style.border = '2px solid #3498db';
  editableDiv.style.borderRadius = '4px';
  editableDiv.style.textAlign = 'center';
  editableDiv.style.background = 'white';
  editableDiv.style.zIndex = '9999';
  editableDiv.style.outline = 'none';
  editableDiv.style.display = 'flex';
  editableDiv.style.alignItems = 'center';
  editableDiv.style.justifyContent = 'center';
  editableDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
  
  // Add to document with helpful hint
  document.body.appendChild(editableDiv);
  
  // Show keyboard shortcut hint
  const hint = document.createElement('div');
  hint.className = 'emoji-keyboard-hint';
  hint.style.position = 'absolute';
  hint.style.left = rect.left + 'px';
  hint.style.top = (rect.bottom + 40) + 'px';
  hint.style.fontSize = '11px';
  hint.style.background = 'rgba(0,0,0,0.8)';
  hint.style.color = 'white';
  hint.style.padding = '4px 8px';
  hint.style.borderRadius = '4px';
  hint.style.zIndex = '9998';
  hint.style.whiteSpace = 'nowrap';
  
  // Detect platform for correct shortcut
  const isMac = /Mac/.test(navigator.platform);
  const isWindows = /Win/.test(navigator.platform);
  
  if (isMac) {
    hint.textContent = '⌘+Ctrl+Space for emoji keyboard';
  } else if (isWindows) {
    hint.textContent = 'Win+. or Win+; for emoji keyboard';
  } else {
    hint.textContent = 'Use your device\'s emoji keyboard';
  }
  
  document.body.appendChild(hint);
  
  // Remove hint after 3 seconds
  setTimeout(() => {
    if (document.body.contains(hint)) {
      hint.remove();
    }
  }, 3000);
  
  // Focus and position cursor
  editableDiv.focus();
  
  // Force cursor to end and select all content
  setTimeout(() => {
    const range = document.createRange();
    range.selectNodeContents(editableDiv);
    range.collapse(false);
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
  }, 10);
  
  // Handle emoji input with robust validation
  editableDiv.addEventListener('input', function() {
    const text = this.textContent.trim();
    
    if (text && text !== '😊') {
      // Check if input is a valid emoji using multiple methods
      if (isValidEmoji(text)) {
        // Valid emoji - update and save
        emojiElement.textContent = text;
        saveEmojiUpdate(index, text);
        this.remove();
        if (document.body.contains(hint)) {
          hint.remove();
        }
      } else {
        // Invalid input - clear and show feedback
        this.textContent = '';
        this.style.borderColor = '#e74c3c';
        this.setAttribute('data-placeholder', '😊 Only emojis!');
        
        // Reset border color after 1 second
        setTimeout(() => {
          this.style.borderColor = '#3498db';
          this.setAttribute('data-placeholder', '😊');
        }, 1000);
      }
    }
  });
  
  // Handle Enter key to confirm with robust validation
  editableDiv.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      const text = this.textContent.trim();
      
      if (text && isValidEmoji(text) && text !== emojiElement.textContent) {
        emojiElement.textContent = text;
        saveEmojiUpdate(index, text);
      }
      this.remove();
      if (document.body.contains(hint)) {
        hint.remove();
      }
    } else if (e.key === 'Escape') {
      e.preventDefault();
      this.remove();
      if (document.body.contains(hint)) {
        hint.remove();
      }
    }
  });
  
  // Clean up on blur
  editableDiv.addEventListener('blur', function() {
    setTimeout(() => {
      if (document.body.contains(this)) {
        this.remove();
      }
      if (document.body.contains(hint)) {
        hint.remove();
      }
    }, 150);
  });
  
  // Close on outside click
  setTimeout(() => {
    document.addEventListener('click', function closeHandler(e) {
      if (!editableDiv.contains(e.target) && e.target !== emojiElement) {
        editableDiv.remove();
        if (document.body.contains(hint)) {
          hint.remove();
        }
        document.removeEventListener('click', closeHandler);
      }
    });
  }, 100);
}

/**
 * Start name editing with inline input
 * @param {number} index - Category index  
 * @param {HTMLElement} nameElement - The name span element
 */
function startNameEdit(index, nameElement) {
  console.log('CategoriesManager: Starting name edit for index', index);
  
  const originalName = nameElement.textContent;
  
  // Create input field
  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'category-name-input';
  input.value = originalName;
  
  // Replace span with input
  nameElement.style.display = 'none';
  nameElement.parentNode.insertBefore(input, nameElement);
  
  // Focus and select
  input.focus();
  input.select();
  
  // Save function
  function saveName() {
    const newName = input.value.trim();
    
    if (!newName) {
      // Revert if empty
      revertNameEdit();
      return;
    }
    
    if (newName === originalName) {
      // No change, just revert
      revertNameEdit();
      return;
    }
    
    // Update UI immediately
    nameElement.textContent = newName;
    
    // Save to server
    saveNameUpdate(index, newName);
    
    // Clean up
    input.remove();
    nameElement.style.display = '';
  }
  
  // Revert function
  function revertNameEdit() {
    input.remove();
    nameElement.style.display = '';
  }
  
  // Event listeners
  input.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      saveName();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      revertNameEdit();
    }
  });
  
  input.addEventListener('blur', function() {
    // Small delay to allow other clicks to register
    setTimeout(saveName, 100);
  });
}

/**
 * Save emoji update to server
 * @param {number} index - Category index
 * @param {string} newEmoji - New emoji
 */
function saveEmojiUpdate(index, newEmoji) {
  const category = _categories[index];
  if (!category) return;
  
  console.log('CategoriesManager: Saving emoji update:', category.name, '→', newEmoji);
  
  const newFullName = `${category.name} ${newEmoji}`;
  
  // Update local data
  category.emoji = newEmoji;
  category.fullName = newFullName;
  
  // Save to server
  if (window.API && typeof API.updateCategoryName === 'function') {
    API.updateCategoryName(
      category.fullName, // old full name (will be different now, but server can handle)
      category.name,
      newEmoji,
      function(result) {
        console.log('CategoriesManager: Emoji update successful');
        
        // Update cache and notify other components
        if (window.CacheManager) {
          CacheManager.setCategoriesWithTimestamp(_categories, new Date().toISOString());
        }
        
        // Broadcast change
        document.dispatchEvent(new CustomEvent('categories-changed', {
          detail: { 
            changedCategory: category.name,
            newEmoji: newEmoji,
            allCategories: _categories
          }
        }));
      },
      function(error) {
        console.error('CategoriesManager: Error saving emoji:', error);
        // Could revert UI here if needed
      }
    );
  }
}

/**
 * Save name update to server
 * @param {number} index - Category index
 * @param {string} newName - New category name
 */
function saveNameUpdate(index, newName) {
  const category = _categories[index];
  if (!category) return;
  
  console.log('CategoriesManager: Saving name update:', category.name, '→', newName);
  
  const oldFullName = category.fullName;
  const newFullName = `${newName} ${category.emoji}`;
  
  // Update local data
  category.name = newName;
  category.fullName = newFullName;
  
  // Save to server
  if (window.API && typeof API.updateCategoryName === 'function') {
    API.updateCategoryName(
      oldFullName,
      newName,
      category.emoji,
      function(result) {
        console.log('CategoriesManager: Name update successful');
        
        // Update cache and notify other components
        if (window.CacheManager) {
          CacheManager.setCategoriesWithTimestamp(_categories, new Date().toISOString());
        }
        
        // Broadcast change
        document.dispatchEvent(new CustomEvent('categories-changed', {
          detail: { 
            changedCategory: newName,
            oldName: category.name,
            allCategories: _categories
          }
        }));
      },
      function(error) {
        console.error('CategoriesManager: Error saving name:', error);
        // Could revert UI here if needed
      }
    );
  }
}
  
  /**
   * Update the quick expense dropdown to show only active categories
   */
  function updateQuickExpenseDropdown() {
    
    // Find the expense category dropdown
    const expenseCategoryDropdown = document.getElementById('expenseCategory');
    if (!expenseCategoryDropdown) {
      console.log('CategoriesManager: Quick expense dropdown not found');
      return;
    }
    
    // Get only active categories
    const activeCategories = _categories
      .filter(cat => cat.active)
      .sort((a, b) => (a.order || 0) - (b.order || 0)) // Preserve spreadsheet order
      .map(cat => cat.fullName); // Use full name with emoji
    
    // Save current selection if any
    const currentSelection = expenseCategoryDropdown.value;
    
    // Clear existing options
    expenseCategoryDropdown.innerHTML = '';
    
    // Add active categories as options
    activeCategories.forEach(category => {
      const option = document.createElement('option');
      option.value = category;
      option.textContent = category;
      expenseCategoryDropdown.appendChild(option);
    });
    
    // Restore selection if it exists and is still active
    if (currentSelection && activeCategories.includes(currentSelection)) {
      expenseCategoryDropdown.value = currentSelection;
    } else if (activeCategories.length > 0) {
      // Otherwise select first option
      expenseCategoryDropdown.value = activeCategories[0];
    }
    
    console.log('CategoriesManager: Updated dropdown with', activeCategories.length, 'active categories');
  }
  
  /**
   * Show loading indicator
   */
  function showLoadingIndicator() {
    const container = getElement('categories-container');
    if (container) {
      container.innerHTML = '<div class="categories-loading"><div class="loading-spinner"></div><p>Loading categories...</p></div>';
    }
  }
  
  /**
   * Hide loading indicator
   */
  function hideLoadingIndicator() {
    const loadingEl = document.querySelector('.categories-loading');
    if (loadingEl) {
      loadingEl.remove();
    }
  }
  
  /**
   * Show error message
   * @param {string} message - Error message to display
   */
  function showError(message) {
    const container = getElement('categories-container');
    if (container) {
      container.innerHTML = `<div class="categories-error"><i class="material-icons">error</i><p>${message}</p></div>`;
    }
  }
  
  // Public API
  return {
    init: init,
    refreshCategories: refreshCategories,
    updateQuickExpenseDropdown: updateQuickExpenseDropdown,
    
    // Expose for debugging
    getCategories: function() { return _categories; },
    isInitialized: function() { return _initialized; }
  };
})();

// Expose globally
window.CategoriesManager = CategoriesManager;

// Global function for updating all category dropdowns
window.updateAllCategoryDropdowns = function() {
  console.log('Updating all category dropdowns');
  
  if (window.CategoriesManager && typeof CategoriesManager.updateQuickExpenseDropdown === 'function') {
    CategoriesManager.updateQuickExpenseDropdown();
  }
  
  // Update QuickExpenseEntry if available
  if (window.QuickExpenseEntry && typeof QuickExpenseEntry.ensureCategoriesLoaded === 'function') {
    const activeCategories = CategoriesManager.getCategories().filter(cat => cat.active);
    QuickExpenseEntry.ensureCategoriesLoaded(activeCategories);
  }
};

</script>

<style>
/* ======================================================
   CATEGORIES MANAGEMENT STYLES - ENHANCED VERSION
   ======================================================
   3-column grid layout with saving indicators
*/

/* Container for categories */
.categories-container {
  width: 100%;
  padding: 8px;
  box-sizing: border-box;
}

/* Categories grid layout - CONSISTENT 3 COLUMNS */
.categories-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* Always 3 columns as requested */
  gap: 8px;
  width: 100%;
}

/* Individual category card */
.category-card {
  display: flex;
  align-items: center;
  padding: 8px;
  background-color: #f0f0f0;
  border-radius: 6px;
  transition: background-color 0.2s ease, border-color 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Active category style */
.category-card.active {
  background-color: #fff9e0;
  border-left: 3px solid #ffc107;
}

/* Error state - flash red briefly */
.category-card.save-error {
  background-color: #ffebee;
  border-color: #f44336;
}

/* Category toggle checkbox */
.category-toggle {
  margin-right: 6px;
  width: 16px;
  height: 16px;
  cursor: pointer;
}

/* Saving indicator */
.saving-indicator {
  width: 16px;
  height: 16px;
  margin-right: 6px;
  position: relative;
}

.saving-indicator .spinner {
  width: 12px;
  height: 12px;
  border: 2px solid rgba(169, 99, 34, 0.3);
  border-top-color: #a96322;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  position: absolute;
  top: 0;
  left: 0;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Category name label */
.category-name-cat {
  font-size: 14px;
  font-weight: 500;
  flex: 1;
  cursor: pointer;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Loading indicator */
.categories-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  width: 100%;
}

.categories-loading p {
  margin-top: 8px;
  font-size: 14px;
  color: #666;
}

/* Error display */
.categories-error {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
  background-color: #ffebee;
  border-radius: 6px;
  color: #c62828;
  margin: 8px 0;
}

.categories-error i {
  margin-right: 6px;
  font-size: 20px;
}

/* Hide category counts element completely */
.category-counts {
  display: none !important;
}

/* Container for category-counts (parent element) should also not take up space */
.categories-header {
  display: none !important;
}

/* No categories message */
.categories-message {
  text-align: center;
  padding: 20px;
  color: #666;
  font-size: 14px;
}

/* Dark mode styles */
body.dark-mode .category-card {
  background-color: #333333;
  color: #f1f1f1;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

body.dark-mode .category-card.active {
  background-color: #423d24;
  border-left: 3px solid #ffd866;
}

body.dark-mode .category-card.save-error {
  background-color: #4a1f1f;
  border-color: #e57373;
}

body.dark-mode .category-name-cat {
  color: #ffffff;
}

body.dark-mode .categories-loading p {
  color: #aaaaaa;
}

body.dark-mode .categories-message {
  color: #aaaaaa;
}

body.dark-mode .saving-indicator .spinner {
  border-color: rgba(255, 209, 102, 0.3);
  border-top-color: #ffd166;
}

/* Responsive design for very small screens only */
@media (max-width: 480px) {
  .categories-grid {
    grid-template-columns: repeat(2, 1fr); /* 2 columns only on very small screens */
  }
  
  .category-card {
    padding: 6px;
  }
  
  .category-name-cat {
    font-size: 12px;
  }
}

/* Extra small screens */
@media (max-width: 320px) {
  .categories-grid {
    grid-template-columns: 1fr; /* 1 column on tiny screens */
  }
}


/* AWESOMICO: Clickable category elements */
.clickable-emoji, .clickable-name {
  cursor: pointer;
  transition: background-color 0.2s ease, transform 0.1s ease;
  border-radius: 3px;
  padding: 2px 4px;
  margin: -2px -4px; /* Offset padding for consistent spacing */
}

.clickable-emoji:hover, .clickable-name:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.clickable-emoji:active, .clickable-name:active {
  transform: scale(0.95);
}

/* Dark mode hover states */
body.dark-mode .clickable-emoji:hover, 
body.dark-mode .clickable-name:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

/* Category name input for inline editing */
.category-name-input {
  background: white;
  border: 2px solid #2c3e50;
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 14px;
  font-weight: 500;
  font-family: inherit;
  outline: none;
  min-width: 120px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.category-name-input:focus {
  border-color: #3498db;
  box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
}

/* Dark mode input styles */
body.dark-mode .category-name-input {
  background: #2c2c2c;
  border-color: #DDA15E;
  color: white;
}

body.dark-mode .category-name-input:focus {
  border-color: #ffd866;
  box-shadow: 0 2px 8px rgba(255, 216, 102, 0.3);
}

/* AWESOMICO: Emoji editor using contenteditable */
.emoji-editor {
  position: absolute !important;
  width: 40px !important;
  height: 30px !important;
  font-size: 20px !important;
  border: 2px solid #3498db !important;
  border-radius: 4px !important;
  text-align: center !important;
  background: white !important;
  z-index: 9999 !important;
  outline: none !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2) !important;
  cursor: text !important;
  transition: border-color 0.3s ease !important;
}

.emoji-editor:focus {
  border-color: #2980b9 !important;
  box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4) !important;
}

.emoji-editor:empty:before {
  content: attr(data-placeholder);
  color: #bdc3c7;
  font-style: italic;
  font-size: 12px;
  white-space: nowrap;
}

/* Error state for invalid input */
.emoji-editor[style*="border-color: rgb(231, 76, 60)"] {
  animation: shake 0.5s ease-in-out;
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-3px); }
  75% { transform: translateX(3px); }
}

/* Dark mode emoji editor */
body.dark-mode .emoji-editor {
  background: #2c2c2c !important;
  border-color: #DDA15E !important;
  color: white !important;
}

body.dark-mode .emoji-editor:focus {
  border-color: #ffd866 !important;
  box-shadow: 0 2px 8px rgba(255, 216, 102, 0.4) !important;
}

/* Keyboard shortcut hint */
.emoji-keyboard-hint {
  position: absolute !important;
  font-size: 11px !important;
  background: rgba(0,0,0,0.8) !important;
  color: white !important;
  padding: 4px 8px !important;
  border-radius: 4px !important;
  z-index: 9998 !important;
  white-space: nowrap !important;
  pointer-events: none !important;
  animation: fadeInOut 3s ease-in-out !important;
}

@keyframes fadeInOut {
  0% { opacity: 0; transform: translateY(5px); }
  20%, 80% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-5px); }
}

/* Dark mode hint */
body.dark-mode .emoji-keyboard-hint {
  background: rgba(255,255,255,0.9) !important;
  color: #2c2c2c !important;
}

body.dark-mode .emoji-editor:empty:before {
  color: #7f8c8d;
}

/* Enhanced label container for better layout */
.category-label-container {
  display: flex;
  align-items: center;
  flex: 1;
  cursor: inherit;
}

/* Ensure emojis don't break layout */
.clickable-emoji {
  display: inline-block;
  min-width: 20px;
  text-align: center;
}

/* Visual feedback for editing states */
.category-card.editing {
  box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
  border-left: 3px solid #3498db;
}

/* Smooth transitions for all interactive elements */
.category-card * {
  transition: all 0.2s ease;
}

/* Better visual hierarchy */
.clickable-name {
  font-weight: 500;
}

.category-card.active .clickable-name {
  font-weight: 600;
}

/* Mobile-friendly touch targets */
@media (max-width: 768px) {
  .clickable-emoji, .clickable-name {
    padding: 6px 8px;
    margin: -6px -8px;
    min-height: 32px; /* Ensure good touch target size */
    display: inline-flex;
    align-items: center;
  }
  
  .category-name-input {
    font-size: 16px; /* Prevent zoom on iOS */
    padding: 8px 12px;
    min-width: 140px;
  }
}
</style>