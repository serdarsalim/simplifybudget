<script>
/**
 * CacheManager - Unified caching system for SimBudget
 * Merges Init cache + CacheManager + Preloader into one predictable system
 * 
 * Key principles:
 * 1. Simple TTLs (2 min for data, 30 min for settings)
 * 2. Aggressive invalidation on writes
 * 3. Background preloading for better UX
 * 4. No localStorage - just memory cache for simplicity
 */
const CacheManager = (function() {
  // Cache storage
  const cache = {
    data: {},
    metadata: {},
  };
  
  // Configuration
  const config = {
    ttl: {
      shortLived: 2 * 60 * 1000,    // 2 minutes for expenses, dashboard
      mediumLived: 10 * 60 * 1000,  // 10 minutes for budget data
      longLived: 30 * 60 * 1000,     // 30 minutes for categories, settings
    },
    preloadDelay: 1000,              // Wait 1 second before preloading
    preloadInterval: 2000,           // 2 seconds between preloads
  };
  
  // Track current month/year
  let currentMonth = new Date().getMonth();
  let currentYear = new Date().getFullYear();
  
  // Preloader state
  const preloader = {
    queue: [],
    isRunning: false,
    hasRunInSession: false,
  };
  
  // Cache invalidation relationships (from Init)
  const relationships = {
    budget: ["reports", "dashboard"],
    expense: ["budget", "reports", "dashboard"],
    income: ["budget", "reports", "dashboard"],
    recurring: ["reports", "dashboard"],
    netWorth: ["reports"],
    categories: ["dashboard"],
  };

  /**
   * Core cache operations
   */
  
  // Set data in cache
  function set(key, data, options = {}) {
    const ttl = options.ttl || config.ttl.shortLived;
    
    cache.data[key] = data;
    cache.metadata[key] = {
      timestamp: Date.now(),
      expires: Date.now() + ttl,
    };
    
    return true;
  }
  
  // Get data from cache
  function get(key) {
    const meta = cache.metadata[key];
    
    if (!meta || !cache.data[key]) {
      return null;
    }
    
    // Check if expired
    if (Date.now() > meta.expires) {
      invalidate(key);
      return null;
    }
    
    return cache.data[key];
  }
  
  // Check if cache is valid
  function isValid(key) {
    return get(key) !== null;
  }
  
  // Invalidate cache and related data
  function invalidate(key) {
    delete cache.data[key];
    delete cache.metadata[key];
    
    // Don't invalidate during rendering (from Init logic)
    if (window._isRendering) {
      return;
    }
    
    // Invalidate related keys
    if (relationships[key]) {
      relationships[key].forEach(relatedKey => {
        invalidate(relatedKey);
      });
    }
  }
  
  // Invalidate all cache
  function invalidateAll() {
    if (window._isRendering) {
      return;
    }
    
    Object.keys(cache.data).forEach(key => {
      delete cache.data[key];
      delete cache.metadata[key];
    });
  }
  
  // Clear specific month data
  function clearMonth(month, year) {
    const monthKey = `${year}-${month}`;
    
    Object.keys(cache.data).forEach(key => {
      if (key.includes(monthKey)) {
        invalidate(key);
      }
    });
    
    // Also clear dashboard for that month
    invalidate(`dashboard_${monthKey}`);
  }

  /**
   * Budget-specific helpers (from old CacheManager)
   */
  
  // Expenses
  function getExpenses(month = currentMonth, year = currentYear) {
    return get(`expenses_${year}-${month}`);
  }
  
  function setExpenses(expenses, month = currentMonth, year = currentYear) {
    set(`expenses_${year}-${month}`, expenses, { ttl: config.ttl.shortLived });
    // Invalidate dashboard when expenses change
    invalidate(`dashboard_${year}-${month}`);
  }
  
  // Dashboard
  function getDashboardData(month = currentMonth, year = currentYear) {
    // First check if we have cached dashboard
    const cached = get(`dashboard_${year}-${month}`);
    if (cached) return cached;
    
    // If not, try to calculate from components
    const expenses = getExpenses(month, year);
    const recurring = getRecurring();
    const budgetData = getBudgetData();
    const categories = getCategories();
    
    if (expenses && recurring && budgetData && categories) {
      const calculated = calculateDashboardData(expenses, recurring, month, year);
      // Cache the calculated result
      set(`dashboard_${year}-${month}`, calculated, { ttl: config.ttl.shortLived });
      return calculated;
    }
    
    return null;
  }
  
  // Budget data
  function getBudgetData() {
    return get('budgetData');
  }
  
  function setBudgetData(data) {
    set('budgetData', data, { ttl: config.ttl.mediumLived });
    // Invalidate all dashboards when budget changes
    Object.keys(cache.data).forEach(key => {
      if (key.startsWith('dashboard_')) {
        invalidate(key);
      }
    });
  }
  
  // Categories
  function getCategories() {
    return get('categories');
  }
  
  function setCategories(categories) {
    set('categories', categories, { ttl: config.ttl.longLived });
    invalidateRelated('categories');
  }
  
  // Recurring
  function getRecurring() {
    return get('recurring');
  }
  
  function setRecurring(recurring) {
    set('recurring', recurring, { ttl: config.ttl.mediumLived });
    // Invalidate all dashboards when recurring changes
    Object.keys(cache.data).forEach(key => {
      if (key.startsWith('dashboard_')) {
        invalidate(key);
      }
    });
  }
  
  // Settings
  function getSettings() {
    return get('settings');
  }
  
  function setSettings(settings) {
    set('settings', settings, { ttl: config.ttl.longLived });
  }

  /**
   * Calculate dashboard data (from old CacheManager - PRESERVED EXACTLY)
   */
  function calculateDashboardData(expenses, recurring, month, year) {
    // Get budget data for this month
    const monthlyBudget = getBudgetForMonth(month, year) || {};
    
    // Initialize summary
    const summary = {
      income: 0,
      spent: 0,
      leftToSpend: 0
    };
    
    // Initialize categories map
    const categoriesMap = {};
    
    // Get active categories from cache
    const allCategories = getCategories() || [];
    const activeCategories = allCategories.filter(cat => cat.active);
    
    // Add all active categories with budgeted values
    activeCategories.forEach(cat => {
      const categoryName = cat.name.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
      categoriesMap[categoryName] = {
        name: cat.name,
        budgeted: monthlyBudget[cat.name] || 0,
        actual: 0,
        isActive: true
      };
    });
    
    // Process expenses for this month
    expenses.forEach(expense => {
      if (!expense.category || !expense.amount) return;
      
      const categoryName = expense.category.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
      
      if (!categoriesMap[categoryName]) {
        categoriesMap[categoryName] = {
          name: expense.category,
          budgeted: 0,
          actual: 0,
          isActive: false
        };
      }
      
      categoriesMap[categoryName].actual += expense.amount;
      summary.spent += expense.amount;
    });
    
    // Process recurring items that occur in this month
    const recurringThisMonth = getRecurringForMonth(recurring, month, year);
    
    // Convert map to array
    const categoryOrder = {};
    allCategories.forEach((cat, index) => {
      const cleanName = cat.name.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
      categoryOrder[cleanName] = index;
    });
    
    const categories = Object.values(categoriesMap)
      .sort((a, b) => {
        if (a.isActive && !b.isActive) return -1;
        if (!a.isActive && b.isActive) return 1;
        
        const cleanNameA = a.name.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
        const cleanNameB = b.name.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
        
        const orderA = categoryOrder[cleanNameA] ?? 999;
        const orderB = categoryOrder[cleanNameB] ?? 999;
        
        return orderA - orderB;
      });
    
    // Build dashboard data
    return {
      summary: summary,
      categories: categories,
      header: {
        month: new Date(year, month).toLocaleDateString('en-US', { month: 'long' }),
        year: year
      },
      netWorth: {
        total: 0,
        savings: 0,
        debts: 0
      },
      subscriptions: {
        count: recurringThisMonth.length,
        total: recurringThisMonth.reduce((sum, item) => sum + item.amount, 0),
        items: recurringThisMonth.slice(0, 10).map((item, index) => ({
          id: index + 1,
          name: item.name,
          amount: item.amount,
          nextDate: getNextPaymentDate(item, month, year)
        }))
      }
    };
  }
  
  // Helper functions for dashboard calculation
  function getBudgetForMonth(month = currentMonth, year = currentYear) {
    const budgetData = getBudgetData();
    if (!budgetData || !budgetData.categories) return {};
    
    const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
    const monthIndices = budgetData.budgets[monthKey] || {};
    
    const budgetObject = {};
    Object.keys(monthIndices).forEach(index => {
      const categoryName = budgetData.categories[parseInt(index)];
      if (categoryName) {
        budgetObject[categoryName] = monthIndices[index];
      }
    });
    
    return budgetObject;
  }
  
  function getRecurringForMonth(allRecurring, month, year) {
    return allRecurring.filter(item => {
      if (!item.startDate) return false;
      
      const start = new Date(item.startDate);
      const frequency = (item.frequency || 'Monthly').toLowerCase();
      const currentMonthStart = new Date(year, month, 1);
      const currentMonthEnd = new Date(year, month + 1, 0);
      
      if (start > currentMonthEnd) return false;
      
      if (frequency.includes('monthly')) {
        const paymentDay = start.getDate();
        const paymentDate = new Date(year, month, paymentDay);
        
        if (start > currentMonthStart && start <= currentMonthEnd) {
          paymentDate = start;
        }
        
        return paymentDate >= start && (!item.endDate || new Date(item.endDate) >= paymentDate);
      } else if (frequency.includes('yearly') || frequency.includes('annual')) {
        return start.getMonth() === month;
      } else if (frequency.includes('quarterly')) {
        const monthsSinceStart = (year - start.getFullYear()) * 12 + (month - start.getMonth());
        return monthsSinceStart >= 0 && monthsSinceStart % 3 === 0;
      }
      
      return true;
    });
  }
  
  function getNextPaymentDate(item, month, year) {
    if (!item.startDate) return '';
    
    const start = new Date(item.startDate);
    const frequency = (item.frequency || 'Monthly').toLowerCase();
    
    if (frequency.includes('monthly')) {
      const nextDate = new Date(year, month, start.getDate());
      return nextDate.toLocaleDateString('en-US', { day: 'numeric', month: 'short' });
    }
    
    return '';
  }
  
  // Invalidate related data (from Init)
  function invalidateRelated(key) {
    if (window._isRendering) {
      return;
    }
    
    const related = relationships[key];
    if (related) {
      related.forEach(relatedKey => {
        invalidate(relatedKey);
      });
    }
  }

  /**
   * Preloader functionality (from Init)
   */
  function startPreloader(excludeView) {
    // Only allow one preload attempt per session
    if (preloader.hasRunInSession) {
      return;
    }
    
    if (preloader.isRunning) {
      return;
    }
    
    preloader.hasRunInSession = true;
    preloader.queue = ['budget', 'expense', 'income', 'recurring', 'netWorth']
      .filter(view => view !== excludeView);
    
    console.log(`CacheManager: Starting background preload, excluded ${excludeView}`);
    
    preloader.isRunning = true;
    
    setTimeout(() => {
      processPreloadNext();
    }, config.preloadDelay);
  }
  
  function processPreloadNext() {
    if (preloader.queue.length === 0) {
      console.log('CacheManager: Preload complete');
      preloader.isRunning = false;
      return;
    }
    
    const viewName = preloader.queue.shift();
    
    // Skip if already cached
    if (isValidForView(viewName)) {
      setTimeout(processPreloadNext, 200);
      return;
    }
    
    console.log(`CacheManager: Preloading ${viewName}`);
    preloadView(viewName);
  }
  
  function isValidForView(viewName) {
    switch (viewName) {
      case 'budget':
        return isValid('budgetData');
      case 'expense':
        return isValid(`expenses_${currentYear}-${currentMonth}`);
      case 'recurring':
        return isValid('recurring');
      case 'categories':
        return isValid('categories');
      default:
        return false;
    }
  }
  
  function preloadView(viewName) {
    switch (viewName) {
      case 'budget':
        API.getBudgetData(
          (result) => {
            setBudgetData(result.budgetData || {});
            onPreloadComplete(viewName, true);
          },
          (error) => {
            console.warn(`Preload failed for ${viewName}:`, error);
            onPreloadComplete(viewName, false);
          }
        );
        break;
        
      case 'expense':
        API.getExpenseData(currentMonth, currentYear,
          (result) => {
            setExpenses(result.expenses || [], currentMonth, currentYear);
            onPreloadComplete(viewName, true);
          },
          (error) => {
            console.warn(`Preload failed for ${viewName}:`, error);
            onPreloadComplete(viewName, false);
          }
        );
        break;
        
      case 'recurring':
        API.getRecurringData(
          (result) => {
            setRecurring(result.recurring || []);
            onPreloadComplete(viewName, true);
          },
          (error) => {
            console.warn(`Preload failed for ${viewName}:`, error);
            onPreloadComplete(viewName, false);
          }
        );
        break;
        
      default:
        onPreloadComplete(viewName, false);
    }
  }
  
  function onPreloadComplete(viewName, success) {
    if (success) {
      console.log(`CacheManager: Successfully preloaded ${viewName}`);
    }
    
    setTimeout(processPreloadNext, config.preloadInterval);
  }
  
  function stopPreloader() {
    console.log('CacheManager: Stopping preloader');
    preloader.isRunning = false;
    preloader.queue = [];
  }

  /**
   * Month prefetching (for expense grid)
   */
  function prefetchMonth(month, year) {
    const key = `expenses_${year}-${month}`;
    
    // Skip if already cached
    if (isValid(key)) {
      return Promise.resolve();
    }
    
    return new Promise((resolve) => {
      API.getExpenseData(month, year,
        (result) => {
          if (result && result.success && result.expenses) {
            setExpenses(result.expenses, month, year);
          }
          resolve();
        },
        (error) => {
          console.log(`Prefetch failed for ${month}/${year}:`, error);
          resolve();
        }
      );
    });
  }

  /**
   * Get cache statistics
   */
  function getStats() {
    const stats = {
      itemCount: Object.keys(cache.data).length,
      items: {}
    };
    
    Object.entries(cache.metadata).forEach(([key, meta]) => {
      stats.items[key] = {
        age: Date.now() - meta.timestamp,
        expires: new Date(meta.expires),
        isValid: Date.now() < meta.expires
      };
    });
    
    return stats;
  }

  /**
   * Public API
   */
  return {
    // Core operations
    get,
    set,
    isValid,
    invalidate,
    invalidateAll,
    clear: invalidateAll,
    clearMonth,
    
    // Budget-specific
    getExpenses,
    setExpenses,
    getDashboardData,
    getBudgetData,
    setBudgetData,
    getCategories,
    setCategories,
    getRecurring,
    setRecurring,
    getSettings,
    setSettings,
    getBudgetForMonth,
    calculateDashboardData,
    
    // Update expense (for transaction updates)
    updateExpense: function(expense, month = currentMonth, year = currentYear) {
      const expenses = getExpenses(month, year) || [];
      const index = expenses.findIndex(e => 
        e.transactionId === expense.transactionId || 
        e.id === expense.id
      );
      
      if (index >= 0) {
        expenses[index] = expense;
      } else {
        expenses.push(expense);
      }
      
      setExpenses(expenses, month, year);
    },
    
    // Preloader
    startPreloader,
    stopPreloader,
    prefetchMonth,
    
    // State management
    setCurrentMonth: (month, year) => {
      currentMonth = month;
      currentYear = year;
    },
    
    // Stats
    getStats,
    
    // Check if all priority views are loaded (from Init)
    areAllPriorityViewsLoaded: function() {
      const priorityViews = ['budget', 'expense', 'income', 'recurring', 'netWorth'];
      return priorityViews.every(view => isValidForView(view));
    },
    
    // For backwards compatibility
    invalidateRelated
  };
})();

// Make globally available
window.CacheManager = CacheManager;
</script>