<script>
/**
 * CacheManager - Centralized cache management for SimBudget
 * Handles all data caching with smart invalidation and client-side calculations
 */
const CacheManager = (function() {
  // Cache storage
  const cache = {
    data: {},      // Actual cached data
    metadata: {},  // Timestamps, TTL, etc.
  };
  
  // Default config
  const config = {
    defaultTTL: 24 * 60 * 60 * 1000, // 24 hours
    prefix: 'simbudget_cache_',
    maxSize: 5 * 1024 * 1024, // 5MB limit for localStorage
  };
  
  // Define data relationships - when X changes, invalidate Y
  const dependencies = {
    expenses: ['dashboardData'],
    recurring: ['dashboardData'],
    categories: ['dashboardData'],
    income: ['dashboardData'],
    networth: ['dashboardData'],
  };
  
  // Track current month/year
  let currentMonth = new Date().getMonth();
  let currentYear = new Date().getFullYear();

  /**
   * Get data from cache
   */
  function get(key, monthYear = null) {
    const cacheKey = monthYear ? `${key}_${monthYear}` : key;
    const meta = cache.metadata[cacheKey];
    
    // Check if exists and not expired
    if (!meta || Date.now() > meta.expires) {
      return null;
    }
    
    return cache.data[cacheKey];
  }

  /**
   * Set data in cache with smart invalidation
   */
  function set(key, data, options = {}) {
    const monthYear = options.monthYear || null;
    const ttl = options.ttl || config.defaultTTL;
    const cacheKey = monthYear ? `${key}_${monthYear}` : key;
    
    // Store in memory
    cache.data[cacheKey] = data;
    cache.metadata[cacheKey] = {
      expires: Date.now() + ttl,
      size: JSON.stringify(data).length,
      monthYear: monthYear
    };
    
    // Invalidate dependent data
    invalidateDependents(key, monthYear);
    
    // Persist to localStorage if not too large
    persist(cacheKey, data, cache.metadata[cacheKey]);
    
    return true;
  }

  /**
   * Invalidate cache and its dependents
   */
  function invalidate(key, monthYear = null) {
    const cacheKey = monthYear ? `${key}_${monthYear}` : key;
    // Remove from memory
    delete cache.data[cacheKey];
    delete cache.metadata[cacheKey];
    
    // Remove from localStorage
    try {
      localStorage.removeItem(config.prefix + cacheKey);
    } catch (e) {}
    
    // Invalidate dependents
    invalidateDependents(key, monthYear);
  }

  /**
   * Force refresh - just an alias for invalidate
   */
  function forceRefresh(key, monthYear = null) {
    invalidate(key, monthYear);
  }

  /**
   * Invalidate dependent data
   */
  function invalidateDependents(key, monthYear) {
    const deps = dependencies[key];
    if (!deps) return;
    
    deps.forEach(depKey => {
      if (monthYear) {
        // Invalidate specific month
        invalidate(depKey, monthYear);
      } else {
        // Invalidate all months for this key
        Object.keys(cache.data).forEach(cacheKey => {
          if (cacheKey.startsWith(depKey)) {
            delete cache.data[cacheKey];
            delete cache.metadata[cacheKey];
          }
        });
      }
    });
  }

  /**
   * Persist to localStorage with size management
   */
  function persist(key, data, metadata) {
    try {
      const storageKey = config.prefix + key;
      const payload = { data, metadata };
      
      // Check size before storing
      const size = JSON.stringify(payload).length;
      if (size > config.maxSize / 10) { // Don't let one item take >10% of space
        console.warn(`Cache item ${key} too large (${size} bytes), not persisting`);
        return;
      }
      
      localStorage.setItem(storageKey, JSON.stringify(payload));
    } catch (e) {
      if (e.name === 'QuotaExceededError') {
        // Clear old data and try again
        cleanupStorage();
        try {
          localStorage.setItem(storageKey, JSON.stringify(payload));
        } catch (e2) {
          console.error('Cache persist failed after cleanup:', e2);
        }
      }
    }
  }

  /**
   * Load from localStorage on init
   */
  function hydrate() {
    const keys = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(config.prefix)) {
        keys.push(key);
      }
    }
    
    keys.forEach(storageKey => {
      try {
        const cacheKey = storageKey.replace(config.prefix, '');
        const stored = JSON.parse(localStorage.getItem(storageKey));
        
        if (stored && stored.metadata && stored.metadata.expires > Date.now()) {
          cache.data[cacheKey] = stored.data;
          cache.metadata[cacheKey] = stored.metadata;
        } else {
          // Expired, remove it
          localStorage.removeItem(storageKey);
        }
      } catch (e) {
        // Corrupted data, remove it
        localStorage.removeItem(storageKey);
      }
    });
  }

  /**
   * Clean up old localStorage data
   */
  function cleanupStorage() {
    const items = [];
    
    // Collect all our cache items with metadata
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(config.prefix)) {
        try {
          const data = JSON.parse(localStorage.getItem(key));
          items.push({
            key: key,
            expires: data.metadata.expires,
            size: data.metadata.size || 0
          });
        } catch (e) {}
      }
    }
    
    // Sort by expiration (oldest first)
    items.sort((a, b) => a.expires - b.expires);
    
    // Remove oldest 25%
    const removeCount = Math.floor(items.length * 0.25);
    for (let i = 0; i < removeCount; i++) {
      localStorage.removeItem(items[i].key);
    }
  }

  /**
   * Budget-specific helper methods
   */
  const budgetHelpers = {
    // Get expense data for current or specific month
    getExpenses(month = currentMonth, year = currentYear) {
      const paddedMonth = String(month).padStart(2, '0');
      return get('expenses', `${year}-${paddedMonth}`);
    },

    setExpenses(expenses, month = currentMonth, year = currentYear) {
      const paddedMonth = String(month).padStart(2, '0');
      return set('expenses', expenses, { monthYear: `${year}-${paddedMonth}` });
    },
    
    // Update single expense
    updateExpense(expense, month = currentMonth, year = currentYear) {
      const expenses = this.getExpenses(month, year) || [];
      const index = expenses.findIndex(e => e.transactionId === expense.transactionId);
      
      if (index >= 0) {
        expenses[index] = expense;
      } else {
        expenses.push(expense);
      }
      
      return this.setExpenses(expenses, month, year);
    },



// Add to budgetHelpers object in CacheManager.js.html

// Get budget data from JSON
getBudgetData() {
  return get('budgetData');
},

// Set budget data
setBudgetData(budgetData) {
  // Store with longer TTL since budget doesn't change often
  return set('budgetData', budgetData, { ttl: 7 * 24 * 60 * 60 * 1000 }); // 7 days
},

// Get budget for specific month/year
getBudgetForMonth(month = currentMonth, year = currentYear) {
  const budgetData = this.getBudgetData();
  if (!budgetData || !budgetData.categories) return {};
  
  const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
  const monthIndices = budgetData.budgets[monthKey] || {};
  
  // Convert sparse indices back to full object
  const budgetObject = {};
  Object.keys(monthIndices).forEach(index => {
    const categoryName = budgetData.categories[parseInt(index)];
    if (categoryName) {
      budgetObject[categoryName] = monthIndices[index];
    }
  });
  
  return budgetObject;
},

// Update budget for specific month
updateBudgetForMonth(month, year, categoryBudgets) {
  let budgetData = this.getBudgetData();
  
  if (!budgetData || !budgetData.categories) {
    const allCategories = this.getCategories() || [];
    budgetData = {
      categories: allCategories.map(cat => cat.name),
      budgets: {}
    };
  }
  
  const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
  
  // Convert to sparse indexed format
  const sparseMonth = {};
  
  Object.keys(categoryBudgets).forEach(catName => {
    const index = budgetData.categories.indexOf(catName);
    if (index !== -1 && categoryBudgets[catName] > 0) {
      sparseMonth[index.toString()] = categoryBudgets[catName];
    }
  });
  
  budgetData.budgets[monthKey] = sparseMonth;
  
  this.setBudgetData(budgetData);
  this.invalidate('dashboardData');
  
  return budgetData;
},



// Add to budgetHelpers object in CacheManager.js
getCategories() {
  return get('categories');
},

setCategories(categories) {
  // Store with longer TTL since categories don't change often
  return set('categories', categories, { ttl: 7 * 24 * 60 * 60 * 1000 }); // 7 days
},

// Get only active categories for quick access
getActiveCategories() {
  const allCategories = this.getCategories();
  if (!allCategories) return null;
  
  return allCategories.filter(cat => cat.active);
},

// Update a single category's status
updateCategoryStatus(categoryName, active) {
  const categories = this.getCategories();
  if (!categories) return false;
  
  const category = categories.find(cat => cat.name === categoryName);
  if (category) {
    category.active = active;
    return this.setCategories(categories);
  }
  return false;
},

    
    // Get recurring data
    getRecurring() {
      return get('recurring');
    },
    
    // Set recurring data
    setRecurring(recurring) {
      return set('recurring', recurring, { ttl: 24 * 60 * 60 * 1000 });
    },
    
    // Get dashboard data (calculated from expenses + recurring)
    // In CacheManager.js.html, in the budgetHelpers object:
getDashboardData(month = currentMonth, year = currentYear) {
  const expenses = this.getExpenses(month, year);
  const recurring = this.getRecurring();
  const categories = this.getCategories();
  

  
  if (!expenses || !recurring || !categories) {
    console.log('CacheManager: Missing data for dashboard calculation', {
      expenses: expenses,
      recurring: recurring,
      categories: categories
    });
    return null;
  }
  
  
  try {
    const result = this.calculateDashboardData(expenses, recurring, month, year);
    console.log('CacheManager: Dashboard calculation COMPLETED');
    return result;
  } catch (error) {
    console.error('ERROR in calculateDashboardData:', error);
    console.error('Error stack:', error.stack);
    return null;
  }
},
    
    // Calculate dashboard data from raw expenses and recurring
    calculateDashboardData(expenses, recurring, month, year) {

  
  // Get budget data for this month
  const monthlyBudget = this.getBudgetForMonth(month, year) || {};
  
  // Initialize summary
  const summary = {
    income: 0,
    spent: 0,
    leftToSpend: 0
  };
  
  // Initialize categories map
  const categoriesMap = {};
  
  // Get active categories from cache
  const allCategories = this.getCategories() || [];
  console.log('Categories loaded:', allCategories.length);
  
  const activeCategories = allCategories.filter(cat => cat.active);
  
  // Add all active categories with budgeted values
  activeCategories.forEach(cat => {
    const categoryName = cat.name.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
    categoriesMap[categoryName] = {
      name: cat.name,
      budgeted: monthlyBudget[cat.name] || 0,
      actual: 0,
      isActive: true
    };
  });
  

// Process expenses for this month
expenses.forEach(expense => {
  if (!expense.category || !expense.amount) return;
  
  const categoryName = expense.category.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
  
  if (!categoriesMap[categoryName]) {
    // This is an inactive category with transactions
    categoriesMap[categoryName] = {
      name: expense.category, // Keep original with emoji
      budgeted: 0,
      actual: 0,
      isActive: false
    };
  }
  
  categoriesMap[categoryName].actual += expense.amount;
  summary.spent += expense.amount;
});

// Process recurring items that occur in this month
const recurringThisMonth = this.getRecurringForMonth(recurring, month, year);
recurringThisMonth.forEach(item => {
  if (!item.amount) return;
  
  const categoryName = item.category ? 
    item.category.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim() : 
    'Subscriptions';
  const categoryDisplay = item.category || 'Subscriptions 🔁';
  
  if (!categoriesMap[categoryName]) {
    categoriesMap[categoryName] = {
      name: categoryDisplay,
      budgeted: 0,
      actual: 0,
      isActive: false
    };
  }
  
  categoriesMap[categoryName].actual += item.amount;
 // summary.spent += item.amount;
});

// Convert map to array - active categories first, then inactive with transactions
// Get the original order from allCategories
const categoryOrder = {};
allCategories.forEach((cat, index) => {
  const cleanName = cat.name.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
  categoryOrder[cleanName] = index;
});

// Convert map to array - active categories first (in original order), then inactive with transactions
const categories = Object.values(categoriesMap)
  .sort((a, b) => {
    // Active categories first
    if (a.isActive && !b.isActive) return -1;
    if (!a.isActive && b.isActive) return 1;
    
    // For categories of the same type (both active or both inactive)
    // Use the original order if available
    const cleanNameA = a.name.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
    const cleanNameB = b.name.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
    
    const orderA = categoryOrder[cleanNameA] ?? 999;
    const orderB = categoryOrder[cleanNameB] ?? 999;
    
    return orderA - orderB;
  });
      
      // Build dashboard data structure matching the original API response
      return {
        summary: summary,
        categories: categories,
        header: {
          month: new Date(year, month).toLocaleDateString('en-US', { month: 'long' }),
          year: year
        },
        netWorth: {
          total: 0, // TODO: Add later
          savings: 0,
          debts: 0
        },
        subscriptions: {
          count: recurringThisMonth.length,
          total: recurringThisMonth.reduce((sum, item) => sum + item.amount, 0),
          items: recurringThisMonth.slice(0, 10).map((item, index) => ({
            id: index + 1,
            name: item.name,
            amount: item.amount,
            nextDate: this.getNextPaymentDate(item, month, year)
          }))
        }
      };
    },
    
    // Get recurring items that occur in a specific month
    getRecurringForMonth(allRecurring, month, year) {
      return allRecurring.filter(item => {
        if (!item.startDate) return false;
        
        const start = new Date(item.startDate);
        const frequency = (item.frequency || 'Monthly').toLowerCase();
        const currentMonthStart = new Date(year, month, 1);
        const currentMonthEnd = new Date(year, month + 1, 0); // Last day of month
        
        // Skip if subscription hasn't started yet
        if (start > currentMonthEnd) return false;
        
        // Calculate when the payment would occur in this month
        let paymentDate;
        
        if (frequency.includes('monthly')) {
          // Payment occurs on the same day each month
          const paymentDay = start.getDate();
          paymentDate = new Date(year, month, paymentDay);
          
          // If start date is in the future but within this month, use start date
          if (start > currentMonthStart && start <= currentMonthEnd) {
            paymentDate = start;
          }
        } else if (frequency.includes('yearly') || frequency.includes('annual')) {
          // Payment occurs once a year on anniversary
          if (start.getMonth() !== month) return false;
          paymentDate = new Date(year, month, start.getDate());
        } else if (frequency.includes('quarterly')) {
          // Check if this is a quarter month
          const monthsSinceStart = (year - start.getFullYear()) * 12 + (month - start.getMonth());
          if (monthsSinceStart < 0 || monthsSinceStart % 3 !== 0) return false;
          paymentDate = new Date(year, month, start.getDate());
        } else {
          // Default to monthly
          const paymentDay = start.getDate();
          paymentDate = new Date(year, month, paymentDay);
        }
        
        // Check if payment date is after start date
        if (paymentDate < start) return false;
        
        // Check if subscription was canceled before the payment date
        if (item.endDate) {
          const end = new Date(item.endDate);
          if (end < paymentDate) return false;
        }
        
        return true;
      });
    },
    
    // Calculate next payment date for display
    getNextPaymentDate(item, month, year) {
      if (!item.startDate) return '';
      
      const start = new Date(item.startDate);
      const targetDate = new Date(year, month);
      const frequency = (item.frequency || 'Monthly').toLowerCase();
      
      // For monthly, it's this month
      if (frequency.includes('monthly')) {
        const nextDate = new Date(year, month, start.getDate());
        return nextDate.toLocaleDateString('en-US', { day: 'numeric', month: 'short' });
      }
      
      // TODO: Calculate for other frequencies
      return '';
    },
    
    // Get category totals (computed from expenses)
    getCategoryTotals(month = currentMonth, year = currentYear) {
      const expenses = this.getExpenses(month, year) || [];
      const totals = {};
      
      expenses.forEach(expense => {
        if (expense.category) {
          const categoryName = expense.category.replace(/\s*[\u{1F300}-\u{1F9FF}].*$/u, '').trim();
          totals[categoryName] = (totals[categoryName] || 0) + expense.amount;
        }
      });
      
      return totals;
    },
    
    // Clear all data for a month
    clearMonth(month = currentMonth, year = currentYear) {
      const monthYear = `${year}-${month}`;
      invalidate('expenses', monthYear);
      invalidate('dashboardData', monthYear);
    },
    
    // Prefetch month data
    prefetchMonth(month, year) {
      const monthKey = `${year}-${month}`;
      
      // Skip if already cached
      if (this.getExpenses(month, year)) {
        return Promise.resolve();
      }
      
      // Skip if already being fetched
      if (this._prefetchingMonths && this._prefetchingMonths.has(monthKey)) {
        return Promise.resolve();
      }
      
      // Track what we're fetching
      if (!this._prefetchingMonths) {
        this._prefetchingMonths = new Set();
      }
      this._prefetchingMonths.add(monthKey);
      
      // Fetch in background
      return new Promise((resolve) => {
        if (window.API && API.getExpenseData) {
          API.getExpenseData(month, year,
            (result) => {
              this._prefetchingMonths.delete(monthKey);
              if (result && result.success && result.expenses) {
                this.setExpenses(result.expenses, month, year);
              }
              resolve();
            },
            (error) => {
              this._prefetchingMonths.delete(monthKey);
              console.log(`Prefetch failed for ${month}/${year}:`, error);
              resolve();
            }
          );
        } else {
          this._prefetchingMonths.delete(monthKey);
          resolve();
        }
      });
    }
  };

  // Initialize on load
  hydrate();
  
  // Public API
  return {
    get,
    set,
    invalidate,
    forceRefresh,
    clear: () => {
      cache.data = {};
      cache.metadata = {};
      cleanupStorage();
    },
    
    // Month/year management
    setCurrentMonth: (month, year) => {
      currentMonth = month;
      currentYear = year;
    },
    
    // Budget-specific methods
    ...budgetHelpers,
    
    // Debugging
    getStats: () => {
      const stats = {
        itemCount: Object.keys(cache.data).length,
        totalSize: 0,
        items: {}
      };
      
      Object.entries(cache.metadata).forEach(([key, meta]) => {
        stats.totalSize += meta.size || 0;
        stats.items[key] = {
          expires: new Date(meta.expires),
          size: meta.size
        };
      });
      
      return stats;
    }
  };
})();

// Make available globally
window.CacheManager = CacheManager;
</script>