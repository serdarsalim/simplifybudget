<script>
// ============================================================================
// CLIENT-SIDE RECURRING MODULE - ENHANCED VERSION
// ============================================================================

var RecurringManager = (function() {
  // Private variables
  let _initialized = false;
  let _recurringData = [];
  let _categories = [];
  let _currencySymbol = '$';
  let _showDecimals = true;
  let _language = 'en';
  let _currentFilter = 'all';
  
  // DOM element cache
  const _elements = {};
  
  /**
   * Get element with caching
   */
  function getElement(id) {
    if (!_elements[id]) {
      _elements[id] = document.getElementById(id);
    }
    return _elements[id];
  }

  /**
   * Load settings from SimBudget
   */
  function loadSettings() {
    console.log('RecurringManager: Loading settings...');
    
    if (window.SimBudget && SimBudget.Settings) {
      _currencySymbol = SimBudget.Settings.getCurrencySymbol() || '$';
      _showDecimals = SimBudget.Settings.showDecimals() !== false;
      _language = SimBudget.Settings.getSetting('language') || 'en';
      
      console.log('RecurringManager: Settings loaded -', {
        currency: _currencySymbol,
        decimals: _showDecimals,
        language: _language
      });
    }
  }

  /**
   * Format currency with user settings
   */
  function formatCurrency(amount) {
    if (window.Utils && typeof Utils.formatCurrency === 'function') {
      return Utils.formatCurrency(amount);
    }
    
    const decimals = _showDecimals ? 2 : 0;
    return `${_currencySymbol}${amount.toFixed(decimals)}`;
  }

  /**
   * Initialize the Recurring Manager
   * @param {string} containerId - Container element ID
   * @param {Array|null} cachedData - Optional cached data to use instead of loading
   */
  function init(containerId, cachedData) {
    console.log('RecurringManager: init called');
    
    // Clean up any unsaved new items when re-initializing (tab switch)
    _recurringData = _recurringData.filter(item => !item.isNew);
    
    // Clear element cache when re-initializing
    Object.keys(_elements).forEach(key => {
      delete _elements[key];
    });
    
    // Reset event binding flag
    const oldContainer = document.getElementById('recurringContent');
    if (oldContainer) {
      oldContainer.dataset.eventsbound = 'false';
    }
    
    // Load user settings
    loadSettings();
    
    // Find container
    const container = containerId ? 
      document.getElementById(containerId) : 
      getElement('recurringContent');
    
    if (!container) {
      console.error('RecurringManager: Container not found');
      return;
    }
    
    _elements['recurringContent'] = container;
    
    // Load categories
    loadCategories();
    
    // Check if we already have data loaded
    if (_initialized && _recurringData.length > 0 && !cachedData) {
      console.log('RecurringManager: Using existing loaded data');
      // Just render with existing data
      renderRecurringView();
      bindEvents();
      
      // Set active filter as default
      setTimeout(() => {
        const activeBtn = document.querySelector('.rec-filter-btn[data-status="active"]');
        if (activeBtn) {
          activeBtn.click();
        }
      }, 100);
      
    } else if (cachedData && Array.isArray(cachedData)) {
      console.log('RecurringManager: Using provided cached data');
      _recurringData = processRecurringData(cachedData);
      renderRecurringView();
      bindEvents();
      
      // Set active filter as default
      setTimeout(() => {
        const activeBtn = document.querySelector('.rec-filter-btn[data-status="active"]');
        if (activeBtn) {
          activeBtn.click();
        }
      }, 100);
      
      // Load fresh data in background after a delay
      setTimeout(() => {
        loadRealRecurringData(true); // true = background refresh
      }, 2000);
      
    } else if (!_initialized || _recurringData.length === 0) {
      console.log('RecurringManager: Loading fresh data');
      // No data yet, load fresh
      loadRealRecurringData();
    }
    
    _initialized = true;
  }

  /**
   * Load categories from active categories
   */
  function loadCategories() {
    console.log('RecurringManager: Loading categories...');
    
    try {
      const cachedCategories = localStorage.getItem('simbudget_categories');
      const activeCategories = localStorage.getItem('simbudget_active_categories');
      
      if (cachedCategories && activeCategories) {
        const allCategories = JSON.parse(cachedCategories);
        const active = JSON.parse(activeCategories);
        
        _categories = allCategories
          .filter(cat => {
            const categoryName = typeof cat === 'string' ? cat : cat.name;
            return active.includes(categoryName);
          })
          .map(cat => {
            const categoryString = typeof cat === 'string' ? cat : cat.name || '';
            const parsed = parseCategoryNameAndEmoji(categoryString);
            return {
              id: parsed.name,
              name: parsed.name,
              emoji: parsed.emoji,
              fullName: categoryString
            };
          });
        
        console.log('RecurringManager: Loaded', _categories.length, 'active categories');
      }
    } catch (error) {
      console.warn('RecurringManager: Error loading categories', error);
      _categories = [
        {id: 'Subscription', name: 'Subscription', emoji: 'üì±', fullName: 'Subscription üì±'},
        {id: 'Utilities', name: 'Utilities', emoji: 'üí°', fullName: 'Utilities üí°'},
        {id: 'Insurance', name: 'Insurance', emoji: 'üõ°Ô∏è', fullName: 'Insurance üõ°Ô∏è'}
      ];
    }
  }

  /**
   * Parse category string to extract name and emoji
   */
  function parseCategoryNameAndEmoji(categoryString) {
    const parts = categoryString.trim().split(' ');
    
    if (parts.length >= 2) {
      const lastPart = parts[parts.length - 1];
      const emojiRegex = /[\u{1F600}-\u{1F6FF}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
      
      if (emojiRegex.test(lastPart)) {
        const name = parts.slice(0, -1).join(' ');
        const emoji = lastPart;
        return { name, emoji };
      }
    }
    
    return { name: categoryString, emoji: '' };
  }

  /**
   * Calculate next payment date based on frequency and start date
   */
  function calculateNextPayment(startDate, frequency, endDate) {
    if (!startDate || !(startDate instanceof Date)) return null;
    
    const now = new Date();
    
    // If ended, no next payment
    if (endDate && endDate < now) return null;
    
    let nextDate = new Date(startDate);
    const freq = frequency.toLowerCase();
    
    // Keep advancing the date until it's in the future
    while (nextDate <= now) {
      if (freq.includes('monthly')) {
        nextDate.setMonth(nextDate.getMonth() + 1);
      } else if (freq.includes('yearly') || freq.includes('annual')) {
        nextDate.setFullYear(nextDate.getFullYear() + 1);
      } else if (freq.includes('quarterly')) {
        nextDate.setMonth(nextDate.getMonth() + 3);
      } else {
        // Default to monthly
        nextDate.setMonth(nextDate.getMonth() + 1);
      }
    }
    
    // If the next payment would be after end date, return null
    if (endDate && nextDate > endDate) return null;
    
    return nextDate;
  }

  /**
   * Calculate expiration date for current subscription period
   */
  function calculateExpirationDate(startDate, frequency, endDate, itemType) {
    if (!startDate || !(startDate instanceof Date) || !endDate) return null;
    
    // Check if this is a subscription (TRUE) vs fixed payment (FALSE)
    const isSubscription = itemType && itemType.toString().toUpperCase() === 'TRUE';
    
    // For Fixed Payments, end date is just the end date
    if (!isSubscription) {
      return endDate;
    }
    
    // For Subscriptions - SIMPLE LOGIC
    const freq = frequency.toLowerCase();
    let expDate = new Date(startDate);
    
    // Add one full cycle from start date
    if (freq.includes('yearly') || freq.includes('annual')) {
      expDate.setFullYear(expDate.getFullYear() + 1);
    } else if (freq.includes('quarterly')) {
      expDate.setMonth(expDate.getMonth() + 3);
    } else {
      // Default to monthly
      expDate.setMonth(expDate.getMonth() + 1);
    }
    
    // Subtract 1 day (expires day before next cycle)
    expDate.setDate(expDate.getDate() - 1);
    
    return expDate;
  }

  /**
   * Load real recurring data from API
   */
  function loadRealRecurringData(isBackgroundRefresh = false) {
    console.log('RecurringManager: Loading data...');
    
    if (!isBackgroundRefresh) {
      showLoadingState();
    }
    
    if (!window.API || typeof API.getRecurringData !== 'function') {
      console.error('RecurringManager: API.getRecurringData not available');
      if (!isBackgroundRefresh) {
        showErrorState('API not available');
      }
      return;
    }

    API.getRecurringData(
      function(result) {
        console.log('RecurringManager: API response received');
        
        if (result && result.success && Array.isArray(result.recurring)) {
          _recurringData = processRecurringData(result.recurring);
          
          // Cache the data in SimBudget's cache system
          if (window._cache && typeof _cache.set === 'function') {
            _cache.set('recurring', result.recurring);
          }
          
          if (!isBackgroundRefresh) {
            renderRecurringView();
            bindEvents();
            
            // Set active filter as default
            setTimeout(() => {
              const activeBtn = document.querySelector('.rec-filter-btn[data-status="active"]');
              if (activeBtn) {
                activeBtn.click();
              }
            }, 100);
          } else {
            updateSummaryCards();
            updateRecurringTable();
    
    // Update header based on initial filter
    updateDynamicDateHeader(_currentFilter);
          }
          
          console.log('RecurringManager: Data loaded successfully');
        } else {
          console.warn('RecurringManager: Invalid API response');
          if (!isBackgroundRefresh) {
            showErrorState(result?.error || 'No recurring data received');
          }
        }
      },
      function(error) {
        console.error('RecurringManager: API error:', error);
        if (!isBackgroundRefresh) {
          showErrorState('Failed to load data: ' + error);
        }
      }
    );
  }

  /**
   * Process raw recurring data from API
   */
  function processRecurringData(rawData) {
    if (!rawData || !Array.isArray(rawData)) {
      return [];
    }
    
    return rawData.map(item => {
      const startDate = item.startDate ? new Date(item.startDate) : null;
      const endDate = item.endDate ? new Date(item.endDate) : null;
      
      // Calculate next payment 
      const nextPayment = startDate ? calculateNextPayment(startDate, item.frequency || 'Monthly', endDate) : null;
      
      // Calculate status - ONLY use expiration logic if there's an actual end date
      let status = 'Active';
      let expiration = null;
      const now = new Date();
      const isSubscription = item.type && item.type.toString().toUpperCase() === 'TRUE';
      
      if (endDate) {
        // Only calculate expiration if there's an end date
        expiration = calculateExpirationDate(startDate, item.frequency || 'Monthly', endDate, item.type);
        
        if (isSubscription) {
          // For subscriptions, use calculated expiration date
          if (expiration && expiration < now) {
            status = 'Ended';
          } else if (expiration) {
            // Any subscription with an expiration date shows as "Expires"
            status = 'Expires';
          }
        } else {
          // For fixed payments, use raw end date
          if (endDate < now) {
            status = 'Ended';
          } else if (endDate < new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000)) {
            status = 'Expires';
          }
        }
      }
      // If no end date, status stays 'Active' and expiration stays null
      
      return {
        id: item.id,
        rowIndex: item.rowIndex,
        startDate: startDate,
        endDate: endDate,
        name: item.name || '',
        category: item.category || '',
        type: item.type || '',
        frequency: item.frequency || 'Monthly',
        amount: parseFloat(item.amount) || 0,
        account: item.account || '',
        status: status,
        nextPayment: nextPayment,
        expiration: expiration,
        notes: item.notes || ''
      };
    });
  }

  /**
   * Calculate banner metrics
   */
  function calculateBannerMetrics() {
    const activeSubscriptions = _recurringData.filter(item => 
      item.status === 'Active' || item.status === 'active'
    );

    const activeCount = activeSubscriptions.length;
    
    let monthlyTotal = 0;
    activeSubscriptions.forEach(item => {
      const freq = item.frequency.toLowerCase();
      const amount = item.amount;
      
      if (freq.includes('monthly')) {
        monthlyTotal += amount;
      } else if (freq.includes('yearly') || freq.includes('annual')) {
        monthlyTotal += amount / 12;
      } else if (freq.includes('quarterly')) {
        monthlyTotal += amount / 3;
      } else {
        monthlyTotal += amount;
      }
    });

    const annualProjection = monthlyTotal * 12;
    
    let budgetImpact = 0;
    if (window._dataCache && typeof _dataCache.get === 'function') {
      const budgetData = _dataCache.get('budget');
      if (budgetData && budgetData.summary) {
        const monthlyBudget = budgetData.summary.income;
        budgetImpact = monthlyBudget > 0 ? (monthlyTotal / monthlyBudget) * 100 : 0;
      }
    }

    return {
      activeSubscriptions: activeCount,
      annualProjection: annualProjection,
      budgetImpact: budgetImpact,
      monthlyAverage: monthlyTotal
    };
  }

  /**
   * Show loading state
   */
  function showLoadingState() {
    const container = getElement('recurringContent');
    if (container) {
      container.innerHTML = `
        <div class="rec-loading">
          <div class="loading-spinner"></div>
          <p data-translate="loading_recurring">Loading recurring transactions...</p>
        </div>
      `;
    }
  }

  /**
   * Show error state
   */
  function showErrorState(error) {
    const container = getElement('recurringContent');
    if (container) {
      container.innerHTML = `
        <div class="rec-error">
          <h3 data-translate="error_loading_recurring">Error Loading Recurring Data</h3>
          <p>${error}</p>
          <button onclick="RecurringManager.refresh()" data-translate="retry">Retry</button>
        </div>
      `;
    }
  }

  /**
   * Show notes popup
   */
  function showNotesPopup(notes, elementRect) {
    // Remove any existing popup
    const existingPopup = document.querySelector('.rec-notes-popup');
    if (existingPopup) {
      existingPopup.remove();
    }
    
    // Create popup
    const popup = document.createElement('div');
    popup.className = 'rec-notes-popup';
    popup.textContent = notes || 'No notes';
    
    // Position near the clicked element
    popup.style.position = 'absolute';
    popup.style.left = elementRect.left + 'px';
    popup.style.top = (elementRect.bottom + 5) + 'px';
    
    document.body.appendChild(popup);
    
    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', function closePopup(e) {
        if (!popup.contains(e.target)) {
          popup.remove();
          document.removeEventListener('click', closePopup);
        }
      });
    }, 100);
  }

  /**
   * Render the complete recurring view
   */
  function renderRecurringView() {
    console.log('RecurringManager: Rendering view...');
    
    const container = getElement('recurringContent');
    if (!container) return;

    const metrics = calculateBannerMetrics();

    container.innerHTML = `
      <!-- Summary Box -->
      <div class="rec-summary-row">
        <div class="rec-summary-box">
          <div class="rec-box-content">
            <div class="rec-box-item">
              <div class="rec-box-label" data-translate="active_subscriptions">Active Subscriptions</div>
              <div class="rec-box-value" id="activeSubscriptionsCount">${metrics.activeSubscriptions}</div>
            </div>
            <div class="rec-box-item">
              <div class="rec-box-label" data-translate="annual_projection">Annual Projection</div>
              <div class="rec-box-value" id="annualProjection">${formatCurrency(metrics.annualProjection)}</div>
            </div>
            <div class="rec-box-item">
              <div class="rec-box-label" data-translate="budget_impact">Budget Impact</div>
              <div class="rec-box-value" id="budgetImpact">${metrics.budgetImpact.toFixed(1)}%</div>
            </div>
            <div class="rec-box-item">
              <div class="rec-box-label" data-translate="monthly_average">Monthly Average</div>
              <div class="rec-box-value" id="monthlyAverage">${formatCurrency(metrics.monthlyAverage)}</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Table Section -->
      <div class="rec-table-container">
        <div class="rec-table-header">
          <div class="rec-filters">
            <div class="rec-status-filters">
              <button class="rec-filter-btn" data-status="all" data-translate="all">All</button>
              <button class="rec-filter-btn active" data-status="active" data-translate="active">Active</button>
              <button class="rec-filter-btn" data-status="expires" data-translate="expires">Expires</button>
              <button class="rec-filter-btn" data-status="ended" data-translate="ended">Ended</button>
              <button class="rec-add-subscription-btn" id="addSubscriptionBtn">
                <i class="material-icons">add</i>
                <span>Add</span>
              </button>
            </div>
            <div class="rec-category-filter">
              <select id="categoryFilter" class="rec-filter-select">
                <option value="all" data-translate="all_categories">All Categories</option>
                ${_categories.map(cat => 
                  `<option value="${cat.name}">${cat.emoji} ${cat.name}</option>`
                ).join('')}
              </select>
            </div>
          </div>
        </div>
        
        <div class="rec-table-wrapper">
          <table class="rec-table" id="recurringTable">
            <thead>
              <tr>
                <th class="rec-startdate-header" data-translate="start_date">Start Date</th>
                <th class="rec-name-header" data-translate="name">Name</th>
                <th class="rec-category-header" data-translate="category">Category</th>
                <th class="rec-type-header" data-translate="type">Type</th>
                <th class="rec-frequency-header" data-translate="frequency">Frequency</th>
                <th class="rec-amount-header" data-translate="amount">Amount</th>
                <th class="rec-account-header" data-translate="account">Account</th>
                <th class="rec-dynamic-date-header" id="dynamicDateHeader" data-translate="next_payment">Next Payment</th>
                <th class="rec-enddate-header" data-translate="end_date">End date</th>
                <th class="rec-notes-header">üìù</th>
                <th class="rec-actions-header" data-translate="actions">Actions</th>
              </tr>
            </thead>
            <tbody id="recurringTableBody">
              <!-- Data will be populated here -->
            </tbody>
          </table>
        </div>
      </div>
    `;

    updateRecurringTable();
    
    if (window.SimBudget && SimBudget.applyTranslations) {
      SimBudget.applyTranslations();
    }
  }

  /**
   * Update dynamic date column header based on filter
   */
  function updateDynamicDateHeader(filter) {
    const header = getElement('dynamicDateHeader');
    if (!header) return;
    
    if (filter === 'ended') {
      // Hide the Next Payment column completely for ended items
      header.style.display = 'none';
      // Also hide all existing cells in this column
      document.querySelectorAll('.rec-dynamic-date-cell').forEach(cell => {
        cell.style.display = 'none';
      });
    } else if (filter === 'expires') {
      // Show "Expires on" for expires filter
      header.style.display = '';
      header.setAttribute('data-translate', 'expires_on');
      header.textContent = 'Expires on';
      // Show all existing cells in this column
      document.querySelectorAll('.rec-dynamic-date-cell').forEach(cell => {
        cell.style.display = '';
      });
    } else {
      // Show the Next Payment column for active items
      header.style.display = '';
      header.setAttribute('data-translate', 'next_payment');
      header.textContent = 'Next Payment';
      // Show all existing cells in this column
      document.querySelectorAll('.rec-dynamic-date-cell').forEach(cell => {
        cell.style.display = '';
      });
    }
    
    if (window.SimBudget && SimBudget.applyTranslations) {
      SimBudget.applyTranslations();
    }
  }

  /**
   * Update recurring table with current data and filters
   */
  function updateRecurringTable() {
    const tbody = getElement('recurringTableBody');
    if (!tbody) return;

    const statusFilter = _currentFilter;
    const categoryFilter = getElement('categoryFilter')?.value || 'all';

    updateDynamicDateHeader(statusFilter);

    let filteredData = _recurringData;

    if (statusFilter !== 'all') {
      filteredData = filteredData.filter(item => {
        const status = item.status.toLowerCase();
        if (statusFilter === 'active') return status === 'active';
        if (statusFilter === 'expires') return status === 'expires';
        if (statusFilter === 'ended') return status === 'ended';
        return true;
      });
    }

    if (categoryFilter !== 'all') {
      filteredData = filteredData.filter(item => 
        item.category && item.category.includes(categoryFilter)
      );
    }

    tbody.innerHTML = '';

    filteredData.forEach(item => {
      const row = createRecurringRow(item);
      tbody.appendChild(row);
      
      // Hide next payment column if on ended filter
      if (statusFilter === 'ended') {
        const dynamicCell = row.querySelector('.rec-dynamic-date-cell');
        if (dynamicCell) {
          dynamicCell.style.display = 'none';
        }
      }
    });

    if (filteredData.length === 0) {
      const emptyRow = document.createElement('tr');
      const colSpan = statusFilter === 'ended' ? '10' : '11'; // Less columns when Next Payment is hidden
      emptyRow.innerHTML = `
        <td colspan="${colSpan}" class="rec-empty-message" data-translate="no_recurring_found">
          No recurring transactions found
        </td>
      `;
      tbody.appendChild(emptyRow);
    }
  }

  /**
   * Create a table row for recurring item
   */
  function createRecurringRow(item) {
    const row = document.createElement('tr');
    row.setAttribute('data-id', item.id);
    row.setAttribute('data-status', item.status);

    const categoryInfo = _categories.find(cat => 
      cat.fullName === item.category || cat.name === item.category
    );
    const categoryEmoji = categoryInfo ? categoryInfo.emoji : 'üìÑ';

    const formatDate = (date) => {
      if (!date || !(date instanceof Date)) return '';
      const options = { day: 'numeric', month: 'short', year: 'numeric' };
      return date.toLocaleDateString('en-GB', options);
    };

    const startDateStr = formatDate(item.startDate);
    const endDateStr = formatDate(item.endDate);

    let typeDisplay = 'Subscription';
    if (item.type) {
      const typeStr = item.type.toString().toUpperCase();
      if (typeStr === 'FALSE' || typeStr === 'FIXED' || typeStr === 'PAYMENT') {
        typeDisplay = 'Fixed';
      }
    }

    const frequencyFull = item.frequency || 'Monthly';

    // Dynamic date column logic
    let dynamicDateValue = '';
    let dynamicDateClass = '';
    
    if (item.status.toLowerCase() === 'ended') {
      dynamicDateValue = 'Ended';
      dynamicDateClass = 'status-ended';
    } else if (item.status.toLowerCase() === 'expires' && item.expiration) {
      // Show expiration date for items that expire
      dynamicDateValue = formatDate(item.expiration);
      dynamicDateClass = 'status-expires';
    } else if (item.nextPayment) {
      dynamicDateValue = formatDate(item.nextPayment);
      dynamicDateClass = 'status-active';
    } else if (item.isNew || !item.startDate) {
      // For new items or items without start date, show empty
      dynamicDateValue = '';
      dynamicDateClass = '';
    } else {
      dynamicDateValue = 'Ended';
      dynamicDateClass = 'status-ended';
    }

    // Truncate name and add title for hover
    const nameDisplay = item.name.length > 25 ? item.name.substring(0, 25) + '...' : item.name;

    row.innerHTML = `
      <td class="rec-startdate-cell">${startDateStr}</td>
      <td class="rec-name-cell">
        <div class="rec-name-content" title="${item.name}">
          <span class="rec-item-name">${nameDisplay}</span>
        </div>
      </td>
      <td class="rec-category-cell">
        <span class="category-emoji-only" title="${item.category}">${categoryEmoji}</span>
      </td>
      <td class="rec-type-cell">
        <span class="rec-type-full">${typeDisplay}</span>
      </td>
      <td class="rec-frequency-cell">
        <span class="frequency-full">${frequencyFull}</span>
      </td>
      <td class="rec-amount-cell">${formatCurrency(item.amount)}</td>
      <td class="rec-account-cell">${item.account}</td>
      <td class="rec-dynamic-date-cell ${dynamicDateClass}">${dynamicDateValue}</td>
      <td class="rec-enddate-cell">${endDateStr}</td>
      <td class="rec-notes-cell" data-notes="${item.notes || ''}" title="Click to view notes">
        ${item.notes ? 'üìù' : ''}
      </td>
      <td class="rec-actions-cell">
        <div class="rec-action-buttons">
          <button class="rec-action-btn rec-edit-btn" data-id="${item.id}" title="Edit">
            <i class="material-icons">edit</i>
          </button>
          <button class="rec-action-btn rec-delete-btn" data-id="${item.id}" title="Delete">
            <i class="material-icons">close</i>
          </button>
        </div>
      </td>
    `;

    return row;
  }

  /**
   * Show add subscription popup
   */
  function showAddSubscriptionPopup() {
    // Remove any existing popup
    const existingPopup = document.querySelector('.rec-add-popup');
    if (existingPopup) {
      existingPopup.remove();
    }
    
    // Always reload settings before creating new item to get current currency
    loadSettings();
    
    // Create popup overlay
    const overlay = document.createElement('div');
    overlay.className = 'rec-add-overlay';
    
    // Create popup
    const popup = document.createElement('div');
    popup.className = 'rec-add-popup';
    
    popup.innerHTML = `
      <div class="rec-add-header">
        <h3>Add New Subscription</h3>
      </div>
      <div class="rec-add-body">
        <div class="rec-add-grid">
          <div class="rec-add-row">
            <label>Name *</label>
            <input type="text" id="addName" class="rec-add-input" placeholder="Subscription name" required>
          </div>
          <div class="rec-add-row">
            <label>Amount *</label>
            <div class="rec-add-amount-wrapper">
              <span class="rec-add-currency">${_currencySymbol}</span>
              <input type="number" id="addAmount" class="rec-add-input rec-add-amount" 
                placeholder="0.00" step="0.01" min="0" required>
            </div>
          </div>
          <div class="rec-add-row">
            <label>Type</label>
            <select id="addType" class="rec-add-input">
              <option value="Subscription">Subscription</option>
              <option value="Payment">Fixed Payment</option>
            </select>
          </div>
          <div class="rec-add-row">
            <label>Category</label>
            <select id="addCategory" class="rec-add-input">
              ${_categories.map(cat => 
                `<option value="${cat.fullName}">${cat.emoji} ${cat.name}</option>`
              ).join('')}
            </select>
          </div>
          <div class="rec-add-row">
            <label>Start Date *</label>
            <input type="date" id="addStartDate" class="rec-add-input" required>
          </div>
          <div class="rec-add-row">
            <label>End Date</label>
            <input type="date" id="addEndDate" class="rec-add-input">
          </div>
          <div class="rec-add-row">
            <label>Frequency</label>
            <select id="addFrequency" class="rec-add-input">
              <option value="Monthly">Monthly</option>
              <option value="Quarterly">Quarterly</option>
              <option value="Yearly">Yearly</option>
            </select>
          </div>
          <div class="rec-add-row">
            <label>Account</label>
            <input type="text" id="addAccount" class="rec-add-input" placeholder="Account/Card">
          </div>
        </div>
        <div class="rec-add-row rec-add-notes-row">
          <label>Notes</label>
          <textarea id="addNotes" class="rec-add-input rec-add-textarea" placeholder="Additional notes..."></textarea>
        </div>
      </div>
      <div class="rec-add-actions">
        <button class="rec-add-btn rec-add-cancel-btn" type="button">Cancel</button>
        <button class="rec-add-btn rec-add-save-btn" type="button">Save</button>
      </div>
    `;
    
    overlay.appendChild(popup);
    document.body.appendChild(overlay);
    
    // Set default start date to today
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('addStartDate').value = today;
    
    // Focus the name input
    setTimeout(() => {
      const nameInput = document.getElementById('addName');
      if (nameInput) {
        nameInput.focus();
        nameInput.select();
      }
    }, 100);
    
    // Handle button clicks
    const saveBtn = popup.querySelector('.rec-add-save-btn');
    const cancelBtn = popup.querySelector('.rec-add-cancel-btn');
    
    saveBtn.addEventListener('click', function() {
      saveNewSubscriptionFromPopup(overlay);
    });
    
    cancelBtn.addEventListener('click', function() {
      overlay.remove();
    });
    
    // Handle keyboard events
    popup.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.target.matches('textarea')) {
        e.preventDefault();
        saveBtn.click();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelBtn.click();
      }
    });
    
    // Handle overlay click (close on outside click)
    overlay.addEventListener('click', function(e) {
      if (e.target === overlay) {
        cancelBtn.click();
      }
    });
  }

  /**
   * Save new subscription from popup
   */
  function saveNewSubscriptionFromPopup(overlay) {
    const formData = {
      name: document.getElementById('addName').value.trim(),
      type: document.getElementById('addType').value,
      category: document.getElementById('addCategory').value,
      frequency: document.getElementById('addFrequency').value,
      amount: document.getElementById('addAmount').value.trim(),
      account: document.getElementById('addAccount').value.trim(),
      startDate: document.getElementById('addStartDate').value,
      endDate: document.getElementById('addEndDate').value,
      notes: document.getElementById('addNotes').value.trim()
    };
    
    // Validate required fields
    let hasErrors = false;
    const requiredFields = ['name', 'amount', 'startDate'];
    
    requiredFields.forEach(field => {
      const input = document.getElementById('add' + field.charAt(0).toUpperCase() + field.slice(1));
      if (!formData[field] || (field === 'amount' && parseFloat(formData[field]) <= 0)) {
        input.classList.add('rec-input-error');
        hasErrors = true;
      } else {
        input.classList.remove('rec-input-error');
      }
    });
    
    if (hasErrors) {
      if (window.Utils && Utils.showToast) {
        Utils.showToast('Please fill all required fields (Name, Amount, Start Date)', 'error');
      }
      return;
    }
    
    // Create new item object using existing logic
    const newItem = {
      id: `REC-${Date.now()}`,
      rowIndex: null,
      startDate: new Date(formData.startDate),
      endDate: formData.endDate ? new Date(formData.endDate) : null,
      name: formData.name,
      category: formData.category,
      type: formData.type === 'Subscription' ? 'TRUE' : 'FALSE',
      frequency: formData.frequency,
      amount: parseFloat(formData.amount),
      account: formData.account,
      notes: formData.notes
    };
    
    // Calculate status and dates using existing logic
    const now = new Date();
    const isSubscription = newItem.type === 'TRUE';
    
    if (newItem.endDate) {
      newItem.expiration = calculateExpirationDate(newItem.startDate, newItem.frequency, newItem.endDate, newItem.type);
      
      if (isSubscription) {
        if (newItem.expiration && newItem.expiration < now) {
          newItem.status = 'Ended';
          newItem.nextPayment = null;
        } else if (newItem.expiration) {
          newItem.status = 'Expires';
          newItem.nextPayment = calculateNextPayment(newItem.startDate, newItem.frequency, newItem.endDate);
        } else {
          newItem.status = 'Active';
          newItem.nextPayment = calculateNextPayment(newItem.startDate, newItem.frequency, newItem.endDate);
        }
      } else {
        if (newItem.endDate < now) {
          newItem.status = 'Ended';
          newItem.nextPayment = null;
        } else {
          newItem.status = 'Active';
          newItem.nextPayment = calculateNextPayment(newItem.startDate, newItem.frequency, newItem.endDate);
        }
      }
    } else {
      newItem.status = 'Active';
      newItem.nextPayment = calculateNextPayment(newItem.startDate, newItem.frequency, null);
      newItem.expiration = null;
    }
    
    // Add to data and save using existing logic
    _recurringData.unshift(newItem);
    saveToServer([newItem]);
    
    // Update UI
    updateSummaryCards();
    updateRecurringTable();
    
    // Close popup
    overlay.remove();
    
    if (window.Utils && Utils.showToast) {
      Utils.showToast('Subscription added successfully', 'success');
    }
  }

  /**
   * Add new subscription - Updated to show popup
   */
  function addNewSubscription() {
    console.log('RecurringManager: Opening add subscription popup');
    showAddSubscriptionPopup();
  }

  /**
   * Start editing a row
   */
  function startEditingRow(row, item) {
    console.log('RecurringManager: Start editing', item.id);
    
    // Always reload settings before editing to get current currency
    loadSettings();
    
    row.classList.add('rec-editing');

    const cells = row.querySelectorAll('td');

    // Start Date (0)
    const startDateValue = item.startDate && item.startDate instanceof Date ? 
      item.startDate.toISOString().split('T')[0] : '';
    cells[0].innerHTML = `
      <input type="date" class="rec-edit-input" 
        value="${startDateValue}" 
        data-field="startDate"
        placeholder="Select date"
        required>
    `;

    // Name (1)
    cells[1].innerHTML = `
      <input type="text" class="rec-edit-input" 
        value="${item.name}" 
        data-field="name" 
        placeholder="Subscription name" required>
    `;

    // Category (2)
    cells[2].innerHTML = `
      <select class="rec-edit-input" data-field="category">
        ${_categories.map(cat => 
          `<option value="${cat.fullName}" ${cat.fullName === item.category ? 'selected' : ''}>
            ${cat.emoji} ${cat.name}
          </option>`
        ).join('')}
      </select>
    `;

    // Type (3)
    const currentType = item.type && (item.type.toString().toUpperCase() === 'FALSE' || 
                       item.type.toString().toUpperCase().includes('FIXED') || 
                       item.type.toString().toUpperCase().includes('PAYMENT')) ? 'Payment' : 'Subscription';
    cells[3].innerHTML = `
      <select class="rec-edit-input" data-field="type">
        <option value="Subscription" ${currentType === 'Subscription' ? 'selected' : ''}>Subscription</option>
        <option value="Payment" ${currentType === 'Payment' ? 'selected' : ''}>Fixed Payment</option>
      </select>
    `;

    // Frequency (4) - ONLY Monthly, Quarterly, Yearly
    cells[4].innerHTML = `
      <select class="rec-edit-input" data-field="frequency">
        <option value="Monthly" ${item.frequency === 'Monthly' ? 'selected' : ''}>Monthly</option>
        <option value="Quarterly" ${item.frequency === 'Quarterly' ? 'selected' : ''}>Quarterly</option>
        <option value="Yearly" ${item.frequency === 'Yearly' ? 'selected' : ''}>Yearly</option>
      </select>
    `;

    // Amount (5) - IMPROVEMENT #1: Empty value for new items
    const amountValue = item.isNew ? '' : item.amount;
    cells[5].innerHTML = `
      <div class="rec-amount-wrapper">
        <span class="rec-currency">${_currencySymbol}</span>
        <input type="number" class="rec-edit-input rec-amount" 
          value="${amountValue}" 
          data-field="amount" 
          placeholder="0.00" 
          step="0.01" 
          min="0" required>
      </div>
    `;

    // Account (6)
    cells[6].innerHTML = `
      <input type="text" class="rec-edit-input" 
        value="${item.account}" 
        data-field="account" 
        placeholder="Account/Card">
    `;

    // IMPROVEMENT #5: Reordered columns - Dynamic Date (7) - non-editable (hide if ended filter)
    if (_currentFilter === 'ended') {
      cells[7].style.display = 'none';
    } else {
      cells[7].style.display = '';
      cells[7].innerHTML = `<span class="rec-noneditable">${cells[7].textContent}</span>`;
    }

    // IMPROVEMENT #5: Reordered columns - End Date (8)
    const endDateValue = item.endDate && item.endDate instanceof Date ? 
      item.endDate.toISOString().split('T')[0] : '';
    cells[8].innerHTML = `
      <input type="date" class="rec-edit-input" 
        value="${endDateValue}" 
        data-field="endDate">
    `;

    // Notes (9)
    cells[9].innerHTML = `
      <input type="text" class="rec-edit-input rec-notes-input" 
        value="${item.notes || ''}" 
        data-field="notes" 
        placeholder="Notes">
    `;

    // Actions (10) - IMPROVEMENT #2: Side-by-side buttons
    cells[10].innerHTML = `
      <div class="rec-action-buttons">
        <button class="rec-action-btn rec-save-btn" data-id="${item.id}" title="Save">
          <i class="material-icons">check</i>
        </button>
        <button class="rec-action-btn rec-cancel-btn" data-id="${item.id}" title="Cancel">
          <i class="material-icons">close</i>
        </button>
      </div>
    `;

    const nameInput = cells[1].querySelector('input');
    if (nameInput) {
      nameInput.focus();
      nameInput.select();
    }
  }

  /**
   * Save edited row - ONLY saves when save button is clicked
   */
  function saveEditedRow(itemId) {
    console.log('RecurringManager: Saving row', itemId);
    
    const row = document.querySelector(`tr[data-id="${itemId}"]`);
    if (!row) return;

    const item = _recurringData.find(r => r.id === itemId);
    if (!item) return;

    const editedData = {};
    let hasErrors = false;

    // Validate required fields
    row.querySelectorAll('.rec-edit-input').forEach(input => {
      const field = input.getAttribute('data-field');
      const value = input.value.trim();

      // Check required fields
      if (field === 'name' && !value) {
        input.classList.add('rec-input-error');
        hasErrors = true;
        return;
      }

      if (field === 'startDate' && !value) {
        input.classList.add('rec-input-error');
        hasErrors = true;
        return;
      }

      if (field === 'amount' && (!value || parseFloat(value) <= 0)) {
        input.classList.add('rec-input-error');
        hasErrors = true;
        return;
      }

      input.classList.remove('rec-input-error');
      
      if (field === 'type') {
        editedData[field] = value === 'Subscription' ? 'TRUE' : 'FALSE';
      } else {
        editedData[field] = value;
      }
    });

    if (hasErrors) {
      if (window.Utils && Utils.showToast) {
        Utils.showToast('Please fill in all required fields (Name, Start Date, Amount)', 'error');
      }
      return;
    }

    // Update item with edited data
    Object.assign(item, editedData);
    
    if (editedData.startDate) {
      item.startDate = new Date(editedData.startDate);
    }
    if (editedData.endDate) {
      item.endDate = new Date(editedData.endDate);
    }
    
    item.amount = parseFloat(editedData.amount) || 0;

    // Recalculate status and dates
    const now = new Date();
    const isSubscription = item.type && item.type.toString().toUpperCase() === 'TRUE';
    
    // Only calculate expiration if there's an end date
    if (item.endDate) {
      item.expiration = calculateExpirationDate(item.startDate, item.frequency, item.endDate, item.type);
      
      if (isSubscription) {
        // For subscriptions, use calculated expiration date
        if (item.expiration && item.expiration < now) {
          item.status = 'Ended';
          item.nextPayment = null;
        } else if (item.expiration) {
          // Any subscription with an expiration date shows as "Expires"
          item.status = 'Expires';
          item.nextPayment = calculateNextPayment(item.startDate, item.frequency, item.endDate);
        } else {
          item.status = 'Active';
          item.nextPayment = calculateNextPayment(item.startDate, item.frequency, item.endDate);
        }
      } else {
        // For fixed payments, use raw end date
        if (item.endDate < now) {
          item.status = 'Ended';
          item.nextPayment = null;
        } else if (item.endDate < new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000)) {
          item.status = 'Expires';
          item.nextPayment = calculateNextPayment(item.startDate, item.frequency, item.endDate);
        } else {
          item.status = 'Active';
          item.nextPayment = calculateNextPayment(item.startDate, item.frequency, item.endDate);
        }
      }
    } else {
      // No end date = Active subscription
      item.status = 'Active';
      item.nextPayment = calculateNextPayment(item.startDate, item.frequency, null);
      item.expiration = null;
    }

    // For new items, generate a proper ID if still using temporary ID
    if (item.isNew || item.id.startsWith('new-')) {
      item.id = `REC-${Date.now()}`;
    }
    
    // Always remove the isNew flag after successful save
    delete item.isNew;

    // Save to server
    saveToServer([item]);

    // Replace row with updated view
    const newRow = createRecurringRow(item);
    row.replaceWith(newRow);

    // Update summary metrics
    updateSummaryCards();
  }

  /**
   * Cancel editing
   */
  function cancelEditingRow(itemId) {
    console.log('RecurringManager: Cancel editing', itemId);
    
    const row = document.querySelector(`tr[data-id="${itemId}"]`);
    if (!row) return;

    const item = _recurringData.find(r => r.id === itemId);
    if (!item) return;

    if (item.isNew) {
      _recurringData = _recurringData.filter(r => r.id !== itemId);
      row.remove();
    } else {
      const newRow = createRecurringRow(item);
      row.replaceWith(newRow);
    }
  }

  /**
   * Edit recurring item
   */
  function editRecurringItem(itemId) {
    console.log('RecurringManager: Edit item', itemId);
    
    const row = document.querySelector(`tr[data-id="${itemId}"]`);
    const item = _recurringData.find(r => r.id === itemId);
    
    if (row && item) {
      startEditingRow(row, item);
    }
  }

  /**
   * Show custom confirmation dialog
   */
  function showConfirmDialog(message, onConfirm, onCancel) {
    // Remove any existing dialog
    const existingDialog = document.querySelector('.rec-confirm-dialog');
    if (existingDialog) {
      existingDialog.remove();
    }
    
    // Create dialog overlay
    const overlay = document.createElement('div');
    overlay.className = 'rec-confirm-overlay';
    
    // Create dialog
    const dialog = document.createElement('div');
    dialog.className = 'rec-confirm-dialog';
    
    dialog.innerHTML = `
      <div class="rec-confirm-header">
        <h3>Confirm Delete</h3>
      </div>
      <div class="rec-confirm-body">
        <p>${message}</p>
      </div>
      <div class="rec-confirm-actions">
        <button class="rec-confirm-btn rec-cancel-btn" type="button">Cancel</button>
        <button class="rec-confirm-btn rec-delete-btn" type="button">Delete</button>
      </div>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Focus the delete button
    const deleteBtn = dialog.querySelector('.rec-delete-btn');
    const cancelBtn = dialog.querySelector('.rec-cancel-btn');
    
    setTimeout(() => deleteBtn.focus(), 100);
    
    // Handle button clicks
    deleteBtn.addEventListener('click', function() {
      overlay.remove();
      if (onConfirm) onConfirm();
    });
    
    cancelBtn.addEventListener('click', function() {
      overlay.remove();
      if (onCancel) onCancel();
    });
    
    // Handle keyboard events
    dialog.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        deleteBtn.click();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelBtn.click();
      }
    });
    
    // Handle overlay click (close on outside click)
    overlay.addEventListener('click', function(e) {
      if (e.target === overlay) {
        cancelBtn.click();
      }
    });
  }

  /**
   * Delete recurring item
   */
  function deleteRecurringItem(itemId) {
    console.log('RecurringManager: Delete item', itemId);
    
    const item = _recurringData.find(r => r.id === itemId);
    if (!item) return;

    showConfirmDialog(
      `Are you sure you want to delete "${item.name}"?`,
      function() {
        // On confirm - delete the item
        const row = document.querySelector(`tr[data-id="${itemId}"]`);
        if (row) row.remove();

        _recurringData = _recurringData.filter(r => r.id !== itemId);
        
        updateSummaryCards();

        if (window.API && typeof API.clearRecurringRow === 'function') {
          API.clearRecurringRow(itemId, 
            function(result) {
              console.log('RecurringManager: Item deleted on server');
              if (window.Utils && Utils.showToast) {
                Utils.showToast(`"${item.name}" deleted successfully`, 'success');
              }
            },
            function(error) {
              console.error('RecurringManager: Delete error', error);
              if (window.Utils && Utils.showToast) {
                Utils.showToast('Error deleting item: ' + error, 'error');
              }
            }
          );
        }
      },
      function() {
        // On cancel - do nothing
        console.log('RecurringManager: Delete cancelled');
      }
    );
  }

  /**
   * Save data to server - UPDATED VERSION
   */
  function saveToServer(items) {
    console.log('RecurringManager: Saving to server', items.length, 'items');
    
    if (!window.API || typeof API.saveBatchRecurring !== 'function') {
      console.error('RecurringManager: API.saveBatchRecurring not available');
      return;
    }

    // Filter out items without required fields before saving
    const validItems = items.filter(item => 
      item.name && item.amount > 0 && item.startDate
    );

    if (validItems.length === 0) {
      console.log('RecurringManager: No valid items to save');
      return;
    }

    // Prepare items for saving - ensure proper date formatting
    const itemsToSave = validItems.map(item => {
      const saveItem = {
        id: item.id,
        name: item.name,
        category: item.category,
        type: item.type,
        frequency: item.frequency,
        amount: item.amount,
        account: item.account,
        status: item.status,
        notes: item.notes || ''
      };
      
      // Handle dates - convert to ISO strings for transmission
      if (item.startDate instanceof Date) {
        saveItem.startDate = item.startDate.toISOString();
      } else if (item.startDate) {
        saveItem.startDate = new Date(item.startDate).toISOString();
      }
      
      if (item.endDate instanceof Date) {
        saveItem.endDate = item.endDate.toISOString();
      } else if (item.endDate) {
        saveItem.endDate = new Date(item.endDate).toISOString();
      }
      
      if (item.nextPayment instanceof Date) {
        saveItem.nextPayment = item.nextPayment.toISOString();
      } else if (item.nextPayment) {
        saveItem.nextPayment = new Date(item.nextPayment).toISOString();
      }
      
      return saveItem;
    });

    if (window.Utils && Utils.showToast) {
      Utils.showToast('Saving...', 'info');
    }

    API.saveBatchRecurring(itemsToSave,
      function(result) {
        console.log('RecurringManager: Save success', result);
        
        if (window.Utils && Utils.showToast) {
          const message = result.inserted > 0 ? 
            `Saved successfully (${result.inserted} added, ${result.updated} updated)` :
            'Updated successfully';
          Utils.showToast(message, 'success');
        }
        
        // Update cache after successful save
        if (window._cache && typeof _cache.invalidate === 'function') {
          _cache.invalidate('recurring');
        }
        
        // Refresh the data to get proper row indices
        // This ensures new items get their proper IDs from the spreadsheet
        setTimeout(() => {
          loadRealRecurringData(true); // true = background refresh
        }, 500);
      },
      function(error) {
        console.error('RecurringManager: Save error', error);
        if (window.Utils && Utils.showToast) {
          Utils.showToast('Error saving: ' + error, 'error');
        }
      }
    );
  }

  /**
   * Update summary cards only
   */
  function updateSummaryCards() {
    const metrics = calculateBannerMetrics();
    
    const elements = {
      activeSubscriptionsCount: getElement('activeSubscriptionsCount'),
      annualProjection: getElement('annualProjection'),
      budgetImpact: getElement('budgetImpact'),
      monthlyAverage: getElement('monthlyAverage')
    };

    if (elements.activeSubscriptionsCount) {
      elements.activeSubscriptionsCount.textContent = metrics.activeSubscriptions;
    }
    if (elements.annualProjection) {
      elements.annualProjection.textContent = formatCurrency(metrics.annualProjection);
    }
    if (elements.budgetImpact) {
      elements.budgetImpact.textContent = metrics.budgetImpact.toFixed(1) + '%';
    }
    if (elements.monthlyAverage) {
      elements.monthlyAverage.textContent = formatCurrency(metrics.monthlyAverage);
    }
  }

  /**
   * Bind event listeners - SIMPLE VERSION
   */
  function bindEvents() {
    console.log('RecurringManager: Binding events...');

    // Use event delegation on the container for all dynamic content
    const container = getElement('recurringContent');
    if (!container) return;

    // Check if we already bound events to this container
    if (container.dataset.eventsbound === 'true') {
      console.log('RecurringManager: Events already bound to container');
      return;
    }

    // Single click handler for everything
    container.addEventListener('click', function(e) {
      // Filter buttons
      if (e.target.classList.contains('rec-filter-btn') && e.target.hasAttribute('data-status')) {
        document.querySelectorAll('.rec-filter-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        e.target.classList.add('active');
        _currentFilter = e.target.getAttribute('data-status');
        
        // Update table and header based on new filter
        updateDynamicDateHeader(_currentFilter);
        updateRecurringTable();
        return;
      }

      // Add button
      if (e.target.id === 'addSubscriptionBtn' || e.target.closest('#addSubscriptionBtn')) {
        addNewSubscription();
        return;
      }

      // Notes cell
      const notesCell = e.target.closest('.rec-notes-cell');
      if (notesCell && notesCell.dataset.notes) {
        e.stopPropagation();
        const rect = notesCell.getBoundingClientRect();
        showNotesPopup(notesCell.dataset.notes, rect);
        return;
      }

      // Action buttons
      const button = e.target.closest('button');
      if (button) {
        const itemId = button.getAttribute('data-id');
        if (!itemId) return;

        if (button.classList.contains('rec-edit-btn')) {
          editRecurringItem(itemId);
        } else if (button.classList.contains('rec-delete-btn')) {
          deleteRecurringItem(itemId);
        } else if (button.classList.contains('rec-save-btn')) {
          saveEditedRow(itemId);
        } else if (button.classList.contains('rec-cancel-btn')) {
          cancelEditingRow(itemId);
        }
      }
    });

    // Category filter change
    container.addEventListener('change', function(e) {
      if (e.target.id === 'categoryFilter') {
        updateRecurringTable();
      }
    });

    // Enter key to save
    container.addEventListener('keypress', function(e) {
      if (e.key === 'Enter' && e.target.classList.contains('rec-edit-input')) {
        const row = e.target.closest('tr');
        if (row) {
          const saveBtn = row.querySelector('.rec-save-btn');
          if (saveBtn) saveBtn.click();
        }
      }
    });

    // Currency change listener - only add once
    if (!window._recurringCurrencyListener) {
      window._recurringCurrencyListener = function(event) {
        _currencySymbol = event.detail.symbol;
        updateSummaryCards();
        updateRecurringTable();
      };
      document.addEventListener('currency-changed', window._recurringCurrencyListener);
    }

    // Settings change listener - only add once
    if (!window._recurringSettingsListener) {
      window._recurringSettingsListener = function() {
        loadSettings();
        updateSummaryCards();
        updateRecurringTable();
      };
      document.addEventListener('settings-changed', window._recurringSettingsListener);
    }

    // Mark container as having events bound
    container.dataset.eventsbound = 'true';
  }

  /**
   * Refresh recurring data
   */
  function refresh() {
    console.log('RecurringManager: Refresh triggered');
    
    // Clear cache in main system
    if (window._cache && typeof _cache.invalidate === 'function') {
      window._cache.invalidate('recurring');
    }
    
    // Clear local data
    _recurringData = [];
    
    // Reset initialization flag
    _initialized = false;
    
    // Clear element cache
    Object.keys(_elements).forEach(key => {
      delete _elements[key];
    });
    
    // Re-initialize without cached data to force fresh load
    init('recurringContent', null);
  }

  /**
   * Set recurring data from external source
   */
  function setRecurringData(recurringData) {
    if (!recurringData || !Array.isArray(recurringData)) {
      console.warn('RecurringManager: Invalid recurring data');
      return;
    }

    _recurringData = processRecurringData(recurringData);
    
    if (_initialized) {
      updateSummaryCards();
      updateRecurringTable();
    }
  }

  // Public API
  return {
    init: init,
    refresh: refresh,
    setRecurringData: setRecurringData,
    isInitialized: function() { return _initialized; }
  };
})();

// Expose globally
window.RecurringManager = RecurringManager;
</script>

<style>
/* ==============================================================
   RECURRING MANAGEMENT - ENHANCED STYLES
   ==============================================================
*/

/* ======== LOADING & ERROR STATES ======== */
.rec-loading, .rec-error {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  text-align: center;
}

.rec-loading-text {
  margin-top: 16px;
  color: var(--text-secondary, #666);
}

.rec-error {
  background-color: #ffebee;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

/* ======== NOTES POPUP ======== */
.rec-notes-popup {
  position: absolute;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 10px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  max-width: 300px;
  z-index: 1000;
  font-size: 14px;
  word-wrap: break-word;
}

body.dark-mode .rec-notes-popup {
  background: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

/* ======== ADD SUBSCRIPTION POPUP ======== */
.rec-add-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  backdrop-filter: blur(2px);
}

.rec-add-popup {
  background: white;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
  min-width: 400px;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  animation: rec-dialog-appear 0.2s ease-out;
}

.rec-add-header {
  background-color: #fe9aa1;
  padding: 16px 20px;
  border-bottom: 1px solid #eee;
}

.rec-add-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.rec-add-body {
  padding: 8px;
  max-height: 60vh;
  overflow-y: auto;
}

.rec-add-row {
  margin-bottom: 16px;
}

.rec-add-row label {
  display: block;
  font-size: 14px;
  font-weight: 500;
  color: #2c3e50;
  margin-bottom: 6px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.rec-add-input {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #ddd;
  border-radius: 0px;
  font-size: 14px;
  background-color: white;
  color: #2c3e50;
  box-sizing: border-box;
}

.rec-add-input:focus {
  border-color: #2c3e50;
  outline: none;
  box-shadow: 0 0 0 2px rgba(44, 62, 80, 0.2);
}

.rec-add-textarea {
  height: 40px;
  resize: vertical;
  font-family: inherit;
}

.rec-add-amount-wrapper {
  position: relative;
  width: 100%;
}

.rec-add-currency {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: #666;
  z-index: 1;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.rec-add-amount {
  padding-left: 36px !important;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.rec-add-actions {
  padding: 16px 20px;
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  border-top: 1px solid #eee;
}

.rec-add-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 0px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  min-width: 80px;
}

.rec-add-cancel-btn {
  background-color: #f5f5f5;
  color: #666;
  border: 1px solid #ddd;
}

.rec-add-cancel-btn:hover {
  background-color: #e8e8e8;
  color: #2c3e50;
}

.rec-add-save-btn {
  background-color: #2c3e50;
  color: white;
}

.rec-add-save-btn:hover {
  background-color: #1984c5;
}

.rec-add-btn:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(44, 62, 80, 0.3);
}

/* Dark mode for add subscription popup */
body.dark-mode .rec-add-popup {
  background: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .rec-add-header {
  background-color: var(--dark-surface, #1e1e1e);
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-add-header h3 {
  color: #DDA15E;
}

body.dark-mode .rec-add-row label {
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .rec-add-input {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-add-input:focus {
  border-color: #DDA15E;
  box-shadow: 0 0 0 2px rgba(221, 161, 94, 0.3);
}

body.dark-mode .rec-add-currency {
  color: rgba(255, 255, 255, 0.6);
}

body.dark-mode .rec-add-actions {
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-add-cancel-btn {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-secondary, rgba(255, 255, 255, 0.6));
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-add-cancel-btn:hover {
  background-color: rgba(255, 255, 255, 0.05);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .rec-add-save-btn {
  background-color: #DDA15E;
  color: #1e1e1e;
}

body.dark-mode .rec-add-save-btn:hover {
  background-color: #c9955a;
}

body.dark-mode .rec-add-btn:focus {
  box-shadow: 0 0 0 2px rgba(221, 161, 94, 0.3);
}

/* Mobile responsive for add popup */
@media (max-width: 768px) {
  .rec-add-popup {
    width: 95%;
    max-width: 95%;
    margin: 10px;
  }
  
  /* Single column on mobile */
  .rec-add-grid {
    grid-template-columns: 1fr;
    gap: 16px;
  }
  
  .rec-add-row {
    margin-bottom: 16px;
  }
  
  .rec-add-body {
    padding: 16px;
  }
  
  .rec-add-actions {
    padding: 12px 16px;
    flex-direction: column;
  }
  
  .rec-add-btn {
    width: 100%;
  }
}
.rec-confirm-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  backdrop-filter: blur(2px);
}

.rec-confirm-dialog {
  background: white;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
  min-width: 320px;
  max-width: 480px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  animation: rec-dialog-appear 0.2s ease-out;
}

@keyframes rec-dialog-appear {
  from {
    opacity: 0;
    transform: scale(0.9) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.rec-confirm-header {
  background-color: #fe9aa1;
  padding: 16px 20px;
  border-bottom: 1px solid #eee;
}

.rec-confirm-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.rec-confirm-body {
  padding: 20px;
}

.rec-confirm-body p {
  margin: 0;
  font-size: 15px;
  color: #2c3e50;
  line-height: 1.4;
}

.rec-confirm-actions {
  padding: 16px 20px;
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  border-top: 1px solid #eee;
}

.rec-confirm-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 0px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  min-width: 80px;
}

.rec-confirm-btn.rec-cancel-btn {
  background-color: #f5f5f5;
  color: #666;
  border: 1px solid #ddd;
}

.rec-confirm-btn.rec-cancel-btn:hover {
  background-color: #e8e8e8;
  color: #2c3e50;
}

.rec-confirm-btn.rec-delete-btn {
  background-color: transparent;
  color: #f44336;
  border: 1px solid #f44336;
}

.rec-confirm-btn.rec-delete-btn:hover {
  background-color: rgba(244, 67, 54, 0.1);
  color: #d32f2f;
}

.rec-confirm-btn:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(244, 67, 54, 0.3);
}

/* Dark mode for confirmation dialog */
body.dark-mode .rec-confirm-dialog {
  background: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .rec-confirm-header {
  background-color: var(--dark-surface, #1e1e1e);
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-confirm-header h3 {
  color: #DDA15E;
}

body.dark-mode .rec-confirm-body p {
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .rec-confirm-actions {
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-confirm-btn.rec-cancel-btn {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-secondary, rgba(255, 255, 255, 0.6));
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-confirm-btn.rec-cancel-btn:hover {
  background-color: rgba(255, 255, 255, 0.05);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .rec-confirm-btn.rec-delete-btn:focus {
  box-shadow: 0 0 0 2px rgba(239, 83, 80, 0.3);
}

body.dark-mode .rec-confirm-btn.rec-delete-btn {
  background-color: transparent;
  color: #ef5350;
  border-color: #ef5350;
}

body.dark-mode .rec-confirm-btn.rec-delete-btn:hover {
  background-color: rgba(239, 83, 80, 0.1);
  color: #f44336;
}

/* ======== SUMMARY BOX ======== */
.rec-summary-row {
  margin-bottom: 16px;
  display: flex;
  justify-content: center;
}

.rec-summary-box {
  background-color: #fe9aa1;
  border-radius: 0px;
  padding: 20px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
  width: 100%;
}

.rec-box-content {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}

.rec-box-item {
  flex: 1 0 calc(50% - 10px);
  padding: 8px;
  text-align: center;
  margin-bottom: 5px;
}

.rec-box-label {
  font-size: 12px;
  color: black;
  margin-bottom: 4px;
  font-family: sans-serif;
}

.rec-box-value {
  font-size: 18px;
  font-weight: 600;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* Hide summary on mobile */
@media (max-width: 768px) {
  .rec-summary-row {
    display: none;
  }
}

/* Add button styling */
.rec-add-subscription-btn {
  background-color: #2c3e50;
  color: white;
  border: none;
  border-radius: 0px;
  padding: 8px 12px;
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 13px;
  cursor: pointer;
  transition: background-color 0.2s;
  margin-left: 8px;
}

.rec-add-subscription-btn:hover {
  background-color: #1984c5;
}

.rec-add-subscription-btn i {
  font-size: 18px;
}

/* ======== TABLE SECTION ======== */
.rec-table-container {
  background-color: #ffffff;
  border-radius: 0px;
  padding: 20px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

.rec-table-header {
  display: flex;
  flex-direction: column;
  margin-bottom: 16px;
}

.rec-filters {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 8px;
}

.rec-status-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.rec-filter-btn {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
  border-radius: 0px;
  padding: 8px 12px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
}

.rec-filter-btn.active {
  background-color: #2c3e50;
  color: white;
  border-color: #2c3e50;
}

.rec-filter-select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 0px;
  font-size: 14px;
}

.rec-table-wrapper {
  overflow-x: auto;
  margin-bottom: 16px;
}

.rec-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}

/* IMPROVEMENT #6: Reduced table padding and max 10px gap */
.rec-table th,
.rec-table td {
  padding: 6px 5px;
  text-align: center;
  border-bottom: 1px solid #eee;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.rec-table th {
  font-weight: 500;
  color: #607d8b;
  position: sticky;
  top: 0;
  background-color: white;
  z-index: 10;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* IMPROVEMENT #6: Updated column widths for full text */
.rec-type-header,
.rec-type-cell {
  width: 80px !important;
  max-width: 80px !important;
}

.rec-frequency-header,
.rec-frequency-cell {
  width: 90px !important;
  max-width: 90px !important;
}

.rec-amount-header,
.rec-amount-cell {
  width: 80px !important;
  max-width: 80px !important;
}

.rec-account-header,
.rec-account-cell {
  width: 80px !important;
  max-width: 80px !important;
}

/* Name cell - prevent wrapping */
.rec-name-cell {
  max-width: 200px;
  text-align: left !important;
}

.rec-name-content {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: left;
}

/* Notes cell styling */
.rec-notes-cell {
  width: 40px;
  text-align: center;
  cursor: pointer;
  color: #666;
}

.rec-notes-cell:hover {
  color: #2c3e50;
  background-color: rgba(0,0,0,0.05);
}

.rec-notes-header {
  width: 40px !important;
  text-align: center !important;
  padding: 6px 5px !important;
}

/* Notes input in edit mode */
.rec-notes-input {
  max-width: 100px;
}

.rec-table tbody tr {
  transition: background-color 0.2s;
}

.rec-table tbody tr:hover {
  filter: brightness(0.95);
}

.rec-table tbody tr.rec-editing {
  box-shadow: 0 0 0 2px #2c3e50;
  position: relative;
  z-index: 5;
}

.rec-amount-cell {
  font-weight: 500;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
  color: #2c3e50;
}

/* IMPROVEMENT #2: Side-by-side action buttons */
.rec-action-buttons {
  display: flex;
  gap: 4px;
  justify-content: center;
  align-items: center;
}

.rec-action-btn {
  background: none;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #666;
  width: 32px;
  height: 32px;
  border-radius: 0px;
}

.rec-action-btn:hover {
  background-color: rgba(0,0,0,0.05);
  color: #2c3e50;
}

.rec-actions-cell {
  white-space: nowrap;
}

.rec-save-btn {
  color: #4caf50;
}

.rec-cancel-btn {
  color: #757575;
}

/* IMPROVEMENT #3: Red X icon for delete button */
.rec-delete-btn {
  color: #f44336 !important;
}

.rec-delete-btn:hover {
  background-color: rgba(244, 67, 54, 0.1) !important;
  color: #d32f2f !important;
}

.rec-edit-input {
  width: 100%;
  padding: 6px 8px;
  border: 1px solid #ddd;
  border-radius: 0px;
  font-size: 14px;
}

.rec-input-error {
  border-color: #f44336 !important;
  background-color: rgba(244, 67, 54, 0.1) !important;
}

.rec-noneditable {
  color: #999;
  font-style: italic;
}

/* Status classes for dynamic date column */
.rec-dynamic-date-cell.status-active {
  color: #2e7d32;
}

.rec-dynamic-date-cell.status-expires {
  color: #ff9800;
}

.rec-dynamic-date-cell.status-ended {
  color: #d32f2f;
}

/* Full text display for type and frequency */
.rec-type-cell,
.rec-frequency-cell {
  font-size: 13px !important;
}

.rec-type-full,
.frequency-full {
  font-weight: 500;
  font-size: 13px !important;
  display: inline-block;
}

/* Make sure frequency shows up properly */
.rec-frequency-cell .frequency-full {
  display: inline-block !important;
}

/* Mobile optimizations */
@media (max-width: 768px) {
  .rec-table {
    font-size: 12px;
  }
  
  /* Hide start date column on mobile */
  .rec-startdate-cell,
  .rec-table th:nth-child(1) {
    display: none;
  }
  
  /* Name column */
  .rec-name-cell,
  .rec-table th:nth-child(2) {
    max-width: 80px;
  }
  
  /* Category emoji column */
  .rec-category-cell,
  .rec-table th:nth-child(3) {
    width: 30px;
    max-width: 30px;
  }
  
  /* End date column - hide on mobile */
  .rec-enddate-cell,
  .rec-table th:nth-child(9) {
    display: none;
  }
  
  /* Dynamic date column */
  .rec-dynamic-date-cell,
  .rec-table th:nth-child(8) {
    width: 70px;
  }
  
  /* Notes column */
  .rec-notes-cell,
  .rec-table th:nth-child(10) {
    width: 30px;
  }
  
  /* Actions column */
  .rec-actions-cell,
  .rec-table th:nth-child(11) {
    width: 60px;
    padding-left: 0;
    padding-right: 0;
  }
  
  /* Action button smaller */
  .rec-action-btn {
    width: 28px;
    height: 28px;
  }
  
  .rec-action-btn i {
    font-size: 16px;
  }
  
  /* Filter adjustments */
  .rec-filter-btn {
    padding: 6px 8px;
    font-size: 11px;
  }
  
  /* Show abbreviated text on mobile for space */
  .rec-type-cell .rec-type-full {
    font-size: 11px;
  }
  
  .rec-frequency-cell .frequency-full {
    font-size: 11px;
  }
}

@media (min-width: 769px) {
  /* Show frequency letter only on desktop too for consistency */
  .frequency-full {
    display: none;
  }
  
  .frequency-letter {
    display: inline-block;
    font-weight: bold;
  }
}

/* Emoji-only category display */
.category-emoji-only {
  font-size: 16px !important;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  width: 100%;
}

.rec-category-cell:hover .category-emoji-only {
  transform: scale(1.1);
  transition: transform 0.2s ease;
}

.rec-table th:nth-child(3) {
  width: 40px !important;
}

.rec-category-cell {
  width: 40px !important;
  cursor: help;
}

/* Currency input wrapper */
.rec-amount-wrapper {
  position: relative;
  width: 100%;
}

.rec-currency {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: #666;
  z-index: 1;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.rec-amount {
  padding-left: 36px !important;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* iOS-specific fix for date inputs */
input[type="date"].rec-edit-input {
  width: 100% !important;
  min-width: 100% !important;
  max-width: 100% !important;
  -webkit-appearance: none;
  appearance: none;
  display: block !important;
}

/* ======== DARK MODE SUPPORT ======== */
body.dark-mode .rec-summary-box {
  background-color: var(--dark-surface, #1e1e1e) !important;
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87)) !important;
}

body.dark-mode .rec-table-container {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .rec-box-label,
body.dark-mode .rec-table th {
  color: var(--dark-text-secondary, rgba(255, 255, 255, 0.6)) !important;
}

body.dark-mode .rec-box-value,
body.dark-mode .rec-amount-cell {
  color: #DDA15E !important;
}

body.dark-mode .rec-currency {
  color: rgba(255, 255, 255, 0.6) !important;
}

body.dark-mode .rec-filter-select,
body.dark-mode .rec-filter-btn,
body.dark-mode .rec-edit-input {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-table td {
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-table th {
  background-color: var(--dark-surface, #1e1e1e);
}

body.dark-mode .rec-action-btn {
  color: var(--dark-text-secondary, rgba(255, 255, 255, 0.6));
}

body.dark-mode .rec-action-btn:hover {
  background-color: rgba(255, 255, 255, 0.1);
  color: #DDA15E;
}

body.dark-mode .category-emoji-only {
  color: #ffffff !important;
  text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
}

body.dark-mode .rec-filter-btn.active {
  background-color: #DDA15E;
  border-color: #DDA15E;
  color: #1e1e1e;
}

body.dark-mode .rec-add-subscription-btn {
  background-color: #DDA15E;
  color: #1e1e1e;
}

body.dark-mode .rec-add-subscription-btn:hover {
  background-color: #c9955a;
}

body.dark-mode .rec-dynamic-date-cell.status-active {
  color: #4caf50;
}

body.dark-mode .rec-dynamic-date-cell.status-expires {
  color: #ffb74d;
}

body.dark-mode .rec-dynamic-date-cell.status-ended {
  color: #ef5350;
}

body.dark-mode .rec-notes-cell {
  color: rgba(255, 255, 255, 0.6);
}

body.dark-mode .rec-notes-cell:hover {
  color: #DDA15E;
}

/* IMPROVEMENT #3: Dark mode delete button styling */
body.dark-mode .rec-delete-btn {
  color: #ef5350 !important;
}

body.dark-mode .rec-delete-btn:hover {
  background-color: rgba(239, 83, 80, 0.1) !important;
  color: #f44336 !important;
}

/* ======== DESKTOP STYLES ======== */
@media (min-width: 769px) {
  .rec-box-item {
    flex: 1;
  }
  
  .rec-box-label {
    font-size: 14px;
  }
  
  .rec-box-value {
    font-size: 22px;
  }
  
  .rec-filters {
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
  }
  
  .rec-status-filters {
    flex: 3;
  }
  
  .rec-category-filter {
    flex: 1;
    max-width: 200px;
  }
  
  .rec-table {
    font-size: 15px;
  }
  
  .rec-table-container,
  .rec-summary-box {
    margin-left: auto;
    margin-right: auto;
    max-width: 85%;
  }
}

/* Empty message styling */
.rec-empty-message {
  text-align: center;
  color: #999;
  font-style: italic;
  padding: 20px !important;
}

/* Hide Next Payment column completely when display is none */
.rec-dynamic-date-header[style*="display: none"],
.rec-dynamic-date-cell[style*="display: none"] {
  width: 0 !important;
  padding: 0 !important;
  border: none !important;
}

/* Add this to your CSS section */
.rec-add-grid {
  display: grid;
  grid-template-columns: 1fr 1fr; /* Two equal columns */
  gap: 10px;
  margin-bottom: 0px;
}

/* Keep your existing mobile rule which changes it to 1 column */
@media (max-width: 768px) {
  .rec-add-grid {
    grid-template-columns: 1fr;
  }
}

</style>