<!-- recurring.js.html - Simplified Version With Emoji-Only Display -->
<script>
/**
 * RecurringManager - Recurring transactions management component for SimBudget
 */
var RecurringManager = (function() {
  // Private variables
  let _initialized = false;
  let _recurringData = [];
  let _categories = [];
  let _activeFilter = 'active'; // Default filter: show active items
  let _editingRow = null;
  let _isAddingNew = false; // Flag to track if we're adding a new subscription
  
  // Constants for status types with matching color scheme (more transparent)
  const STATUS_TYPES = {
    ACTIVE: {value: 'Active', color: 'rgba(214, 234, 204, 0.3)'}, // Green with 30% opacity
    EXPIRES: {value: 'Expires', color: 'rgba(255, 232, 179, 0.3)'}, // Yellow with 30% opacity
    ENDED: {value: 'Ended', color: 'rgba(248, 215, 218, 0.3)'}  // Pink with 30% opacity
  };

  // Constants for frequency options - only the ones used in the spreadsheet
  const FREQUENCY_OPTIONS = [
    'Monthly',
    'Yearly',
    'Quarterly'
  ];

  // DOM element cache
  const _elements = {};
  
  /**
   * Get an element by ID with caching
   */
  function getElement(id) {
    if (!_elements[id]) {
      _elements[id] = document.getElementById(id);
    }
    return _elements[id];
  }
  
  /**
   * Initialize the Recurring Manager
   */
  function init(containerId) {
    if (_initialized && !containerId) {
      return;
    }
    
    console.log('Initializing Recurring Manager...', containerId);
    
    // Find container element
    const container = containerId ? 
      document.getElementById(containerId) : 
      getElement('recurringContent');
    
    if (!container) {
      console.error('Recurring container not found');
      return;
    }
    
    // Store container in elements cache
    _elements['recurringContent'] = container;
    
    try {
      // Load categories from CategoriesManager if available
      loadCategories();
      
      // Load sample data for immediate display
      loadSampleData();
      
      // Render the recurring view
      renderRecurringView();
      
      // Set up event handlers
      bindEvents();
      
      _initialized = true;
      console.log('Recurring Manager initialized successfully!');
    } catch (err) {
      console.error('Error initializing RecurringManager:', err);
      
      // Fallback to simple render if something goes wrong
      container.innerHTML = `
        <div class="rec-error">
          <h3>Advanced Recurring Module</h3>
          <p>Loaded with sample data. Backend integration coming soon.</p>
          <div class="rec-sample-table">
            <table>
              <tr>
                <th>Name</th>
                <th>Amount</th>
                <th>Frequency</th>
                <th>Status</th>
              </tr>
              <tr style="background-color: #d6eacc">
                <td>Netflix</td>
                <td>‚Ç¨15.99</td>
                <td>Monthly</td>
                <td>Active</td>
              </tr>
              <tr style="background-color: #ffe8b3">
                <td>Domain Hosting</td>
                <td>‚Ç¨30.00</td>
                <td>Yearly</td>
                <td>Expires</td>
              </tr>
            </table>
          </div>
        </div>
      `;
    }
  }

  /**
   * Parse category string to extract name and emoji
   * Format: "Business üíº" -> {name: "Business", emoji: "üíº"}
   */
  function parseCategoryNameAndEmoji(categoryString) {
    // Split by space and check if last part is an emoji
    const parts = categoryString.trim().split(' ');
    
    if (parts.length >= 2) {
      // Check if the last part contains emoji characters
      const lastPart = parts[parts.length - 1];
      const emojiRegex = /[\u{1F600}-\u{1F6FF}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
      
      if (emojiRegex.test(lastPart)) {
        // Last part contains emoji, split name and emoji
        const name = parts.slice(0, -1).join(' ');
        const emoji = lastPart;
        return { name, emoji };
      }
    }
    
    // No emoji found, return the whole string as name
    return { name: categoryString, emoji: '' };
  }

  /**
   * Load categories from CategoriesManager or create defaults
   */
  function loadCategories() {
    console.log('Loading categories for recurring manager...');
    
    try {
      if (window.CategoriesManager && typeof CategoriesManager.getCategories === 'function') {
        const rawCategories = CategoriesManager.getCategories();
        console.log('Loaded raw categories from CategoriesManager:', rawCategories.length);
        
        // Process categories to extract emojis
        _categories = rawCategories.map(cat => {
          // If category is already an object with name and emoji
          if (typeof cat === 'object' && cat.name) {
            return cat;
          }
          
          // Otherwise parse from string format
          const categoryString = typeof cat === 'string' ? cat : cat.name || '';
          const parsed = parseCategoryNameAndEmoji(categoryString);
          return {
            name: parsed.name,
            fullName: categoryString, // Store the full name for filtering/matching
            emoji: parsed.emoji
          };
        });
        
        console.log('Processed categories with emoji extraction:', _categories.length);
      } else {
        throw new Error('CategoriesManager not available');
      }
    } catch (err) {
      console.log('Using default categories:', err.message);
      // Default categories with emoji icons if CategoriesManager not available
      _categories = [
        {name: 'Housing', emoji: 'üè°', fullName: 'Housing üè°'},
        {name: 'Transport', emoji: 'üöó', fullName: 'Transport üöó'},
        {name: 'Utilities', emoji: 'üí°', fullName: 'Utilities üí°'},
        {name: 'Fun', emoji: 'üé¨', fullName: 'Fun üé¨'},
        {name: 'Business', emoji: 'üíº', fullName: 'Business üíº'},
        {name: 'Personal care', emoji: '‚ù§Ô∏è', fullName: 'Personal care ‚ù§Ô∏è'},
        {name: 'Donation', emoji: 'üéóÔ∏è', fullName: 'Donation üéóÔ∏è'}
      ];
    }
  }
  
  /**
   * Load sample data for initial display
   */
  function loadSampleData() {
    console.log('Loading sample recurring data...');
    
    const paymentMethods = ['Revolut', 'QNB', 'Sparkasse', 'Maybank', 'CIMB'];
    const recurringNames = [
      'Netflix', 'Spotify', 'Domain Hosting', 'Phone Plan', 
      'Insurance', 'Gym Membership', 'Cloud Storage', 'Mortgage'
    ];
    
    // Create sample data with varied start dates and status
    _recurringData = [];
    
    // Generate dates for recurring items
    const today = new Date();
    const oneYearAgo = new Date(today);
    oneYearAgo.setFullYear(today.getFullYear() - 1);
    
    // For sample data only - generate plausible next payment dates
    // In production these would come from the spreadsheet
    function getSampleNextPayment(frequency) {
      const nextPayment = new Date();
      
      // Add a random offset between 1-28 days in the future
      nextPayment.setDate(nextPayment.getDate() + Math.floor(Math.random() * 28) + 1);
      
      return nextPayment;
    }
    
    for (let i = 0; i < 12; i++) {
      // Create variations in dates
      const startDate = new Date(
        oneYearAgo.getTime() + Math.random() * (today.getTime() - oneYearAgo.getTime())
      );
      
      // Some items have end dates
      let endDate = null;
      let status = STATUS_TYPES.ACTIVE.value;
      
      // Randomly assign some items as expired or ending soon
      const randomStatus = Math.random();
      if (randomStatus > 0.8) {
        // Ended - has an end date in the past
        endDate = new Date(startDate);
        endDate.setMonth(endDate.getMonth() + Math.floor(Math.random() * 10));
        if (endDate < today) {
          status = STATUS_TYPES.ENDED.value;
        }
      } else if (randomStatus > 0.6) {
        // Expires soon
        endDate = new Date(today);
        endDate.setMonth(today.getMonth() + Math.floor(Math.random() * 3) + 1);
        status = STATUS_TYPES.EXPIRES.value;
      }
      
      // Use weighted frequency distribution to match real-world usage
      // More monthly than others (60% Monthly, 25% Yearly, 15% Quarterly)
      const frequencyRandom = Math.random();
      const frequency = frequencyRandom < 0.6 ? 'Monthly' : 
                        (frequencyRandom < 0.85 ? 'Yearly' : 'Quarterly');
      
      // Generate a sample next payment date (in production this comes from spreadsheet)
      const nextPayment = status !== STATUS_TYPES.ENDED.value ? 
                          getSampleNextPayment(frequency) : null;
      
      // Get random category
      const categoryIndex = Math.floor(Math.random() * _categories.length);
      const category = _categories[categoryIndex].fullName || _categories[categoryIndex].name;
      
      // Generate amount between 5 and 100
      const amount = Math.floor(Math.random() * 95) + 5;
      
      _recurringData.push({
        id: `recurring-${i}-${Date.now()}`,
        startDate: startDate,
        endDate: endDate,
        name: recurringNames[i % recurringNames.length],
        category: category,
        frequency: frequency,
        amount: amount,
        payMethod: paymentMethods[Math.floor(Math.random() * paymentMethods.length)],
        notes: `Sample recurring item ${i+1}`,
        status: status,
        nextPayment: nextPayment
      });
    }
    
    // Sort by status (Active first) then by next payment date
    _recurringData.sort((a, b) => {
      // First by status priority (Active > Expires > Ended)
      const statusOrder = {
        [STATUS_TYPES.ACTIVE.value]: 0,
        [STATUS_TYPES.EXPIRES.value]: 1,
        [STATUS_TYPES.ENDED.value]: 2
      };
      
      if (statusOrder[a.status] !== statusOrder[b.status]) {
        return statusOrder[a.status] - statusOrder[b.status];
      }
      
      // Then by next payment date (if both have next payment)
      if (a.nextPayment && b.nextPayment) {
        return a.nextPayment - b.nextPayment;
      } else if (a.nextPayment) {
        return -1;
      } else if (b.nextPayment) {
        return 1;
      }
      
      // If no next payment, sort by name
      return a.name.localeCompare(b.name);
    });
    
    console.log('Sample data loaded:', _recurringData.length, 'items');
  }
  
  // No calculateNextPayment function needed
  // All next payment calculations are done by the spreadsheet
  
  /**
   * Bind event handlers
   */
  function bindEvents() {
    console.log('Binding recurring events...');
    
    try {
      // Status filter buttons
      const filterButtons = document.querySelectorAll('.rec-filter-btn');
      filterButtons.forEach(button => {
        button.addEventListener('click', function() {
          const status = this.getAttribute('data-status');
          setStatusFilter(status);
          
          // Update active state on buttons
          filterButtons.forEach(btn => btn.classList.remove('active'));
          this.classList.add('active');
        });
      });
      
      // Table row actions - using event delegation
      const recurringTable = getElement('recurringTable');
      if (recurringTable) {
        recurringTable.addEventListener('click', handleTableClicks);
      }
      
      // Category filter change
      const categoryFilter = getElement('categoryFilter');
      if (categoryFilter) {
        categoryFilter.addEventListener('change', function() {
          filterSubscriptions();
        });
      }
      
      // Add New Subscription button
      const addNewBtn = getElement('addNewSubscription');
      if (addNewBtn) {
        addNewBtn.addEventListener('click', function() {
          addNewRecurringEntry();
        });
      }
      
      console.log('Recurring events bound successfully');
    } catch (err) {
      console.error('Error binding recurring events:', err);
    }
  }
  
  /**
   * Handle table row clicks with event delegation
   */
  function handleTableClicks(e) {
    const target = e.target;
    
    // Find the closest button to handle clicks on icon inside button
    const button = target.closest('button');
    if (!button) return;
    
    // Get the row
    const row = button.closest('tr');
    if (!row) return;
    
    const itemId = row.getAttribute('data-id');
    
    // Determine which button was clicked
    if (button.classList.contains('rec-edit-btn')) {
      console.log('Edit button clicked for item:', itemId);
      startEditing(itemId);
    } else if (button.classList.contains('rec-save-btn')) {
      console.log('Save button clicked for item:', itemId);
      saveEdits(itemId);
    } else if (button.classList.contains('rec-cancel-btn')) {
      console.log('Cancel button clicked');
      cancelEditing();
    }
  }
  
  /**
   * Set the status filter and update the view
   */
  function setStatusFilter(status) {
    _activeFilter = status || 'all';
    console.log('Filter set to:', _activeFilter);
    filterSubscriptions();
  }
  
  /**
   * Find category details by name (full name or clean name)
   * This helps us get the emoji for a given category string
   */
  function findCategoryByName(categoryName) {
    // Try exact match on fullName first
    let category = _categories.find(c => c.fullName === categoryName);
    
    // If not found, try match on name
    if (!category) {
      category = _categories.find(c => c.name === categoryName);
    }
    
    // If still not found, parse the category name to extract emoji
    if (!category) {
      const parsed = parseCategoryNameAndEmoji(categoryName);
      category = {
        name: parsed.name,
        emoji: parsed.emoji,
        fullName: categoryName
      };
    }
    
    return category;
  }
  
  /**
   * Filter subscriptions based on current filters
   */
  function filterSubscriptions() {
    // Get current category filter
    const categoryFilter = getElement('categoryFilter');
    const selectedCategory = categoryFilter ? categoryFilter.value : 'all';
    
    // Get all rows
    const rows = document.querySelectorAll('#recurringTable tbody tr');
    
    // Track how many we're showing
    let visibleCount = 0;
    
    // Log filter states to debug
    console.log('Filtering with status:', _activeFilter, 'and category:', selectedCategory);
    
    rows.forEach(row => {
      // Skip rows that are being edited or added new
      if (row.classList.contains('rec-editing') || row.classList.contains('rec-adding-new')) {
        visibleCount++;
        return;
      }
      
      // Get row data attributes
      const status = row.getAttribute('data-status');
      const category = row.getAttribute('data-category');
      
      // Debug log for each row
      console.log('Row status:', status, 'vs filter:', _activeFilter);
      
      // Determine if row should be visible based on filters
      let visible = true;
      
      // Status filter - case insensitive comparison for reliability
      if (_activeFilter !== 'all' && status.toLowerCase() !== _activeFilter.toLowerCase()) {
        visible = false;
      }
      
      // Category filter
      if (selectedCategory !== 'all' && category !== selectedCategory) {
        visible = false;
      }
      
      // Show/hide the row
      row.style.display = visible ? '' : 'none';
      
      if (visible) visibleCount++;
    });
    
    // Update the visible count
    const countElement = getElement('visibleSubscriptionsCount');
    if (countElement) {
      countElement.textContent = visibleCount;
    }
    
    console.log('Showing', visibleCount, 'subscriptions after filtering');
  }
  
  /**
   * Start editing a recurring entry
   */
  function startEditing(itemId) {
    // If already editing, save current edit first
    if (_editingRow) {
      if (_editingRow !== itemId) {
        saveEdits(_editingRow);
      } else {
        return; // Already editing this row
      }
    }
    
    // Set current editing row
    _editingRow = itemId;
    
    // Find the row
    const row = document.querySelector(`tr[data-id="${itemId}"]`);
    if (!row) return;
    
    // Get item data
    const item = _recurringData.find(i => i.id === itemId);
    if (!item) return;
    
    // Add editing class to row
    row.classList.add('rec-editing');
    
    // Replace row with editable version
    const cells = row.querySelectorAll('td');
    
    // Start Date (not editable to maintain subscription history)
    const startDateFormatted = formatDate(item.startDate);
    cells[0].innerHTML = `<span class="rec-noneditable">${startDateFormatted}</span>`;
    
    // Name
    cells[1].innerHTML = `<input type="text" class="rec-edit-input" value="${item.name}" data-field="name">`;
    
    // Category (dropdown)
    let categoryOptions = '<select class="rec-edit-input" data-field="category">';
    _categories.forEach(cat => {
      const catFullName = cat.fullName || `${cat.name} ${cat.emoji}`;
      const selected = catFullName === item.category ? 'selected' : '';
      categoryOptions += `<option value="${catFullName}" ${selected}>${cat.emoji} ${cat.name}</option>`;
    });
    categoryOptions += '</select>';
    cells[2].innerHTML = categoryOptions;
    
    // Frequency (dropdown)
    let frequencyOptions = '<select class="rec-edit-input" data-field="frequency">';
    FREQUENCY_OPTIONS.forEach(freq => {
      const selected = freq === item.frequency ? 'selected' : '';
      frequencyOptions += `<option value="${freq}" ${selected}>${freq}</option>`;
    });
    frequencyOptions += '</select>';
    cells[3].innerHTML = frequencyOptions;
    
    // Amount
    const currencySymbol = getCurrencySymbol();
    cells[4].innerHTML = `
      <div class="rec-amount-wrapper">
        <span class="rec-currency">${currencySymbol}</span>
        <input type="number" class="rec-edit-input rec-amount" value="${item.amount}" data-field="amount" step="0.01" min="0">
      </div>
    `;
    
    // Payment Method
    cells[5].innerHTML = `<input type="text" class="rec-edit-input" value="${item.payMethod}" data-field="payMethod">`;
    
    // End Date
    const endDateFormatted = item.endDate ? formatDate(item.endDate) : '';
    cells[6].innerHTML = `<input type="date" class="rec-edit-input" value="${formatDateForInput(item.endDate)}" data-field="endDate">`;
    
    // Next Payment (calculated)
    const nextPaymentFormatted = item.nextPayment ? formatDate(item.nextPayment) : 'N/A';
    cells[7].innerHTML = `<span class="rec-noneditable">${nextPaymentFormatted}</span>`;
    
    // Notes
    cells[8].innerHTML = `<input type="text" class="rec-edit-input" value="${item.notes || ''}" data-field="notes">`;
    
    // Actions
    cells[9].innerHTML = `
      <button class="rec-action-btn rec-save-btn" title="Save changes">
        <i class="material-icons">save</i>
      </button>
      <button class="rec-action-btn rec-cancel-btn" title="Cancel">
        <i class="material-icons">close</i>
      </button>
    `;
  }
  
  /**
   * Add a new empty row for entering a new subscription
   */
  function addNewRecurringEntry() {
    if (_editingRow || _isAddingNew) {
      // Already editing or adding - finish that first
      showMessage('Please complete or cancel your current edit first', 'error');
      return;
    }
    
    console.log('Adding new empty row for subscription entry...');
    _isAddingNew = true;
    
    // Create a new empty row with today's date as start date
    const today = new Date();
    const newId = `new-subscription-${Date.now()}`;
    
    const tbody = document.querySelector('#recurringTable tbody');
    if (!tbody) {
      console.error('Table body not found');
      _isAddingNew = false;
      return;
    }
    
    // Create new row
    const newRow = document.createElement('tr');
    newRow.setAttribute('data-id', newId);
    newRow.classList.add('rec-editing', 'rec-adding-new');
    newRow.setAttribute('data-status', STATUS_TYPES.ACTIVE.value);
    
    // Get default category (first one)
    const defaultCategory = _categories.length > 0 ? 
      (_categories[0].fullName || `${_categories[0].name} ${_categories[0].emoji}`) : 
      '';
    
    // Set row content with empty fields to fill in
    const currencySymbol = getCurrencySymbol();
    
    // Create editable cells
    newRow.innerHTML = `
      <td class="rec-startdate-cell">
        <input type="date" class="rec-edit-input" value="${formatDateForInput(today)}" data-field="startDate">
      </td>
      <td class="rec-name-cell">
        <input type="text" class="rec-edit-input" value="" data-field="name" placeholder="Subscription name" required>
      </td>
      <td class="rec-category-cell">
        <select class="rec-edit-input" data-field="category">
          ${_categories.map(cat => {
            const catFullName = cat.fullName || `${cat.name} ${cat.emoji}`;
            return `<option value="${catFullName}">${cat.emoji} ${cat.name}</option>`;
          }).join('')}
        </select>
      </td>
      <td class="rec-frequency-cell">
        <select class="rec-edit-input" data-field="frequency">
          ${FREQUENCY_OPTIONS.map(freq => 
            `<option value="${freq}">${freq}</option>`
          ).join('')}
        </select>
      </td>
      <td class="rec-amount-cell">
        <div class="rec-amount-wrapper">
          <span class="rec-currency">${currencySymbol}</span>
          <input type="number" class="rec-edit-input rec-amount" value="" data-field="amount" step="0.01" min="0" placeholder="0.00" required>
        </div>
      </td>
      <td class="rec-payment-cell">
        <input type="text" class="rec-edit-input" value="" data-field="payMethod" placeholder="e.g. Revolut">
      </td>
      <td class="rec-enddate-cell">
        <input type="date" class="rec-edit-input" value="" data-field="endDate">
      </td>
      <td class="rec-nextpayment-cell">
        <span class="rec-noneditable">Auto-calculated</span>
      </td>
      <td class="rec-notes-cell">
        <input type="text" class="rec-edit-input" value="" data-field="notes" placeholder="Optional notes">
      </td>
      <td class="rec-actions-cell">
        <button class="rec-action-btn rec-save-btn" title="Save">
          <i class="material-icons">save</i>
        </button>
        <button class="rec-action-btn rec-cancel-btn" title="Cancel">
          <i class="material-icons">close</i>
        </button>
      </td>
    `;
    
    // Insert at the beginning of the table
    if (tbody.firstChild) {
      tbody.insertBefore(newRow, tbody.firstChild);
    } else {
      tbody.appendChild(newRow);
    }
    
    // Set focus on the name field
    setTimeout(() => {
      const nameInput = newRow.querySelector('input[data-field="name"]');
      if (nameInput) nameInput.focus();
    }, 100);
    
    // Set editing row to the new ID
    _editingRow = newId;
    
    console.log('New empty row added with ID:', newId);
  }
  
  /**
   * Save edits to a recurring entry
   */
  function saveEdits(itemId) {
    if (!itemId) return;
    
    // Find the row
    const row = document.querySelector(`tr[data-id="${itemId}"]`);
    if (!row) return;
    
    // Check if this is a new entry
    const isNewEntry = row.classList.contains('rec-adding-new');
    
    // Get inputs
    const inputs = row.querySelectorAll('.rec-edit-input');
    
    // Collect values
    const updatedValues = {};
    let hasErrors = false;
    
    inputs.forEach(input => {
      const field = input.getAttribute('data-field');
      
      // Required field validation for new entries
      if (isNewEntry && input.required && (input.value.trim() === '')) {
        input.classList.add('rec-input-error');
        hasErrors = true;
        return;
      } else {
        input.classList.remove('rec-input-error');
      }
      
      if (field === 'startDate' || field === 'endDate') {
        updatedValues[field] = input.value ? new Date(input.value) : null;
      } else if (field === 'amount') {
        updatedValues[field] = parseFloat(input.value) || 0;
        
        // Validate amount
        if (isNewEntry && (isNaN(updatedValues[field]) || updatedValues[field] <= 0)) {
          input.classList.add('rec-input-error');
          hasErrors = true;
        }
      } else if (field) {
        updatedValues[field] = input.value;
      }
    });
    
    // Handle validation errors
    if (hasErrors) {
      showMessage('Please fill in all required fields correctly', 'error');
      return;
    }
    
    try {
      if (isNewEntry) {
        // Create a new subscription entry
        const newEntry = {
          id: itemId,
          startDate: updatedValues.startDate || new Date(),
          endDate: updatedValues.endDate,
          name: updatedValues.name,
          category: updatedValues.category,
          frequency: updatedValues.frequency || 'Monthly',
          amount: updatedValues.amount,
          payMethod: updatedValues.payMethod,
          notes: updatedValues.notes || '',
          status: STATUS_TYPES.ACTIVE.value, // Start as active
          nextPayment: calculateNextPayment(updatedValues.startDate, updatedValues.frequency)
        };
        
        // Add to data array
        _recurringData.unshift(newEntry);
        
        // Reset adding flag
        _isAddingNew = false;
        
        // Show success message
        showMessage('New subscription added successfully', 'success');
      } else {
        // Update existing item
        const itemIndex = _recurringData.findIndex(i => i.id === itemId);
        if (itemIndex === -1) return;
        
        // Create updated item
        const updatedItem = {..._recurringData[itemIndex], ...updatedValues};
        
        // Update status and next payment based on dates
        // Note: In production, these would be calculated by the spreadsheet
        updatedItem.nextPayment = calculateNextPayment(updatedItem.startDate, updatedItem.frequency, updatedItem.endDate);
        updatedItem.status = calculateStatus(updatedItem.endDate);
        
        // Update the data
        _recurringData[itemIndex] = updatedItem;
        
        // Show success message
        showMessage('Subscription updated successfully', 'success');
      }
      
      // Render the row with updated data
      renderRecurringTable();
      
      // Clear editing state
      row.classList.remove('rec-editing', 'rec-adding-new');
      _editingRow = null;
      
      // Update summary
      updateSummary();
      
      // Apply filters
      filterSubscriptions();
    } catch (err) {
      console.error('Error saving subscription:', err);
      showMessage('Error saving: ' + err.message, 'error');
    }
  }
  
  /**
   * Calculate next payment date (for sample data only)
   * In production, this would be calculated by the spreadsheet
   */
  function calculateNextPayment(startDate, frequency, endDate) {
    const today = new Date();
    
    // If ended (end date in past), no next payment
    if (endDate && endDate < today) {
      return null;
    }
    
    // Simple calculation for sample data
    const nextPayment = new Date();
    
    // Add days based on frequency for sample data only
    if (frequency === 'Monthly') {
      nextPayment.setDate(nextPayment.getDate() + 30);
    } else if (frequency === 'Quarterly') {
      nextPayment.setDate(nextPayment.getDate() + 90);
    } else if (frequency === 'Yearly') {
      nextPayment.setDate(nextPayment.getDate() + 365);
    }
    
    return nextPayment;
  }
  
  /**
   * Calculate status based on end date (for sample data only)
   * In production, this would be calculated by the spreadsheet
   */
  function calculateStatus(endDate) {
    if (!endDate) {
      return STATUS_TYPES.ACTIVE.value;
    }
    
    const today = new Date();
    
    if (endDate < today) {
      return STATUS_TYPES.ENDED.value;
    }
    
    // If end date is within 3 months, it "expires soon"
    const threeMonthsFromNow = new Date(today);
    threeMonthsFromNow.setMonth(today.getMonth() + 3);
    
    if (endDate < threeMonthsFromNow) {
      return STATUS_TYPES.EXPIRES.value;
    }
    
    return STATUS_TYPES.ACTIVE.value;
  }
  
  /**
   * Cancel editing and revert changes
   */
  function cancelEditing() {
    if (!_editingRow) return;
    
    // Find the row
    const row = document.querySelector(`tr[data-id="${_editingRow}"]`);
    if (!row) return;
    
    // Check if this is a new entry being added
    const isNewEntry = row.classList.contains('rec-adding-new');
    
    if (isNewEntry) {
      // Remove the row completely if it was a new entry
      row.remove();
      _isAddingNew = false;
    } else {
      // Otherwise revert to non-editing state
      const item = _recurringData.find(i => i.id === _editingRow);
      if (item) {
        renderRow(row, item);
      }
    }
    
    // Clear editing state
    _editingRow = null;
  }
  
  /**
   * Show a status message
   */
  function showMessage(message, type = 'info') {
    console.log(`${type} message: ${message}`);
    
    const messageContainer = getElement('recurringMessage');
    if (!messageContainer) return;
    
    // Set message content and type
    messageContainer.textContent = message;
    messageContainer.className = `rec-message rec-${type}-message`;
    
    // Show the message
    messageContainer.style.display = 'block';
    
    // Hide after delay
    setTimeout(() => {
      messageContainer.style.display = 'none';
    }, 3000);
  }
  
  /**
   * Calculate recurring transactions summary statistics
   * NOTE: This is only for sample data when real data is not available
   * In production, these values should come directly from the spreadsheet
   */
  function calculateRecurringSummary() {
    try {
      // In real implementation, this should come from the API
      // This is just for sample data display
      return {
        activeCount: _recurringData.filter(item => 
          item.status === STATUS_TYPES.ACTIVE.value || 
          item.status === STATUS_TYPES.EXPIRES.value
        ).length,
        monthlyCost: 250.75,  // Sample value
        annualCost: 3009.00,  // Sample value 
        paidThisYear: 1254.50, // Sample value
        leftToPay: 1754.50    // Sample value
      };
    } catch (err) {
      console.error('Error calculating summary (sample data only):', err);
      return {
        activeCount: 0,
        monthlyCost: 0,
        annualCost: 0,
        paidThisYear: 0,
        leftToPay: 0
      };
    }
  }
  
  /**
   * Update the summary display
   */
  function updateSummary() {
    try {
      const summary = calculateRecurringSummary();
      
      // Update count
      const countElement = getElement('totalSubscriptionsCount');
      if (countElement) {
        countElement.textContent = summary.activeCount;
      }
      
      // Update visible count
      const visibleCountElement = getElement('visibleSubscriptionsCount');
      if (visibleCountElement) {
        visibleCountElement.textContent = summary.activeCount; // Initially all active are visible
      }
      
      // Update paid this year
      const paidElement = getElement('paidThisYear');
      if (paidElement) {
        paidElement.textContent = formatCurrency(summary.paidThisYear);
      }
      
      // Update left to pay
      const leftElement = getElement('leftToPay');
      if (leftElement) {
        leftElement.textContent = formatCurrency(summary.leftToPay);
      }
      
      // Update monthly total
      const monthlyElement = getElement('monthlyCost');
      if (monthlyElement) {
        monthlyElement.textContent = formatCurrency(summary.monthlyCost);
      }
    } catch (err) {
      console.error('Error updating summary:', err);
    }
  }
  
  /**
   * Helper: Get currency symbol
   */
  function getCurrencySymbol() {
    if (typeof SimBudget !== 'undefined' && 
        SimBudget.Settings && 
        typeof SimBudget.Settings.getCurrencySymbol === 'function') {
      return SimBudget.Settings.getCurrencySymbol();
    }
    return '‚Ç¨'; // Default
  }
  
  /**
   * Helper: Format currency
   */
  function formatCurrency(amount) {
    if (typeof Utils !== 'undefined' && 
        typeof Utils.formatCurrency === 'function') {
      return Utils.formatCurrency(amount);
    }
    return getCurrencySymbol() + amount.toFixed(2);
  }
  
  /**
   * Helper: Format date for display
   */
  function formatDate(date) {
    if (!date) return '';
    
    if (typeof Utils !== 'undefined' && 
        typeof Utils.formatDate === 'function') {
      return Utils.formatDate(date);
    }
    
    // Default date formatting
    return date.toLocaleDateString();
  }
  
  /**
   * Helper: Format date for input element (YYYY-MM-DD)
   */
  function formatDateForInput(date) {
    if (!date) return '';
    
    const d = new Date(date);
    if (isNaN(d.getTime())) return '';
    
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    
    return `${year}-${month}-${day}`;
  }
  
  /**
   * Render a single row in the table
   */
  function renderRow(row, item) {
    if (!row || !item) return;
    
    // Format dates
    const startDateFormatted = formatDate(item.startDate);
    const endDateFormatted = item.endDate ? formatDate(item.endDate) : '';
    const nextPaymentFormatted = item.nextPayment ? formatDate(item.nextPayment) : 'N/A';
    
    // Find the category object matching this item's category
    const categoryInfo = findCategoryByName(item.category);
    
    // Get emoji and clean name
    const emoji = categoryInfo ? categoryInfo.emoji : '';
    const categoryName = categoryInfo ? categoryInfo.name : item.category;
    
    // Get background color based on status
    let statusColor = STATUS_TYPES.ACTIVE.color;
    if (item.status === STATUS_TYPES.EXPIRES.value) {
      statusColor = STATUS_TYPES.EXPIRES.color;
    } else if (item.status === STATUS_TYPES.ENDED.value) {
      statusColor = STATUS_TYPES.ENDED.color;
    }
    
    // Set status color
    row.style.backgroundColor = statusColor;
    
    // Set data attributes for filtering
    row.setAttribute('data-status', item.status);
    row.setAttribute('data-category', item.category);
    
    // Format frequency for both mobile and desktop
    // Mobile will show just the first letter using CSS
    const frequencyLetter = item.frequency.charAt(0);
    
    // Create row HTML - SHOWING ONLY EMOJI IN TABLE CELL
    row.innerHTML = `
      <td class="rec-startdate-cell">${startDateFormatted}</td>
      <td class="rec-name-cell">${item.name}</td>
      <td class="rec-category-cell" title="${categoryName}">
        <span class="category-emoji-only">${emoji}</span>
      </td>
      <td class="rec-frequency-cell" data-frequency="${item.frequency}" title="${item.frequency}">
        <span class="frequency-full">${item.frequency}</span>
        <span class="frequency-letter">${frequencyLetter}</span>
      </td>
      <td class="rec-amount-cell">${formatCurrency(item.amount)}</td>
      <td class="rec-payment-cell">${item.payMethod}</td>
      <td class="rec-enddate-cell">${endDateFormatted}</td>
      <td class="rec-nextpayment-cell">${nextPaymentFormatted}</td>
      <td class="rec-notes-cell">${item.notes || ''}</td>
      <td class="rec-actions-cell">
        <button class="rec-action-btn rec-edit-btn" title="Edit">
          <i class="material-icons">edit</i>
        </button>
      </td>
    `;
  }
  
  /**
   * Render the recurring table
   */
  function renderRecurringTable() {
    console.log('Rendering recurring table...');
    
    try {
      const recurringTable = getElement('recurringTable');
      if (!recurringTable) {
        console.error('Recurring table element not found');
        return;
      }
      
      const tbody = recurringTable.querySelector('tbody');
      if (!tbody) {
        console.error('Table body not found');
        return;
      }
      
      // Clear existing rows
      tbody.innerHTML = '';
      
      // Add rows for each entry
      _recurringData.forEach(item => {
        const row = document.createElement('tr');
        row.setAttribute('data-id', item.id);
        
        // Render the row
        renderRow(row, item);
        
        tbody.appendChild(row);
      });
      
      console.log('Recurring table rendered with', _recurringData.length, 'rows');
    } catch (err) {
      console.error('Error rendering recurring table:', err);
    }
  }
  
  /**
   * Render the Category Filter dropdown
   */
  function renderCategoryFilter() {
    try {
      const categoryFilter = getElement('categoryFilter');
      if (!categoryFilter) return;
      
      // Clear existing options
      categoryFilter.innerHTML = '<option value="all">All Categories</option>';
      
      // Get unique categories from data
      const uniqueCategories = [...new Set(_recurringData.map(item => item.category))];
      
      // Add options for each category - SHOWING EMOJI FIRST, THEN NAME
      uniqueCategories.forEach(categoryString => {
        // Find category details to get emoji
        const categoryInfo = findCategoryByName(categoryString);
        const emoji = categoryInfo ? categoryInfo.emoji : '';
        const name = categoryInfo ? categoryInfo.name : categoryString;
        
        categoryFilter.innerHTML += `
          <option value="${categoryString}">${emoji} ${name}</option>
        `;
      });
      
      console.log('Category filter rendered with', uniqueCategories.length, 'options');
    } catch (err) {
      console.error('Error rendering category filter:', err);
    }
  }
  
  /**
   * Render the recurring view with all components
   */
  function renderRecurringView() {
    console.log("Starting to render recurring view...");
    
    const container = getElement('recurringContent');
    if (!container) {
      console.error("Recurring container not found in renderRecurringView");
      return;
    }
    
    try {
      // Get summary data
      const summary = calculateRecurringSummary();
      
      // Start with fresh HTML
      container.innerHTML = `
        <!-- Status message container -->
        <div id="recurringMessage" class="rec-message" style="display: none;"></div>
        
        <!-- Summary Cards -->
        <div class="rec-summary-row">
          <div class="rec-summary-box">
            <div class="rec-box-content">
              <div class="rec-box-item">
                <div class="rec-box-label">Active Subscriptions</div>
                <div class="rec-box-value">
                  <span id="visibleSubscriptionsCount">${summary.activeCount}</span>
                  <span class="rec-box-subtitle">/ <span id="totalSubscriptionsCount">${summary.activeCount}</span> total</span>
                </div>
              </div>
              <div class="rec-box-item">
                <div class="rec-box-label">Paid This Year</div>
                <div class="rec-box-value" id="paidThisYear">${formatCurrency(summary.paidThisYear)}</div>
              </div>
              <div class="rec-box-item">
                <div class="rec-box-label">Left To Pay</div>
                <div class="rec-box-value" id="leftToPay">${formatCurrency(summary.leftToPay)}</div>
              </div>
              <div class="rec-box-item">
                <div class="rec-box-label">Monthly Cost</div>
                <div class="rec-box-value" id="monthlyCost">${formatCurrency(summary.monthlyCost)}</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Recurring Table Section -->
        <div class="rec-table-container">
          <div class="rec-table-header">
            <div class="rec-title-bar">
              <h3 class="rec-section-title">My Subscriptions</h3>
            </div>
            <div class="rec-filters">
              <div class="rec-status-filters">
                <button class="rec-filter-btn active" data-status="Active">Active</button>
                <button class="rec-filter-btn" data-status="Expires">Expiring</button>
                <button class="rec-filter-btn" data-status="Ended">Ended</button>
                <button class="rec-filter-btn" data-status="all">All</button>
                <button id="addNewSubscription" class="rec-add-subscription-btn">
                  <i class="material-icons">add</i> Add Subscription
                </button>
              </div>
              <div class="rec-category-filter">
                <select id="categoryFilter" class="rec-filter-select">
                  <option value="all">All Categories</option>
                  <!-- Categories will be added dynamically -->
                </select>
              </div>
            </div>
          </div>
          <div class="rec-table-wrapper">
            <table id="recurringTable" class="rec-table">
              <thead>
                <tr>
                  <th>Start Date</th>
                  <th>Name</th>
                  <th title="Category">Cat</th>
                  <th>Frequency</th>
                  <th>Amount</th>
                  <th>Payment</th>
                  <th>End Date</th>
                  <th>Next Payment</th>
                  <th class="rec-notes-header">Notes</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                <!-- Recurring entries will be populated here -->
              </tbody>
            </table>
          </div>
        </div>
      `;
      
      // Render the recurring table
      renderRecurringTable();
      
      // Render category filter
      renderCategoryFilter();
      
      // Apply initial filters
      setStatusFilter('active');
      
      console.log("Recurring view rendering completed successfully");
    } catch (err) {
      console.error("Error rendering recurring view:", err);
      
      // Show fallback error message
      container.innerHTML = `
        <div class="rec-error">
          <h3>Error Rendering Recurring Module</h3>
          <p>An error occurred while rendering the recurring subscriptions view. Please try refreshing the page.</p>
          <p class="rec-error-details">${err.message}</p>
        </div>
      `;
    }
  }
  
  /**
   * Set recurring data from external source
   */
  function setRecurringData(recurringData) {
    console.log('Setting recurring data from API...');
    
    if (!recurringData || !Array.isArray(recurringData)) {
      console.warn('Invalid recurring data received:', recurringData);
      return;
    }
    
    try {
      console.log('API returned recurring data:', recurringData.length, 'entries');
      
      // Convert API recurring data to our format
      _recurringData = recurringData.map(item => {
        // Ensure dates are Date objects
        const startDate = item.startDate instanceof Date ? item.startDate : new Date(item.startDate);
        const endDate = item.endDate ? (item.endDate instanceof Date ? item.endDate : new Date(item.endDate)) : null;
        
        return {
          id: item.id || `recurring-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          startDate: startDate,
          endDate: endDate,
          name: item.name || '',
          category: item.category || 'Other',
          frequency: item.frequency || 'Monthly',
          amount: parseFloat(item.amount),
          payMethod: item.payMethod || 'Other',
          notes: item.notes || '',
          status: item.status || STATUS_TYPES.ACTIVE.value,
          nextPayment: item.nextPayment ? new Date(item.nextPayment) : null
        };
      });
      
      // Sort by status (Active first) then by next payment date
      _recurringData.sort((a, b) => {
        // First by status priority (Active > Expires > Ended)
        const statusOrder = {
          [STATUS_TYPES.ACTIVE.value]: 0,
          [STATUS_TYPES.EXPIRES.value]: 1,
          [STATUS_TYPES.ENDED.value]: 2
        };
        
        if (statusOrder[a.status] !== statusOrder[b.status]) {
          return statusOrder[a.status] - statusOrder[b.status];
        }
        
        // Then by next payment date (if both have next payment)
        if (a.nextPayment && b.nextPayment) {
          return a.nextPayment - b.nextPayment;
        } else if (a.nextPayment) {
          return -1;
        } else if (b.nextPayment) {
          return 1;
        }
        
        // If no next payment, sort by name
        return a.name.localeCompare(b.name);
      });
      
      // Render with the new data
      renderRecurringView();
      
      console.log('Recurring data successfully updated from API');
    } catch (err) {
      console.error('Error processing API recurring data:', err);
    }
  }
  
  // Public API
  return {
    init: init,
    renderRecurringView: renderRecurringView,
    setRecurringData: setRecurringData
  };
})();

// Expose globally without auto-initialization
window.RecurringManager = RecurringManager;

/**
 * Load recurring data with simplified reliable rendering
 */
SimBudget.loadRecurringData = function() {
  console.log("Loading recurring view...");
  
  const contentArea = document.getElementById("recurringContent");
  if (!contentArea) {
    console.error("Recurring content area not found");
    _loadingView = null;
    return;
  }

  // Show simple loading state
  contentArea.innerHTML = `
    <div class="rec-loading">
      <div class="loading-spinner"></div>
      <p class="rec-loading-text">Loading subscription data...</p>
    </div>
  `;
  
  // Initialize RecurringManager directly with a slight delay
  setTimeout(() => {
    try {
      if (window.RecurringManager && typeof RecurringManager.init === 'function') {
        console.log("Initializing RecurringManager");
        // Explicitly pass the container ID to ensure proper rendering
        RecurringManager.init('recurringContent');
        
        // Only try API calls if API exists
        if (window.API && typeof API.getRecurringData === 'function') {
          console.log("Fetching real recurring data in background...");
          
          try {
            API.getRecurringData(
              function(result) {
                console.log("Real recurring data loaded successfully");
                
                // Update UI with real data if available
                if (result && result.success && result.recurring) {
                  RecurringManager.setRecurringData(result.recurring);
                }
                
                // Cache the result
                if (window._cache && typeof _cache.set === 'function') {
                  _cache.set("recurring", result.recurring || []);
                }
              },
              function(error) {
                console.log("Using sample data - couldn't load real data:", error);
                // Just log the error - user already sees sample data
              }
            );
          } catch (apiErr) {
            console.warn("API call failed, continuing with sample data:", apiErr);
          }
        } else {
          console.log("API.getRecurringData not available, using sample data only");
        }
      } else {
        contentArea.innerHTML = '<div class="error-message">Error: Recurring Manager component not available</div>';
        console.error("RecurringManager component not found");
      }
    } catch (err) {
      console.error("Error in loadRecurringData:", err);
      contentArea.innerHTML = `
        <div class="error-message">
          <h3>Error Loading Recurring View</h3>
          <p>${err.message}</p>
        </div>
      `;
    } finally {
      // Always clear loading flag
      _loadingView = null;
    }
  }, 300); // Slightly longer timeout to ensure DOM is ready
};
</script>

<style>
/* iOS-specific fix for date inputs - force full width */
input[type="date"].rec-edit-input {
  width: 100% !important;
  min-width: 100% !important;
  max-width: 100% !important;
  -webkit-appearance: none; /* Remove iOS default styling */
  appearance: none;
  display: block !important; /* Force block display */
}

/* Currency symbol regular positioning - more space for placeholder */
.rec-currency {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: #666;
  z-index: 1;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* Move placeholder text far away from currency symbol */
.rec-amount {
  padding-left: 36px !important; /* Much larger padding */
  text-indent: 8px; /* Additional text indent for placeholder */
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* Dark mode support for date inputs */
body.dark-mode input[type="date"].rec-edit-input {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

/* More aggressive fix for amount placeholder position */
.rec-amount-wrapper {
  position: relative;
  width: 100%;
}

.rec-currency {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: #666;
  z-index: 1; /* Lower z-index so it doesn't overlap */
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.rec-amount {
  padding-left: 36px !important; /* Much larger left padding */
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* Special styling for amount placeholder */
input[type="number"].rec-amount::placeholder {
  position: relative;
  z-index: 3;
}

/* ==============================================================
   RECURRING MANAGEMENT - DASHBOARD STYLE MATCHING
   ==============================================================
   All classes use the 'rec-' prefix to avoid conflicts.
   Mobile-first approach with desktop adjustments after.
   Matching dashboard's signature border style and color scheme.
*/

/* ======== NEW: FREQUENCY DISPLAY ON MOBILE ======== */
/* Hide the letter on desktop and full text on mobile */
.frequency-letter {
  display: none;
}

@media (max-width: 768px) {
  .frequency-full {
    display: none;
  }
  
  .frequency-letter {
    display: inline-block;
    font-weight: bold;
  }
  
  /* Make frequency cell narrower on mobile */
  .rec-frequency-cell,
  .rec-table th:nth-child(4) {
    width: 30px !important;
    max-width: 30px !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
    text-align: center !important;
  }
}

/* ======== NEW: EMOJI-ONLY CATEGORY DISPLAY ======== */
.category-emoji-only {
  font-size: 16px !important;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  width: 100%;
}

/* Highlight the emoji when hovered */
.rec-category-cell:hover .category-emoji-only {
  transform: scale(1.1);
  transition: transform 0.2s ease;
}

/* Header styling for Category column */
.rec-table th:nth-child(3) {
  text-align: center !important;
  width: 40px !important;
}

/* Cell styling for Category column */
.rec-category-cell {
  text-align: center !important;
  width: 40px !important;
  cursor: help;
}

/* ======== LOADING & ERROR STATES ======== */
.rec-loading, .rec-error {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  text-align: center;
}

.rec-loading-text {
  margin-top: 16px;
  color: var(--text-secondary, #666);
}

.rec-error {
  background-color: #ffebee;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

.rec-error-details {
  font-family: monospace;
  background: rgba(0,0,0,0.05);
  padding: 8px;
  border-radius: 0px;
  max-width: 100%;
  overflow-x: auto;
  margin-top: 10px;
  font-size: 12px;
  color: #d32f2f;
}

/* ======== MESSAGES ======== */
.rec-message {
  padding: 12px 16px;
  border-radius: 0px;
  margin-bottom: 16px;
  font-weight: 500;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

.rec-success-message {
  background-color: #e8f5e9;
  color: #2e7d32;
}

.rec-error-message {
  background-color: #ffebee;
  color: #d32f2f;
}

.rec-info-message {
  background-color: #e3f2fd;
  color: #1976d2;
}

/* ======== SUMMARY BOX ======== */
.rec-summary-row {
  margin-bottom: 16px;
  display: flex;
  justify-content: center;
}

.rec-summary-box {
  background-color: #fe9aa1; /* Match dashboard coral */
  border-radius: 0px;
  padding: 20px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
  width: 100%;
}

.rec-box-content {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
}

.rec-box-item {
  flex: 1 0 calc(50% - 10px); /* Two columns on small screens */
  padding: 8px;
  text-align: center;
  margin-bottom: 5px;
}

.rec-box-label {
  font-size: 12px;
  color: black;
  margin-bottom: 4px;
  font-family: sans-serif;
}

.rec-box-value {
  font-size: 18px;
  font-weight: 600;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.rec-box-subtitle {
  font-size: 14px;
  color: #2c3e50;
  font-weight: normal;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

/* Hide summary on mobile */
@media (max-width: 768px) {
  .rec-summary-row {
    display: none;
  }
}

/* Adjust Add Subscription button to match filter buttons but stand out */
.rec-add-subscription-btn {
  background-color: #2c3e50;
  color: white;
  border: none;
  border-radius: 0px;
  padding: 8px 12px;
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  cursor: pointer;
  transition: background-color 0.2s;
  margin-left: 8px; /* Add spacing from the All button */
}

.rec-add-subscription-btn:hover {
  background-color: #1e2b37;
}

.rec-add-subscription-btn i {
  font-size: 18px;
}

/* ======== TABLE SECTION ======== */
.rec-table-container {
  background-color: #ffffff;
  border-radius: 0px;
  padding: 20px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

.rec-table-header {
  display: flex;
  flex-direction: column;
  margin-bottom: 16px;
}

.rec-filters {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 8px;
}

.rec-status-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.rec-filter-btn {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
  border-radius: 0px;
  padding: 8px 12px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
}

.rec-filter-btn.active {
  background-color: #2c3e50;
  color: white;
  border-color: #2c3e50;
}

.rec-filter-select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 0px;
  font-size: 14px;
}

.rec-table-wrapper {
  overflow-x: auto;
  margin-bottom: 16px;
}

.rec-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px; /* More compact for mobile */
}

.rec-table th,
.rec-table td {
  padding: 10px 8px;
  text-align: left;
  border-bottom: 1px solid #eee;
}

.rec-table th {
  font-weight: 500;
  color: #607d8b;
  white-space: nowrap;
  position: sticky;
  top: 0;
  background-color: white;
  z-index: 10;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
}

.rec-table tbody tr {
  transition: background-color 0.2s;
}

.rec-table tbody tr:hover {
  filter: brightness(0.95);
}

.rec-table tbody tr.rec-editing {
  box-shadow: 0 0 0 2px #2c3e50;
  position: relative;
  z-index: 5;
}

.rec-amount-cell {
  font-weight: 500;
  white-space: nowrap;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
  color: #2c3e50;
}

.rec-action-btn {
  background: none;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #666;
  width: 36px;
  height: 36px;
  border-radius: 0px;
}

.rec-action-btn:hover {
  background-color: rgba(0,0,0,0.05);
  color: #2c3e50;
}

.rec-actions-cell {
  white-space: nowrap;
}

.rec-save-btn {
  color: #4caf50;
}

.rec-cancel-btn {
  color: #757575; /* Neutral gray color */
}

.rec-edit-input {
  width: 100%;
  padding: 6px 8px;
  border: 1px solid #ddd;
  border-radius: 0px;
  font-size: 14px;
}

.rec-input-error {
  border-color: #f44336 !important;
  background-color: rgba(244, 67, 54, 0.1) !important;
}

.rec-noneditable {
  color: #999;
  font-style: italic;
}

/* Mobile optimizations for table */
@media (max-width: 768px) {
  /* Use smaller text and padding in table */
  .rec-table {
    font-size: 12px;
  }
  
  .rec-table th,
  .rec-table td {
    padding: 6px 4px;
  }
  
  /* Fixed table wrapper CSS - no horizontal scrolling */
  .rec-table-wrapper {
    width: 100%;
    overflow-x: auto;
  }
  
  /* Hide start date, payment method and notes columns on mobile */
  .rec-startdate-cell,
  .rec-table th:nth-child(1),
  .rec-payment-cell,
  .rec-table th:nth-child(6),
  .rec-notes-cell,
  .rec-table th:nth-child(9) {
    display: none;
  }
  
  /* Name column */
  .rec-name-cell,
  .rec-table th:nth-child(2) {
    max-width: 80px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  /* Frequency column */
  .rec-frequency-cell,
  .rec-table th:nth-child(4) {
    width: 60px;
    max-width: 60px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  /* Amount column */
  .rec-amount-cell,
  .rec-table th:nth-child(5) {
    width: 50px;
    white-space: nowrap;
  }
  
  /* End date column */
  .rec-enddate-cell,
  .rec-table th:nth-child(7) {
    width: 70px;
    white-space: nowrap;
  }
  
  /* Next payment column */
  .rec-nextpayment-cell,
  .rec-table th:nth-child(8) {
    width: 70px;
    white-space: nowrap;
  }
  
  /* Actions column */
  .rec-actions-cell,
  .rec-table th:nth-child(10) {
    width: 36px;
    padding-left: 0;
    padding-right: 0;
  }
  
  /* Action button smaller */
  .rec-action-btn {
    width: 28px;
    height: 28px;
  }
  
  .rec-action-btn i {
    font-size: 18px;
  }
  
  /* Make material icons smaller on mobile */
  .rec-table .material-icons {
    font-size: 18px;
  }
  
  /* Filter adjustments for mobile */
  .rec-filter-btn {
    padding: 6px 8px;
    font-size: 11px;
  }
  
  /* Enhanced category column - bigger emoji on mobile */
  .category-emoji-only {
    font-size: 18px !important; /* Slightly larger on mobile */
  }
}

/* Sample table for fallback */
.rec-sample-table {
  width: 100%;
  overflow-x: auto;
  margin-top: 20px;
}

.rec-sample-table table {
  width: 100%;
  border-collapse: collapse;
}

.rec-sample-table th,
.rec-sample-table td {
  padding: 8px;
  text-align: left;
  border-bottom: 1px solid #eee;
}

/* ======== DARK MODE SUPPORT ======== */
/* Summary box becomes dark in dark mode like dashboard */
body.dark-mode .rec-summary-box {
  background-color: var(--dark-surface, #1e1e1e) !important;
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87)) !important;
}

/* White data containers stay dark */
body.dark-mode .rec-table-container,
body.dark-mode .rec-sample-table table {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

/* Labels and secondary text */
body.dark-mode .rec-box-label,
body.dark-mode .rec-table th {
  color: var(--dark-text-secondary, rgba(255, 255, 255, 0.6)) !important;
}

/* Values and important numbers - golden color like dashboard */
body.dark-mode .rec-box-value,
body.dark-mode .rec-box-subtitle,
body.dark-mode .rec-amount-cell {
  color: #DDA15E !important;
}

/* Currency symbols */
body.dark-mode .rec-currency {
  color: rgba(255, 255, 255, 0.6) !important;
}

/* Form elements */
body.dark-mode .rec-filter-select,
body.dark-mode .rec-filter-btn,
body.dark-mode .rec-edit-input {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

/* Table styling */
body.dark-mode .rec-table td,
body.dark-mode .rec-sample-table td {
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .rec-table th {
  background-color: var(--dark-surface, #1e1e1e);
}

/* Interactive elements */
body.dark-mode .rec-action-btn {
  color: var(--dark-text-secondary, rgba(255, 255, 255, 0.6));
}

body.dark-mode .rec-action-btn:hover {
  background-color: rgba(255, 255, 255, 0.1);
  color: #DDA15E;
}

/* Emoji cell - improved visibility in dark mode */
body.dark-mode .category-emoji-only {
  color: #ffffff !important;
  text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
}

/* Status row backgrounds */
body.dark-mode .rec-table tbody tr[data-status="Active"] {
  background-color: rgba(76, 175, 80, 0.15) !important; /* Darker green with transparency */
}

body.dark-mode .rec-table tbody tr[data-status="Expires"] {
  background-color: rgba(255, 152, 0, 0.15) !important; /* Darker yellow with transparency */
}

body.dark-mode .rec-table tbody tr[data-status="Ended"] {
  background-color: rgba(244, 67, 54, 0.15) !important; /* Darker red with transparency */
}

/* Filter button active state */
body.dark-mode .rec-filter-btn.active {
  background-color: #DDA15E;
  border-color: #DDA15E;
  color: #1e1e1e;
}

/* Add New Subscription button - dark mode style */
body.dark-mode .rec-add-subscription-btn {
  background-color: #DDA15E;
  color: #1e1e1e;
}

body.dark-mode .rec-add-subscription-btn:hover {
  background-color: #c9955a;
}

/* ======== DESKTOP STYLES ======== */
@media (min-width: 769px) {
  /* Improved summary layout */
  .rec-box-item {
    flex: 1; /* Equal width columns on desktop */
  }
  
  .rec-box-label {
    font-size: 14px;
  }
  
  .rec-box-value {
    font-size: 22px;
  }
  
  /* Improve filters layout */
  .rec-filters {
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
  }
  
  .rec-status-filters {
    flex: 3;
  }
  
  .rec-category-filter {
    flex: 1;
    max-width: 200px;
  }
  
  /* Show all table columns on desktop */
  .rec-table {
    font-size: 15px;
  }
  
  .rec-notes-header,
  .rec-notes-cell,
  .rec-frequency-cell,
  .rec-enddate-cell,
  .rec-payment-cell {
    display: table-cell;
  }
  
  /* Container width restrictions for larger screens */
  .rec-table-container,
  .rec-summary-box {
    margin-left: auto;
    margin-right: auto;
    max-width: 85%; /* Adjust width to match summary box */
  }
}

/* ======== PRINT STYLES ======== */
@media print {
  .rec-filters,
  .rec-action-btn {
    display: none !important;
  }
  
  .rec-summary-box,
  .rec-table-container {
    border: 1px solid #ccc !important;
    break-inside: avoid !important;
    margin-top: 20px !important;
  }
  
  .rec-table-wrapper {
    overflow: visible !important;
  }
  
  .rec-table th,
  .rec-table td {
    padding: 8px !important;
  }
  
  /* Show all columns when printing */
  .rec-notes-header,
  .rec-notes-cell,
  .rec-frequency-cell,
  .rec-enddate-cell,
  .rec-payment-cell {
    display: table-cell !important;
  }
}
</style>