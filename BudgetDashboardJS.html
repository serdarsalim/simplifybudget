<script>


// Add this SaveQueue implementation at the beginning of BudgetDashboardJS.html
// This creates a queue system to handle sequential save operations

/**
 * SaveQueue - Manages sequential saving of budget values
 * Prevents race conditions when multiple values are changed quickly
 */
const SaveQueue = (function() {
  // Private variables
  let _queue = [];
  let _isProcessing = false;
  
  // Process the next item in the queue
  function processNextItem() {
    if (_queue.length === 0) {
      _isProcessing = false;
      return;
    }
    
    _isProcessing = true;
    const nextItem = _queue.shift();
    
    // Call the API to save the value
    API.updateBudgetValue(
      nextItem.categoryName, 
      nextItem.value,
      (result) => {
        // Success callback
        try {
          // Call the original success callback
          if (nextItem.onSuccess) {
            nextItem.onSuccess(result);
          }
        } finally {
          // Process the next item in the queue, even if callback throws an error
          setTimeout(processNextItem, 50);
        }
      },
      (error) => {
        // Error callback
        try {
          // Call the original error callback
          if (nextItem.onError) {
            nextItem.onError(error);
          }
        } finally {
          // Continue processing the queue even if there was an error
          setTimeout(processNextItem, 50);
        }
      }
    );
  }
  
  // Public methods
  return {
    /**
     * Add a save operation to the queue
     * @param {string} categoryName - Name of the budget category
     * @param {number} value - New budget value
     * @param {Function} onSuccess - Success callback
     * @param {Function} onError - Error callback
     */
    add: function(categoryName, value, onSuccess, onError) {
      // Add to the queue
      _queue.push({
        categoryName: categoryName,
        value: value,
        onSuccess: onSuccess,
        onError: onError,
        timestamp: Date.now()
      });
      
      // Start processing if not already processing
      if (!_isProcessing) {
        processNextItem();
      }
    },
    
    /**
     * Cancel pending operations for a category
     * @param {string} categoryName - Name of the budget category to cancel
     */
    cancelCategory: function(categoryName) {
      _queue = _queue.filter(item => item.categoryName !== categoryName);
    },
    
    /**
     * Check if there are pending saves
     * @return {boolean} True if queue is not empty
     */
    hasPendingSaves: function() {
      return _queue.length > 0;
    }
  };
})();


/**
 * Budget Dashboard JavaScript - Render functions for the 3-column dashboard
 */

// Extend the SimBudget namespace with dashboard-specific functions
(function() {
  // Category colors for the chart and UI
  const categoryColors = {
    'Housing üè†': '#81c784', 
    'Transport üöó': '#7986cb',
    'Groceries üçé': '#f48fb1',
    'Dining out üçï': '#ffb74d',
    'Personal care ‚ù§Ô∏è': '#e57373',
    'Shopping üõçÔ∏è': '#ff8a65',
    'Utilities üí°': '#4dd0e1',
    'Fun üé¨': '#ba68c8',
    'Business üíº': '#81d4fa',
    'Other üí∏': '#8d6e63',
    'Donation üéóÔ∏è': '#ffd54f',
    'Childcare üë∂': '#ffb74d',
    'Savings üí∞': '#dce775'
  };
  
  // Get emoji from category name
  function getEmoji(categoryName) {
    const match = categoryName.match(/\p{Emoji}/u);
    return match ? match[0] : 'üìä';
  }
  
  // Get color from category name
  function getCategoryColor(categoryName) {
    return categoryColors[categoryName] || '#9e9e9e'; // Default gray if not found
  }
  
  // Render the budget dashboard
 SimBudget.renderBudgetDashboard = function(data) {
  if (!data) return;
  
  // Extract all the data we need
  const budget = data.budget;
  const netWorth = data.netWorth;
  const subscriptions = data.subscriptions;
  
  // THIS IS THE KEY LINE - Add it right here
  SimBudget._currentBudgetData = budget;

  // Get the content area
  const contentArea = document.getElementById('budgetContent');
  if (!contentArea) {
    console.error('Budget content container not found');
    return;
  }
  
  // Insert the HTML structure first
  contentArea.innerHTML = `
 
  <div class="dashboard-container">
      <!-- First Column: Financial Summary & Chart -->
      <div class="col-left">
        <!-- Top: Income, Spent, Left to Spend -->
        <div class="dashboard-card budget-summary-card">
          <div class="budget-summary-row">
            <div>
              <div class="value-label">Income</div>
              <div id="income-value" class="value-amount">‚Ç¨0</div>
            </div>
            <div>
              <div class="value-label">Spent</div>
              <div id="spent-value" class="value-amount">‚Ç¨0</div>
            </div>
            <div>
              <div class="value-label">Left to Spend</div>
              <div id="left-to-spend-value" class="value-amount">‚Ç¨0</div>
            </div>
          </div>
        </div>
        
        <!-- Middle: Net Worth Summary -->
        <div class="dashboard-card budget-summary-card">
          <div class="budget-summary-row">
            <div>
              <div class="value-label">Net Worth</div>
              <div id="net-worth-value" class="value-amount">‚Ç¨0</div>
            </div>
            <div>
              <div class="value-label">Savings</div>
              <div id="savings-value" class="value-amount">‚Ç¨0</div>
            </div>
            <div>
              <div class="value-label">Debts</div>
              <div id="debts-value" class="value-amount">‚Ç¨0</div>
            </div>
          </div>
        </div>
        
        <!-- Bottom: Monthly Expense Donut Chart -->
        <div class="dashboard-card donut-chart-card">
          <h3 class="donut-chart-header">Monthly Expense Breakdown</h3>
          <div class="donut-chart-container">
            <canvas id="expense-donut-chart"></canvas>
          </div>
        </div>
      </div>
      
      <!-- Second Column: Budget Categories -->
      <div class="dashboard-card budget-data-card">
        <div id="budget-alert" class="budget-alert">
          <!-- Budget alert message will be populated dynamically -->
        </div>
        
        <div class="budget-table-container">
          <table class="budget-table">
            <thead>
              <tr>
                <th>Category</th>
                <th>Budgeted</th>
                <th>Actual</th>
                <th>Progress</th>
              </tr>
            </thead>
            <tbody id="budget-categories-body">
              <!-- Will be populated dynamically -->
            </tbody>
          </table>
        </div>
      </div>
      
      <!-- Third Column: Subscription Summary & List -->
      <div class="col-right">
        <!-- Top: Subscription Summary Card -->
        <div class="dashboard-card subscription-summary">
          <span class="subscription-icon material-icons">sync</span>
          <div class="subscription-total">0‚Ç¨ for 0 payments</div>
          <div class="subscription-percentage">0% of income</div>
        </div>
        
        <!-- Bottom: Subscription List Card -->
        <div class="dashboard-card subscription-list-card">
          <h3 class="subscription-list-header">Subscriptions</h3>
          <div class="subscription-list-container">
            <table class="subscription-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Name</th>
                  <th class="amount-column">Amount</th>
                  <th>Next Due</th>
                </tr>
              </thead>
              <tbody id="subscription-list-body">
                <!-- Will be populated dynamically -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  `;

   // Populate the year selector and set the current date
  const yearSelector = document.getElementById('yearSelector');
  if (yearSelector) {
    // Clear existing options
    yearSelector.innerHTML = '';
    
    // Populate with 2 years before and after current year
    const currentYear = new Date().getFullYear();
    for (let year = currentYear - 2; year <= currentYear + 2; year++) {
      const option = document.createElement('option');
      option.value = year;
      option.textContent = year;
      yearSelector.appendChild(option);
    }
  }
  
  // Update month and year selectors based on data from spreadsheet
  const monthSelector = document.getElementById('monthSelector');
  
  // IMPORTANT: Update month and year based on data from spreadsheet
  if (monthSelector && budget.month) {
    monthSelector.value = budget.month;
  }
  
  if (yearSelector && budget.year) {
    yearSelector.value = budget.year;
  }
  
  // Make sure to attach event listeners to the selectors again
  if (monthSelector && yearSelector) {
    monthSelector.addEventListener('change', function() {
      SimBudget.updateMonthYear(this.value, yearSelector.value);
    });
    
    yearSelector.addEventListener('change', function() {
      SimBudget.updateMonthYear(monthSelector.value, this.value);
    });
  }
  
  // Set up refresh button event listener
  const refreshButton = document.getElementById('refreshBudget');
  if (refreshButton) {
    refreshButton.addEventListener('click', function() {
      // Invalidate cache and reload data
      if (window._cache && typeof window._cache.invalidate === 'function') {
        window._cache.invalidate('budget');
      }
      SimBudget.loadViewData('budget', true); // true to force refresh
    });
  }

  
  // NOW update the values (after the elements exist)
document.getElementById('income-value').textContent = Utils.formatCurrencyNoDecimals(budget.income);
document.getElementById('spent-value').textContent = Utils.formatCurrencyNoDecimals(budget.spent);
document.getElementById('left-to-spend-value').textContent = Utils.formatCurrencyNoDecimals(budget.leftToSpend);

    
   // For net worth values
document.getElementById('net-worth-value').textContent = Utils.formatCurrencyNoDecimals(netWorth.total);
document.getElementById('savings-value').textContent = Utils.formatCurrencyNoDecimals(netWorth.savings);
document.getElementById('debts-value').textContent = Utils.formatCurrencyNoDecimals(netWorth.debts);
    // 3. Update budget alert message
    const budgetAlert = document.getElementById('budget-alert');
    budgetAlert.textContent = budget.infoMessage || '';
    
    // Clear existing alert classes
    budgetAlert.className = 'budget-alert';
    
    // Add appropriate class based on message content
    if (budget.infoMessage && budget.infoMessage.includes('exceeding income')) {
      budgetAlert.classList.add('warning');
    } else if (budget.infoMessage && budget.infoMessage.includes('perfectly matches')) {
      budgetAlert.classList.add('success');
    } else if (budget.infoMessage && budget.infoMessage.includes('left to allocate')) {
      budgetAlert.classList.add('info');
    }
    
    // 4. Render budget categories
    const categoriesBody = document.getElementById('budget-categories-body');
    categoriesBody.innerHTML = '';
    
   budget.categories.forEach(category => {
  const percentSpent = category.budgeted > 0 ? (category.actual / category.budgeted) * 100 : 0;
  const progressClass = percentSpent > 100 ? 'over-budget' : (percentSpent > 80 ? 'near-limit' : '');
  
  // Create row with optimized structure for extended progress bars
  const row = document.createElement('tr');
  row.innerHTML = `
    <td class="category-name">${category.name}</td>
    <td class="budget-value" data-category="${category.name}" data-value="${category.budgeted}">${Utils.formatCurrency(category.budgeted)}</td>
    <td class="actual-value">${Utils.formatCurrency(category.actual)}</td>
    <td class="progress-cell">
      <div class="progress-bar-container">
        <div class="progress-bar ${progressClass}" style="width: ${Math.min(percentSpent, 100)}%; position: absolute; left: 0; right: 0; top: 0; bottom: 0;"></div>
      </div>
      <div class="progress-percentage">${Math.round(percentSpent)}%</div>
    </td>
  `;
  
  categoriesBody.appendChild(row);
});
    
    // 5. Update subscription summary
    document.querySelector('.subscription-total').textContent = 
  `${Utils.formatCurrencyNoDecimals(subscriptions.total)} for ${subscriptions.count} payments`;
    
    const incomeAmount = budget.income;
    const percentage = incomeAmount > 0 ? Math.round((subscriptions.total / incomeAmount) * 100) : 0;
    document.querySelector('.subscription-percentage').textContent = `${percentage}% of income`;
    
    // 6. Render subscription list
    const subscriptionBody = document.getElementById('subscription-list-body');
    subscriptionBody.innerHTML = '';
    
    subscriptions.items.forEach(subscription => {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${subscription.id}</td>
        <td>${subscription.name}</td>
        <td class="amount-column">${Utils.formatCurrency(subscription.amount)}</td>
        <td>${subscription.nextDate}</td>
      `;
      
      subscriptionBody.appendChild(row);
    });
    
    // 7. Make budget values editable
    SimBudget.makeEditableBudgetValues();
    
    // 8. Render the expense donut chart
    this.renderExpenseChart(budget.categories);
  };
  
  // Render expense chart using Chart.js
SimBudget.renderExpenseChart = function(categories) {
  const ctx = document.getElementById('expense-donut-chart');
  
  // Filter out categories with no actual spending
  const spendingCategories = categories.filter(category => category.actual > 0);
  
  // Prepare chart data
  const chartData = {
    labels: spendingCategories.map(cat => {
      const emoji = getEmoji(cat.name);
      const shortName = cat.name.replace(/\s*\p{Emoji}\s*/u, ''); // Remove emoji
      return emoji + ' ' + shortName;
    }),
    datasets: [{
      data: spendingCategories.map(cat => cat.actual),
      backgroundColor: spendingCategories.map(cat => getCategoryColor(cat.name)),
      borderWidth: 0,
      hoverOffset: 10
    }]
  };
  
  // Create chart
  if (window.expenseChart) {
    window.expenseChart.data = chartData;
    window.expenseChart.update();
  } else {
    window.expenseChart = new Chart(ctx, {
      type: 'doughnut',
      data: chartData,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '70%',
        plugins: {
          legend: {
            position: 'bottom', // Changed from 'right' to 'bottom'
            align: 'center',    // Center-align the legend
            labels: {
              boxWidth: 15,
              padding: 10,
              font: {
                size: 12
              }
            }
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                // Get the category name from the label
                const categoryName = context.label;
                const value = context.raw;
                const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                const percentage = Math.round((value / total) * 100);
                
                // Return both the category name and the value with percentage
                return [`${categoryName}`, `${Utils.formatCurrency(value)} (${percentage}%)`];
              }
            }
          }
        }
      }
    });
  }
};
  
  // Fetch Net Worth data
  SimBudget.fetchNetWorthData = function() {
    // For now using placeholder data
    // TODO: Replace with actual API call to get Net Worth data
    const netWorthData = {
      netWorth: 0,
      savings: 0,
      debts: 0
    };
    
     document.getElementById('net-worth-value').textContent = Utils.formatCurrencyNoDecimals(netWorthData.total);
    document.getElementById('savings-value').textContent = Utils.formatCurrencyNoDecimals(netWorthData.savings);
    document.getElementById('debts-value').textContent = Utils.formatCurrencyNoDecimals(netWorthData.debts);
  };
  
  // Fetch Subscription data
  SimBudget.fetchSubscriptionData = function() {
    // For now using placeholder data
    // TODO: Replace with actual API call to get Subscription data from dontedit!GH5:GJ125
    const subscriptionData = [
      { id: 1, name: 'Copilot Pro', amount: 10, nextDate: '14 May 2025' },
      { id: 2, name: 'CapCut Pro', amount: 6, nextDate: '21 May 2025' },
      { id: 3, name: 'Youtube Premium', amount: 3, nextDate: '23 May 2025' },
      { id: 4, name: 'Netflix', amount: 5, nextDate: '25 May 2025' },
      { id: 5, name: 'Google One Serdar', amount: 2, nextDate: '26 May 2025' },
      { id: 6, name: 'Bmw New Insurance', amount: 100, nextDate: '1 Jun 2025' },
      { id: 7, name: 'ChatGPT', amount: 18, nextDate: '12 Jun 2025' },
      { id: 8, name: 'Claude AI', amount: 100, nextDate: '12 Jun 2025' }
    ];
    
    // Calculate total and percentage
    const totalAmount = subscriptionData.reduce((sum, sub) => sum + sub.amount, 0);
    const incomeAmount = parseFloat(document.getElementById('income-value').textContent.replace(/[^0-9.-]+/g, ''));
    const percentage = incomeAmount > 0 ? Math.round((totalAmount / incomeAmount) * 100) : 0;
    
    // Update subscription summary
    document.querySelector('.subscription-total').textContent =  `${Utils.formatCurrencyNoDecimals(totalAmount)} for ${subscriptionData.length} payments`;
    document.querySelector('.subscription-percentage').textContent = `${percentage}% of income`;
    
    // Render subscription list
    const subscriptionBody = document.getElementById('subscription-list-body');
    subscriptionBody.innerHTML = '';
    
    subscriptionData.forEach(subscription => {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${subscription.id}</td>
        <td>${subscription.name}</td>
        <td class="amount-column">${Utils.formatCurrency(subscription.amount)}</td>
        <td>${subscription.nextDate}</td>
      `;
      
      subscriptionBody.appendChild(row);
    });
  };
  
  // Add this after another SimBudget function like fetchSubscriptionData

/**
 * Updates the progress bar for a budget category immediately
 * @param {string} categoryName - The category to update
 * @param {number} newBudgetValue - The new budget value
 */
SimBudget.updateProgressBar = function(categoryName, newBudgetValue) {
  // Find the row for this category
  const rows = document.querySelectorAll('.budget-table tr');
  rows.forEach(row => {
    const categoryCell = row.querySelector('.category-name');
    if (categoryCell && categoryCell.textContent === categoryName) {
      // Get the actual value
      const actualValue = parseFloat(row.querySelector('.actual-value').textContent.replace(/[^0-9.-]+/g, ''));
      
      // Calculate new percentage
      const newPercentage = newBudgetValue > 0 ? (actualValue / newBudgetValue) * 100 : 0;
      const progressClass = newPercentage > 100 ? 'over-budget' : (newPercentage > 80 ? 'near-limit' : '');
      
      // Update progress bar
      const progressBar = row.querySelector('.progress-bar');
      if (progressBar) {
        progressBar.style.width = Math.min(newPercentage, 100) + '%';
        
        // Update classes for color
        progressBar.classList.remove('over-budget', 'near-limit');
        if (progressClass) {
          progressBar.classList.add(progressClass);
        }
      }
      
      // Update percentage text
      const percentageText = row.querySelector('.progress-percentage');
      if (percentageText) {
        percentageText.textContent = Math.round(newPercentage) + '%';
      }
    }
  });
};
 
// Update SimBudget.makeEditableBudgetValues to use the SaveQueue
SimBudget.makeEditableBudgetValues = function() {
  // This function will contain the same code that currently makes budget values editable
  document.querySelectorAll('.budget-value').forEach(cell => {
    cell.setAttribute('contenteditable', 'true');
    cell.setAttribute('title', 'Click to edit budget amount');
    cell.classList.add('editable');
    
    // Get the category name from data attribute
    const categoryName = cell.dataset.category;
    const originalValue = parseFloat(cell.dataset.value);
    
    // Variables for auto-save debounce
    let saveTimeout = null;
    let isSaving = false;
    let currentEditValue = null;
    
    // Handle key presses
    cell.addEventListener('keydown', function(e) {
      // Prevent Enter from creating a new line - just blur the field instead
      if (e.key === 'Enter') {
        e.preventDefault();
        this.blur(); 
      }
      
      // Cancel on Escape key press
      if (e.key === 'Escape') {
        e.preventDefault();
        // Reset to the original formatted value
        this.textContent = Utils.formatCurrency(originalValue);
        this.blur();
        
        // Cancel any pending save
        if (saveTimeout) {
          clearTimeout(saveTimeout);
          saveTimeout = null;
        }
        
        // Cancel any pending save in the queue
        SaveQueue.cancelCategory(categoryName);
      }
    });
    
    // Validate input and handle auto-save
    cell.addEventListener('input', function(e) {
      // Cancel any pending save
      if (saveTimeout) {
        clearTimeout(saveTimeout);
      }
      
      // Clean the value to show just numbers
      const rawValue = this.textContent.replace(/[^0-9.-]+/g, '');
      const numValue = parseFloat(rawValue);
      
      if (isNaN(numValue)) {
        // Invalid input, will be corrected on blur
        return;
      }

        // Apply the styling to indicate editing is in progress
       this.classList.add('editing');

         // Update progress bar immediately with the new value
  SimBudget.updateProgressBar(categoryName, numValue);
      
    // Schedule auto-save after 1 second of no typing
  saveTimeout = setTimeout(() => {
    // Rest of your existing code for saving...
  }, 1000);
      // Store the current edit value
      currentEditValue = numValue;
      
      // Apply the styling to indicate editing is in progress
      this.classList.add('editing');
      
      // Schedule auto-save after 1 second of no typing
      saveTimeout = setTimeout(() => {
        // Get the final numeric value after timeout
        const cleanValue = this.textContent.replace(/[^0-9.-]+/g, '');
        const finalValue = parseFloat(cleanValue);
        
        // Don't save if invalid number
        if (isNaN(finalValue)) {
          this.classList.remove('editing');
          return;
        }
        
        // Don't save if the value hasn't changed significantly (within small rounding error)
        const currentDisplayedValue = parseFloat(this.dataset.value);
if (Math.abs(finalValue - currentDisplayedValue) < 0.001) {
  this.classList.remove('editing');
  return;
}
        
        // Indicate saving
        isSaving = true;
        this.classList.add('saving');
        
        // Format with currency symbol for display
        this.textContent = Utils.formatCurrency(finalValue);
        
        // KEY CHANGE: Use the SaveQueue instead of directly calling API
        SaveQueue.add(
          categoryName,
          finalValue,
          (result) => {
            // Update was successful
            isSaving = false;
            cell.classList.remove('editing', 'saving');
            cell.classList.add('saved');
             cell.dataset.value = finalValue;
            // Update our local data with the final value
            let budgetChanged = false;
            SimBudget._currentBudgetData.categories.forEach(cat => {
              if (cat.name === categoryName) {
                // Only mark changed if there's a significant difference
                if (Math.abs(cat.budgeted - finalValue) > 0.001) {
                  budgetChanged = true;
                  cat.budgeted = finalValue;
                }
              }
            });
            
            // Update cached data too
            if (window._dataCache && window._dataCache.budget && window._dataCache.budget.budget) {
              window._dataCache.budget.budget.categories.forEach(cat => {
                if (cat.name === categoryName) {
                  cat.budgeted = finalValue;
                }
              });
            }
            
            // Always update the info message based on local calculations
            SimBudget.updateInfoMessage(true); // Force update
            
            // Rerender the chart to reflect the changes
            SimBudget.renderExpenseChart(SimBudget._currentBudgetData.categories);
            
            // Show a subtle success indicator
            setTimeout(() => {
              cell.classList.remove('saved');
            }, 1500);
          },
          (error) => {
            // Update failed
            isSaving = false;
            cell.classList.remove('editing', 'saving');
            cell.classList.add('error');
            
            // Revert to original value
            cell.textContent = Utils.formatCurrency(originalValue);
            
            // Show error toast
            Utils.showToast('Error updating budget: ' + error, 'error');
            
            // Remove error indicator after a delay
            setTimeout(() => {
              cell.classList.remove('error');
            }, 1500);
          }
        );
      }, 1000); // Wait 1 second after typing stops
    });
    
    // Format value on blur
    cell.addEventListener('blur', function() {
      // Get numeric value
      const value = parseFloat(this.textContent.replace(/[^0-9.-]+/g, ''));
      if (!isNaN(value)) {
        // Format with currency symbol
        this.textContent = Utils.formatCurrency(value);
      } else {
        // If not a valid number, revert to original
        this.textContent = Utils.formatCurrency(originalValue);
      }
    });
    
    // Select all text when focused
    cell.addEventListener('focus', function() {
      const range = document.createRange();
      range.selectNodeContents(this);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    });
  });
};



})();

</script>